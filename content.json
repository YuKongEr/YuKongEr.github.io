{"meta":{"title":"yukong's blog","subtitle":"learning program","description":"你若对得起时间，时间便对得起你","author":"yukong","url":"http://www.yukonga.cn"},"pages":[{"title":"书单","date":"2020-03-30T06:12:16.263Z","updated":"2018-11-20T06:55:47.288Z","comments":false,"path":"books/index.html","permalink":"http://www.yukonga.cn/books/index.html","excerpt":"","text":""},{"title":"About","date":"2020-03-30T06:12:16.263Z","updated":"2019-05-14T02:01:26.890Z","comments":true,"path":"about/index.html","permalink":"http://www.yukonga.cn/about/index.html","excerpt":"","text":"本人笔名yukong,主要从事JAVA WEB开发，但同时懂一点vue.js react.js python 希望能与大家共同进步。交流群558509374、 公众号"},{"title":"友情链接","date":"2018-11-20T06:55:47.289Z","updated":"2018-11-20T06:55:47.289Z","comments":true,"path":"links/index.html","permalink":"http://www.yukonga.cn/links/index.html","excerpt":"","text":""},{"title":"Categories","date":"2020-03-30T06:12:15.746Z","updated":"2019-03-22T23:40:25.142Z","comments":false,"path":"categories/index.html","permalink":"http://www.yukonga.cn/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2018-11-20T06:55:47.289Z","updated":"2018-11-20T06:55:47.289Z","comments":false,"path":"repository/index.html","permalink":"http://www.yukonga.cn/repository/index.html","excerpt":"","text":""},{"title":"Tags","date":"2020-03-13T05:59:43.421Z","updated":"2019-03-22T23:39:19.334Z","comments":false,"path":"tags/index.html","permalink":"http://www.yukonga.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Seata-Server Rpc模块源码分析","slug":"Seata-Server-Rpc模块源码分析","date":"2020-04-13T07:57:19.000Z","updated":"2020-04-13T07:57:52.941Z","comments":true,"path":"2020/04/13/Seata-Server-Rpc模块源码分析/","link":"","permalink":"http://www.yukonga.cn/2020/04/13/Seata-Server-Rpc模块源码分析/","excerpt":"","text":"前言 上文已经介绍了Seata Server的启动流程 本文将继续上文的流程来分析一下Seata Server Rpc模块的实现。 Seata的RPC实现是基于Netty。借助Netty Seata可以很容易实现高性能的RPC通讯 Seata 目前允许配置的传输层配置如图所示，用户可根据需要进行Netty传输层面的调优，配置通过配置中心配置，首次加载时生效。具体参数配置参考官网。 Rpc模块介绍 首先来看看顶层UML图 整个类图中的顶层类可以分成三类 RemotingService 定义远程服务的开启与关闭 RpcServerBootstrap 负责启动Netty Server启动 监听请求 AbstractRpcRemoting 定义通用的请求发送响应(Server 与 Client复用逻辑) AbstractRpcRemotingServer 负责Server端的具体请求与发送 并且将请求委托给DefaultServerMessageListener来处理 ServerMessageSender 定义Server端中的发送请求的api DefaultServerMessageListener 负责具体的请求的业务逻辑处理 比如BeginGlobalTransaction Commit Rollback (其实它内部的业务逻辑是委托给Core来做的 后文我们会继续分析Coordinator Core模块)等 通过这三个顶层类可以很好的隔离业务逻辑。每个类都只做自己职责的事情 RemotingService负责Rpc服务的启动关闭 AbstractRpcRemoting 负责抽象的发送响应 ServerMessageSender Server端的rpc发送器(带业务逻辑) 处理流程 RpcServer#init()方法启动 1、配置对应的RpcServerHandler以及核心业务处理的监听器`DefaultServerMessageListener` 2、配置BootStrapServer 开始监听Client的请求 3、ServerMessageSender 用于处理Client不同类型请求 如果是TM TC Register 则保存对应的Channel映射 如果是全局事务的请求 则委托给`DefaultServerMessageListener`处理 首先我们看看AbstractRpcRemoting的源码 根据它定义的字段我们大概可以推测它实现的功能 发送请求 &amp;&amp; 支持异步发送 &amp;&amp; 支持异步获取请求结果 响应请求 支持BatchSend 消息合并发送 话不多说直接看源码, 关键地方我会加上注释 主要定义了一下公共的发送方法。它还有一个重要的内部类AbstracHandler 它是一个ChannelHandler用于处理Netty的请求 对于AbstractHandler而言 channelRead方法的代码幅度看来很长的 简单的理解一下就是 判断是不是 请求或者不需要Response的请求 如果是新请求 则交给消息请求处理线程池分发处理 如果不是请求那就是Response 则判断这个Response的原请求是否还在 如果还在则给原请求设置响应结果 如果不在 则交给消息请求处理线程池分发处理 另外对于channelRead 方法而言 我觉得if判断逻辑有点显得冗余 重复代码比较多 可以优化一下！ 读者有兴趣可以试试 ServerHandler 逻辑比较简单 在read方法 判断是不是TM 注册请求或者是心跳请求, 如果是则调用DefaultServerMessageListener处理，如果不是 则是RM请求 一个分布式事务中 一般只有一个TM多个RM 所以RM请求放入线程池中 异步处理。 经过上面的分析 我们已经大概清楚了流程 RpcServerBootstrap启动server监听请求 server收到请求到给ServerHandler处理 ServerHandler根据请求类型采用不同的策略处理 TM 心跳请求直接给DefaultServerMessageListener处理 RM请求放入任务线程池然后给DefaultServerMessageListener处理 以上都是流程公式化的代码 没有什么业务逻辑 接下来我们来看看DefaultServerMessageListener源码 看看它是如何实现TC中的业务逻辑处理 首先看看它的顶层接口ServerMessageListener 我们再看看实现类 DefaultServerMessageListenerImpl 上文中 TM注册 RM注册 心跳这个类型的业务逻辑处理很简单的，重要的事务请求的一个逻辑处理，但是它的具体逻辑是委托给Coordinator来做的,不属于RPC模块的内容，但是我们后文会继续分析。 总结 通过本文可以了解到Rpc Server端对于Client的请求处理流程是怎么样。知道了核心的全局事务处理逻辑是委托给Coordinator处理的。所以接下来我们会继续分析 Coordinator 模块是如何注册一个全局事务 分支事务的。","categories":[{"name":"seata","slug":"seata","permalink":"http://www.yukonga.cn/categories/seata/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.yukonga.cn/tags/java/"},{"name":"分布式事务","slug":"分布式事务","permalink":"http://www.yukonga.cn/tags/分布式事务/"},{"name":"seata","slug":"seata","permalink":"http://www.yukonga.cn/tags/seata/"}]},{"title":"128. Longest Consecutive Sequence(hard)","slug":"128-Longest-Consecutive-Sequence-hard","date":"2020-04-06T08:28:40.000Z","updated":"2020-04-06T08:29:47.019Z","comments":true,"path":"2020/04/06/128-Longest-Consecutive-Sequence-hard/","link":"","permalink":"http://www.yukonga.cn/2020/04/06/128-Longest-Consecutive-Sequence-hard/","excerpt":"[toc] 128. Longest Consecutive Sequence(hard) 原题链接 128. Longest Consecutive Sequence","text":"[toc] 128. Longest Consecutive Sequence(hard) 原题链接 128. Longest Consecutive Sequence 题意 解题思路 审题可得题意是想求得数组中最长的连续序列的长度,但是数组并不是有序数组。如果是有序数组这题完全可以用动态规划来解。 排序+动态规划 1、我们可以使用排序+动态规划 来解 时间复杂度是O(nlogn) 不符合题目要求 代码就不贴了 这只是思路的一种 归并集 2、我们可以使用 归并集来解 uf代表当前i的起始值 初始化为i cnt代表当前i为起始值的连续序列的长度 默认为1 遍历原数组 判断uf[i] 与 uf[i+1]的起始值是不是同一个 如果是同一个则代表当前两个位置已经连接 只需要返回cnt[i]就可以 如果不是同一个则需要连接起来 同时需要把两个序列的长度相加 AC代码 12345678910111213141516171819202122232425262728293031323334353637383940414243Map&lt;Integer, Integer&gt; um = new HashMap&lt;&gt;(); Map&lt;Integer, Integer&gt; cnt = new HashMap&lt;&gt;(); /** * 归并集解法 */ public int longestConsecutive(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return 0; &#125; for (int num : nums) &#123; um.put(num, num); cnt.put(num, 1); &#125; int ans = 1; for (int i : nums) &#123; if (i != Integer.MAX_VALUE &amp;&amp; um.containsKey(i + 1)) &#123; ans = Math.max(ans, merge(i, i + 1)); &#125; &#125; return ans; &#125; private int find(int i) &#123; if (i == um.get(i)) &#123; return i; &#125; // 压缩路径 int res = find(um.get(um.get(i))); um.put(i, res); return res; &#125; private int merge(int x, int y) &#123; int px = find(x); int py = find(y); if (px == py) &#123; return cnt.get(px); &#125; um.put(y, px); cnt.put(px, cnt.get(px) + cnt.get(py)); return cnt.get(px); &#125; HashSet 这题还可以使用Set的特性来解决，这些数字用一个 HashSet 保存，实现 O(1) 时间的查询，同时，我们只对 当前数字 - 1 不在哈希表里的数字，作为连续序列的第一个数字去找对应的最长序列，这是因为其他数字一定已经出现在了某个序列里。 AC代码 123456789101112131415161718192021public int longestConsecutive1(int[] nums) &#123; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for (int num : nums) &#123; set.add(num); &#125; int ans = 0; for(int i: set)&#123; // 假如一个数在哈希表中存在比他小的，那么它不是可以作为开头的数字 if(i != Integer.MIN_VALUE &amp;&amp; set.contains(i-1))&#123; continue; &#125; int cnt = 1; while(i!=Integer.MAX_VALUE &amp;&amp; set.contains(i+1))&#123; cnt ++; i++; &#125; ans = Math.max(ans, cnt); &#125; return ans; &#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.yukonga.cn/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.yukonga.cn/tags/leetcode/"},{"name":"算法","slug":"算法","permalink":"http://www.yukonga.cn/tags/算法/"},{"name":"归并集","slug":"归并集","permalink":"http://www.yukonga.cn/tags/归并集/"},{"name":"java","slug":"java","permalink":"http://www.yukonga.cn/tags/java/"}]},{"title":"395. Longest Substring with At Least K Repeating Characters","slug":"395. Longest Substring with At Least K Repeating Characters","date":"2020-04-04T15:59:59.000Z","updated":"2020-04-04T16:01:35.218Z","comments":true,"path":"2020/04/04/395. Longest Substring with At Least K Repeating Characters/","link":"","permalink":"http://www.yukonga.cn/2020/04/04/395. Longest Substring with At Least K Repeating Characters/","excerpt":"395. Longest Substring with At Least K Repeating Characters 原题链接 395. Longest Substring with At Least K Repeating Characters 解析思路 我们来思考一下什么样的情况可能可以构成连续的子串，每个字符都出现了至少k次；什么情况下又构不成？ 很显然如果字符串里有字符在整个串里都没出现k次，那么含有这个字符的子串一定是不可能成立的。所以我们可以通过这些小于k次的字符作为分隔符 把长字符串分成一个个子串, 采用分支算法求字符串中符合条件的长度 返回其中最长的。","text":"395. Longest Substring with At Least K Repeating Characters 原题链接 395. Longest Substring with At Least K Repeating Characters 解析思路 我们来思考一下什么样的情况可能可以构成连续的子串，每个字符都出现了至少k次；什么情况下又构不成？ 很显然如果字符串里有字符在整个串里都没出现k次，那么含有这个字符的子串一定是不可能成立的。所以我们可以通过这些小于k次的字符作为分隔符 把长字符串分成一个个子串, 采用分支算法求字符串中符合条件的长度 返回其中最长的。 AC代码 12345678910111213141516171819202122232425262728293031public int longestSubstring(String s, int k) &#123; return longestSubstring(s, 0, s.length() - 1, k); &#125; public int longestSubstring(String s, int begin, int end, int k) &#123; if (end - begin + 1 &lt; k) &#123; return 0; &#125; int[] chs = new int[26]; // 计算出现次数 for (int i = begin; i &lt;= end; i++) &#123; chs[s.charAt(i) - 'a'] = chs[s.charAt(i) - 'a'] + 1; &#125; // 跳过 次数小于k的 while (begin &lt; end &amp;&amp; chs[s.charAt(begin) - 'a'] &lt; k) &#123; begin++; &#125; while (begin &lt; end &amp;&amp; chs[s.charAt(end) - 'a'] &lt; k) &#123; end--; &#125; if (end - begin + 1 &lt; k) &#123; return 0; &#125; // 分而治之 for (int i = begin; i &lt;= end; i++) &#123; if (chs[s.charAt(i) - 'a'] &lt; k) &#123; return Math.max(longestSubstring(s, begin, i - 1, k), longestSubstring(s, i + 1, end, k)); &#125; &#125; return end - begin + 1; &#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.yukonga.cn/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.yukonga.cn/tags/leetcode/"},{"name":"java","slug":"java","permalink":"http://www.yukonga.cn/tags/java/"},{"name":"分治算法","slug":"分治算法","permalink":"http://www.yukonga.cn/tags/分治算法/"}]},{"title":"Seata-Server 启动流程源码分析","slug":"Seata-Server-启动流程源码分析","date":"2020-04-02T05:19:03.000Z","updated":"2020-04-02T05:50:09.404Z","comments":true,"path":"2020/04/02/Seata-Server-启动流程源码分析/","link":"","permalink":"http://www.yukonga.cn/2020/04/02/Seata-Server-启动流程源码分析/","excerpt":"认识Seata Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案。","text":"认识Seata Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案。 Seata的TXC模型 根据上图可知整个TXC模型有三个重要的组件 TC 事务协调器,维护全局和分支事务的状态，驱动全局事务提交或回滚。(单独部署) TM 事务管理器 定义全局事务的范围：开始全局事务、提交或回滚全局事务。 RM 资源管理器 管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。 简单理解就是TM事务管理器通过RPC与TC通讯请求开启一个全局事务 简单理解过程就是: Business作为服务起始方(此时它是TM)发起全局事务并注册到TC。在调用协同服务时，协同服务的事务分支事务会先完成阶段一的事务提交或回滚，并生成事务回滚的undo_log日志，同时注册当前服务到TC并上报其事务状态，归并到同一个业务的全局事务中。此时若没有问题继续下一个服务的调用，期间任何服务的分支事务回滚，都会通知到TC，TC在通知全局事务包含的所有已完成一阶段提交的分支事务回滚。如果所有分支事务都正常，最后回到全局事务发起方时，也会通知到TC，TC在通知全局事务包含的所有分支删除回滚日志。在这个过程中为了解决写隔离和度隔离的问题会涉及到TC管理的全局锁。 那么全局事务是如何在服务中传递的呢？实际在TM向TC请求开启一个全局事务的时候，TC会响应一个全局事务XID，只需要TM在调用其他协同服务时把XID传递给协同服务，这样就可以实现全局事务在分布式服务中传播，以及分支事务属于哪个全局事务。 Seata目前已经支持许多框架中的XID的自动传递了 dubbo spring cloud sofa-rpc 用户在使用Seata的时候对于XID的传递完全是无感知。 上文提到Seata中三个重要的组件TC TM RM. 其中TC作为事务协调者, 它负责驱动全局事务的提交与回滚。根据它的职责可知。它的重要性不言而喻。 那么作为一个优秀的协调者它需要具备哪些功能呢？ 高可用 高性能 支持扩展 那么我们根据我们的猜测来看看TC的实现模块Server是怎么来实现这写功能的。 Server模块介绍 整个Server模块可以分成7个主要模块 RPC模块 负责与TM RM交互 Coordinator Core模块 TC实现事务协调的核心模块 Lock模块 资源全局锁的实现 Config模块 支持配置TC的配置模块 Store模块 TC运行时全局事务以及分支事务的相关信息需要通过Store模块持久化 Discover模块 Seata TC服务注册发现模块 HA-Cluste模块 TC Server实现高可用的模块 就一个Server端而言, 它就有7个模块。那么我们改从何看起呢。 我们可以用Server启动的main函数来理解清楚整个TC的运行流程 Server启动流程 本文所有源码基于Seata1.1.0 个人能力有限,如有不对欢迎指出。 整个Server端是一个java应用,它是通过java -jar启动的,所以主入口是一个main函数。 入口地址是io.seata.server.Server#main() 123456789101112131415161718192021222324252627282930313233343536373839404142434445public static void main(String[] args) throws IOException &#123; //1、 参数解析 ParameterParser parameterParser = new ParameterParser(args); //2、 监控初始化 MetricsManager.get().init(); // 3、将存储模式放到系统环境变量÷ System.setProperty(ConfigurationKeys.STORE_MODE, parameterParser.getStoreMode()); // 4、创建与RM TM通讯的rpc服务器 RpcServer rpcServer = new RpcServer(WORKING_THREADS); //server port rpcServer.setListenPort(parameterParser.getPort()); UUIDGenerator.init(parameterParser.getServerNode()); //log store mode : file, db // 5、设置资源存储模式 SessionHolder.init(parameterParser.getStoreMode()); // 6、核心事务协调器创建 DefaultCoordinator coordinator = new DefaultCoordinator(rpcServer); coordinator.init(); // 7、把协调器作为一个回调 传给netty rpc模块 rpcServer.setHandler(coordinator); // 8、注册JVM关闭构造函数 ShutdownHook.getInstance().addDisposable(coordinator); ShutdownHook.getInstance().addDisposable(rpcServer); //127.0.0.1 and 0.0.0.0 are not valid here. if (NetUtil.isValidIp(parameterParser.getHost(), false)) &#123; XID.setIpAddress(parameterParser.getHost()); &#125; else &#123; XID.setIpAddress(NetUtil.getLocalIp()); &#125; XID.setPort(rpcServer.getListenPort()); try &#123; // 9、启动RPC模块 监听TM RM的请求 rpcServer.init(); &#125; catch (Throwable e) &#123; LOGGER.error(\"rpcServer init error:&#123;&#125;\", e.getMessage(), e); System.exit(-1); &#125; System.exit(0); &#125; 首先看看参数解析,其实参数解析很简单主要是通过JCommander解析main函数中的args数组,不过在需要注意的是,由于Seata Server已经支持容器部署, 所以在容器环境启动参数的创建跟正常启动的参数是不同的。容器部署的启动参数需要通过System.getenv获取 io.seata.server.ParameterParser#init() 12345678910111213141516171819202122232425262728293031323334353637private void init(String[] args) &#123; try &#123; // 判断启动环境是否是容器 boolean inContainer = this.isRunningInContainer(); // 如果是容器启动 则从系统环境变量读取参数配置 if (inContainer) &#123; if (LOGGER.isInfoEnabled()) &#123; LOGGER.info(\"The server is running in container.\"); &#125; this.seataEnv = StringUtils.trimToNull(System.getenv(ENV_SYSTEM_KEY)); this.host = StringUtils.trimToNull(System.getenv(ENV_SEATA_IP_KEY)); this.serverNode = NumberUtils.toInt(System.getenv(ENV_SERVER_NODE_KEY), SERVER_DEFAULT_NODE); this.port = NumberUtils.toInt(System.getenv(ENV_SEATA_PORT_KEY), SERVER_DEFAULT_PORT); this.storeMode = StringUtils.trimToNull(System.getenv(ENV_STORE_MODE_KEY)); &#125; else &#123; // 否则使用JCommander 解析启动参数 JCommander jCommander = JCommander.newBuilder().addObject(this).build(); jCommander.parse(args); if (help) &#123; jCommander.setProgramName(PROGRAM_NAME); jCommander.usage(); System.exit(0); &#125; &#125; if (StringUtils.isNotBlank(seataEnv)) &#123; System.setProperty(ENV_PROPERTY_KEY, seataEnv); &#125; if (StringUtils.isBlank(storeMode)) &#123; storeMode = ConfigurationFactory.getInstance().getConfig(ConfigurationKeys.STORE_MODE, SERVER_DEFAULT_STORE_MODE); &#125; &#125; catch (ParameterException e) &#123; printError(e); &#125; &#125; 拿到启动参数后我们就要根据启动参数依次 启动监控、设置存储模型，创建协调核心对象、启动Rpc服务器。 为什么Rpc服务器要在最后一个启动呢？ 下篇文章会解答。 由于监控对Seata的核心功能暂无影响所以本文已经后续文章暂不对监控进行分析。 总结 本文简单的介绍了一下Seata Server模块启动流程的一个分析，了解Seata的启动流程,但是都是比较简单没有深入，后续会陆续深入分析Rpc模块与核心协调模块。","categories":[{"name":"seata","slug":"seata","permalink":"http://www.yukonga.cn/categories/seata/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.yukonga.cn/tags/java/"},{"name":"分布式事务","slug":"分布式事务","permalink":"http://www.yukonga.cn/tags/分布式事务/"},{"name":"seata","slug":"seata","permalink":"http://www.yukonga.cn/tags/seata/"}]},{"title":"230. Kth Smallest Element in a BST","slug":"230-Kth-Smallest-Element-in-a-BST","date":"2020-03-30T03:44:20.000Z","updated":"2020-04-02T05:29:25.309Z","comments":true,"path":"2020/03/30/230-Kth-Smallest-Element-in-a-BST/","link":"","permalink":"http://www.yukonga.cn/2020/03/30/230-Kth-Smallest-Element-in-a-BST/","excerpt":"230. Kth Smallest Element in a BST 原题地址 230. Kth Smallest Element in a BST 解题思路 由于给的二叉搜索树，总所周知二叉搜索树的中序遍历是有序的。所以这题可以变相的理解的为有序数组的中的第k个数 二叉树的中路遍历有两种方法, 递归、非递归(借助 栈). 我们先看递归","text":"230. Kth Smallest Element in a BST 原题地址 230. Kth Smallest Element in a BST 解题思路 由于给的二叉搜索树，总所周知二叉搜索树的中序遍历是有序的。所以这题可以变相的理解的为有序数组的中的第k个数 二叉树的中路遍历有两种方法, 递归、非递归(借助 栈). 我们先看递归 递归解法-1 我们通过中序遍历,把遍历的值存在List&lt;Integer&gt; res 中, 然后返回res.get(k -1) 即,.很容易写出如下代码. AC代码 123456789101112131415public int kthSmallest(TreeNode root, int k) &#123; ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;(); inorder(root, res); return res.get(k - 1);&#125;private ArrayList&lt;Integer&gt; inorder(TreeNode root, ArrayList&lt;Integer&gt; res) &#123; if (root == null) &#123; return res; &#125; inorder(root.left, res); res.add(root.val); inorder(root.right, res); return res;&#125; 很明显时间复杂是O(n),空间复杂度是O(n). 递归解法-2 其实我们没用必要记录每个节点的值, 我们只需要遍历到第k个节点, 并且记录它的值即可,虽然这样不能避免递归的次数,但是可以空间复杂度到O(1). AC代码 很容易写出如下代码. 1234567891011121314151617181920private int num = 0;private int count = 0;public int kthSmallest(TreeNode root, int k) &#123; inorder(root, k); return num;&#125;private void inorder(TreeNode root, int k) &#123; // 减枝 if (root == null || count &gt;= k) &#123; return; &#125; inorder(root.left, k); count++; if (k == count) &#123; num = root.val; &#125; inorder(root.right, k);&#125; 时间复杂是O(n),空间复杂度是O(1). 非递归解法(栈) 总所周知通过栈我们能实现二叉树的中序遍历, 非递归的遍历的好处就是我们能提前结束,而不需等到整个二叉树遍历完. 同时在遍历的时候取第k个数的值即可. AC代码 代码如下 1234567891011121314public int kthSmallest(TreeNode root, int k) &#123; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); while (true) &#123; while (root != null) &#123; stack.push(root); root = root.left; &#125; root = stack.pop(); if (--k == 0) &#123; return root.val; &#125; root = root.right; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.yukonga.cn/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.yukonga.cn/tags/leetcode/"},{"name":"算法","slug":"算法","permalink":"http://www.yukonga.cn/tags/算法/"},{"name":"java","slug":"java","permalink":"http://www.yukonga.cn/tags/java/"},{"name":"BST","slug":"BST","permalink":"http://www.yukonga.cn/tags/BST/"}]},{"title":"LeetCode-951. Flip Equivalent Binary Trees","slug":"LeetCode-951-Flip-Equivalent-Binary-Trees","date":"2019-05-28T06:19:41.000Z","updated":"2019-05-28T06:29:32.503Z","comments":true,"path":"2019/05/28/LeetCode-951-Flip-Equivalent-Binary-Trees/","link":"","permalink":"http://www.yukonga.cn/2019/05/28/LeetCode-951-Flip-Equivalent-Binary-Trees/","excerpt":"原题链接 题目描述 我们可以为二叉树 T 定义一个翻转操作，如下所示：选择任意节点，然后交换它的左子树和右子树。 只要经过一定次数的翻转操作后，能使 X 等于 Y，我们就称二叉树 X 翻转等价于二叉树 Y。 编写一个判断两个二叉树是否是翻转等价的函数。这些树由根节点 root1 和 root2 给出。","text":"原题链接 题目描述 我们可以为二叉树 T 定义一个翻转操作，如下所示：选择任意节点，然后交换它的左子树和右子树。 只要经过一定次数的翻转操作后，能使 X 等于 Y，我们就称二叉树 X 翻转等价于二叉树 Y。 编写一个判断两个二叉树是否是翻转等价的函数。这些树由根节点 root1 和 root2 给出。 示例： 123输入：root1 = [1,2,3,4,5,6,null,null,null,7,8], root2 = [1,3,2,null,6,4,5,null,null,null,null,8,7]输出：true解释：We flipped at nodes with values 1, 3, and 5. 解题思路 从跟节点开始 递归判断 两种情况 不需要反转(或者说是反转两次) 或者是需要反转一次 对应的情况： 需要反转 那就是左子树等于左子树 ， 右子树等于右子树 不需要反转 那就是左子树等于右子树 ， 右子树等于左子树 AC代码 123456789101112131415161718public boolean flipEquiv(TreeNode root1, TreeNode root2) &#123; if(root1==null&amp;&amp;root2==null)&#123; return true; &#125;else if( (root1 == null &amp;&amp; root2 != null) || (root1 != null &amp;&amp; root2 == null))&#123; return false; &#125; if(root1.val!=root2.val)&#123; return false; &#125; if((flipEquiv(root1.left,root2.left) &amp;&amp; flipEquiv(root1.right,root2.right)) || (flipEquiv(root1.left,root2.right) &amp;&amp; flipEquiv(root1.right,root2.left)))&#123; return true; &#125;else&#123; return false; &#125; &#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.yukonga.cn/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.yukonga.cn/tags/leetcode/"},{"name":"算法","slug":"算法","permalink":"http://www.yukonga.cn/tags/算法/"},{"name":"java","slug":"java","permalink":"http://www.yukonga.cn/tags/java/"},{"name":"递归","slug":"递归","permalink":"http://www.yukonga.cn/tags/递归/"}]},{"title":"LeetCode-338 Counting Bits","slug":"LeetCode-338-Counting-Bits","date":"2019-05-27T07:27:15.000Z","updated":"2019-05-27T07:42:16.867Z","comments":true,"path":"2019/05/27/LeetCode-338-Counting-Bits/","link":"","permalink":"http://www.yukonga.cn/2019/05/27/LeetCode-338-Counting-Bits/","excerpt":"","text":"原题链接 题目描述 给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。 示例 1: 12输入: 2输出: [0,1,1] 示例 2: 12输入: 5输出: [0,1,1,2,1,2] 进阶: 给出时间复杂度为**O(n*sizeof(integer))的解答非常容易。但你可以在线性时间O(n)**内用一趟扫描做到吗？ 要求算法的空间复杂度为O(n)。 你能进一步完善解法吗？要求在C或任何其他语言中不使用任何内置函数（如 C 中的 __builtin_popcount）来执行此操作。 解题思路 i &amp; (i - 1)去掉i最右边的一个1；因i &amp; (i - 1）&lt; i，故result[i &amp; (i - 1)]已计算，所以i中1的个数为result[i &amp; (i - 1)] + 1 AC代码 123456789public int[] countBits(int num) &#123; int[] res = new int[num + 1]; for (int i = 1; i &lt;= num ; i++) &#123; res[i] = res[i &amp; (i - 1)] + 1; &#125; return res;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.yukonga.cn/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.yukonga.cn/tags/leetcode/"},{"name":"算法","slug":"算法","permalink":"http://www.yukonga.cn/tags/算法/"},{"name":"java","slug":"java","permalink":"http://www.yukonga.cn/tags/java/"}]},{"title":"【SpringSecurity系列02】SpringSecurity UsernamePasswordAuthenticationFilter认证逻辑源码解读","slug":"【SpringSecurity系列02】SpringSecurity UsernamePasswordAuthenticationFilter认证逻辑源码解读","date":"2019-04-12T07:58:25.000Z","updated":"2019-07-27T06:07:47.719Z","comments":true,"path":"2019/04/12/【SpringSecurity系列02】SpringSecurity UsernamePasswordAuthenticationFilter认证逻辑源码解读/","link":"","permalink":"http://www.yukonga.cn/2019/04/12/【SpringSecurity系列02】SpringSecurity UsernamePasswordAuthenticationFilter认证逻辑源码解读/","excerpt":"概要 前面一节，通过简单配置即可实现SpringSecurity表单认证功能，而今天这一节将通过阅读源码的形式来学习SpringSecurity是如何实现这些功能, 前方高能预警，本篇分析源码篇幅较长。","text":"概要 前面一节，通过简单配置即可实现SpringSecurity表单认证功能，而今天这一节将通过阅读源码的形式来学习SpringSecurity是如何实现这些功能, 前方高能预警，本篇分析源码篇幅较长。 过滤器链 前面我说过SpringSecurity是基于过滤器链的形式，那么我解析将会介绍一下具体有哪些过滤器。 Filter Class 介绍 SecurityContextPersistenceFilter 判断当前用户是否登录 CrsfFilter 用于防止csrf攻击 LogoutFilter 处理注销请求 UsernamePasswordAuthenticationFilter 处理表单登录的请求(也是我们今天的主角) BasicAuthenticationFilter 处理http basic认证的请求 由于过滤器链中的过滤器实在太多，我没有一一列举，调了几个比较重要的介绍一下。 通过上面我们知道SpringSecurity对于表单登录的认证请求是交给了UsernamePasswordAuthenticationFilter处理的，那么具体的认证流程如下： 从上图可知，UsernamePasswordAuthenticationFilter继承于抽象类AbstractAuthenticationProcessingFilter。 具体认证是： 进入doFilter方法，判断是否要认证，如果需要认证则进入attemptAuthentication方法，如果不需要直接结束 attemptAuthentication方法中根据username跟password构造一个UsernamePasswordAuthenticationToken对象(此时的token是未认证的)，并且将它交给ProviderManger来完成认证。 ProviderManger中维护这一个AuthenticationProvider对象列表，通过遍历判断并且最后选择DaoAuthenticationProvider对象来完成最后的认证。 DaoAuthenticationProvider根据ProviderManger传来的token取出username，并且调用我们写的UserDetailsService的loadUserByUsername方法从数据库中读取用户信息，然后对比用户密码，如果认证通过，则返回用户信息也是就是UserDetails对象，在重新构造UsernamePasswordAuthenticationToken(此时的token是 已经认证通过了的)。 接下来我们将通过源码来分析具体的整个认证流程。 AbstractAuthenticationProcessingFilter AbstractAuthenticationProcessingFilter 是一个抽象类。所有的认证认证请求的过滤器都会继承于它，它主要将一些公共的功能实现，而具体的验证逻辑交给子类实现，有点类似于父类设置好认证流程，子类负责具体的认证逻辑，这样跟设计模式的模板方法模式有点相似。 现在我们分析一下 它里面比较重要的方法 1、doFilter 12345678910111213141516171819202122232425262728293031public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException &#123; // 省略不相干代码。。。 // 1、判断当前请求是否要认证 if (!requiresAuthentication(request, response)) &#123; // 不需要直接走下一个过滤器 chain.doFilter(request, response); return; &#125; try &#123; // 2、开始请求认证，attemptAuthentication具体实现给子类，如果认证成功返回一个认证通过的Authenticaion对象 authResult = attemptAuthentication(request, response); if (authResult == null) &#123; return; &#125; // 3、登录成功 将认证成功的用户信息放入session SessionAuthenticationStrategy接口，用于扩展 sessionStrategy.onAuthentication(authResult, request, response); &#125; catch (InternalAuthenticationServiceException failed) &#123; //2.1、发生异常，登录失败，进入登录失败handler回调 unsuccessfulAuthentication(request, response, failed); return; &#125; catch (AuthenticationException failed) &#123; //2.1、发生异常，登录失败，进入登录失败处理器 unsuccessfulAuthentication(request, response, failed); return; &#125; // 3.1、登录成功，进入登录成功处理器。 successfulAuthentication(request, response, chain, authResult); &#125; 2、successfulAuthentication 登录成功处理器 123456789101112131415161718protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response, FilterChain chain, Authentication authResult) throws IOException, ServletException &#123; //1、登录成功 将认证成功的Authentication对象存入SecurityContextHolder中 // SecurityContextHolder本质是一个ThreadLocal SecurityContextHolder.getContext().setAuthentication(authResult); //2、如果开启了记住我功能，将调用rememberMeServices的loginSuccess 将生成一个token // 将token放入cookie中这样 下次就不用登录就可以认证。具体关于记住我rememberMeServices的相关分析我 们下面几篇文章会深入分析的。 rememberMeServices.loginSuccess(request, response, authResult); // Fire event //3、发布一个登录事件。 if (this.eventPublisher != null) &#123; eventPublisher.publishEvent(new InteractiveAuthenticationSuccessEvent( authResult, this.getClass())); &#125; //4、调用我们自己定义的登录成功处理器，这样也是我们扩展得知登录成功的一个扩展点。 successHandler.onAuthenticationSuccess(request, response, authResult); &#125; 3、unsuccessfulAuthentication 登录失败处理器 12345678910protected void unsuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response, AuthenticationException failed) throws IOException, ServletException &#123; //1、登录失败，将SecurityContextHolder中的信息清空 SecurityContextHolder.clearContext(); //2、关于记住我功能的登录失败处理 rememberMeServices.loginFail(request, response); //3、调用我们自己定义的登录失败处理器，这里可以扩展记录登录失败的日志。 failureHandler.onAuthenticationFailure(request, response, failed); &#125; 关于AbstractAuthenticationProcessingFilter主要分析就到这。我们可以从源码中知道，当请求进入该过滤器中具体的流程是 判断该请求是否要被认证 调用attemptAuthentication方法开始认证，由于是抽象方法具体认证逻辑给子类 如果登录成功，则将认证结果Authentication对象根据session策略写入session中，将认证结果写入到SecurityContextHolder,如果开启了记住我功能，则根据记住我功能，生成token并且写入cookie中，最后调用一个successHandler对象的方法，这个对象可以是我们配置注入的，用于处理我们的自定义登录成功的一些逻辑（比如记录登录成功日志等等）。 如果登录失败，则清空SecurityContextHolder中的信息，并且调用我们自己注入的failureHandler对象，处理我们自己的登录失败逻辑。 UsernamePasswordAuthenticationFilter 从上面分析我们可以知道，UsernamePasswordAuthenticationFilter是继承于AbstractAuthenticationProcessingFilter，并且实现它的attemptAuthentication方法，来实现认证具体的逻辑实现。接下来，我们通过阅读UsernamePasswordAuthenticationFilter的源码来解读，它是如何完成认证的。 由于这里会涉及UsernamePasswordAuthenticationToken对象构造，所以我们先看看UsernamePasswordAuthenticationToken的源码 1、UsernamePasswordAuthenticationToken 12345678910111213141516171819202122232425262728293031// 继承至AbstractAuthenticationToken // AbstractAuthenticationToken主要定义一下在SpringSecurity中toke需要存在一些必须信息// 例如权限集合 Collection&lt;GrantedAuthority&gt; authorities; 是否认证通过boolean authenticated = false;认证通过的用户信息Object details;public class UsernamePasswordAuthenticationToken extends AbstractAuthenticationToken &#123; // 未登录情况下 存的是用户名 登录成功情况下存的是UserDetails对象 private final Object principal; // 密码 private Object credentials; /** * 构造函数，用户没有登录的情况下，此时的authenticated是false，代表尚未认证 */ public UsernamePasswordAuthenticationToken(Object principal, Object credentials) &#123; super(null); this.principal = principal; this.credentials = credentials; setAuthenticated(false); &#125; /** * 构造函数，用户登录成功的情况下，多了一个参数 是用户的权限集合，此时的authenticated是true，代表认证成功 */ public UsernamePasswordAuthenticationToken(Object principal, Object credentials, Collection&lt;? extends GrantedAuthority&gt; authorities) &#123; super(authorities); this.principal = principal; this.credentials = credentials; super.setAuthenticated(true); // must use super, as we override &#125;&#125; 接下来我们就可以分析attemptAuthentication方法了。 2、attemptAuthentication 123456789101112131415161718192021222324252627public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException &#123; // 1、判断是不是post请求，如果不是则抛出AuthenticationServiceException异常，注意这里抛出的异常都在AbstractAuthenticationProcessingFilter#doFilter方法中捕获，捕获之后会进入登录失败的逻辑。 if (postOnly &amp;&amp; !request.getMethod().equals(\"POST\")) &#123; throw new AuthenticationServiceException( \"Authentication method not supported: \" + request.getMethod()); &#125; // 2、从request中拿用户名跟密码 String username = obtainUsername(request); String password = obtainPassword(request); // 3、非空处理，防止NPE异常 if (username == null) &#123; username = \"\"; &#125; if (password == null) &#123; password = \"\"; &#125; // 4、除去空格 username = username.trim(); // 5、根据username跟password构造出一个UsernamePasswordAuthenticationToken对象 从上文分析可知道，此时的token是未认证的。 UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken( username, password); // 6、配置一下其他信息 ip 等等 setDetails(request, authRequest); // 7、调用ProviderManger的authenticate的方法进行具体认证逻辑 return this.getAuthenticationManager().authenticate(authRequest); &#125; ProviderManager 维护一个AuthenticationProvider列表，进行认证逻辑验证 1、authenticate 123456789101112131415161718192021222324252627282930313233343536public Authentication authenticate(Authentication authentication) throws AuthenticationException &#123; // 1、拿到token的类型。 Class&lt;? extends Authentication&gt; toTest = authentication.getClass(); AuthenticationException lastException = null; Authentication result = null; // 2、遍历AuthenticationProvider列表 for (AuthenticationProvider provider : getProviders()) &#123; // 3、AuthenticationProvider不支持当前token类型，则直接跳过 if (!provider.supports(toTest)) &#123; continue; &#125; try &#123; // 4、如果Provider支持当前token，则交给Provider完成认证。 result = provider.authenticate(authentication); &#125; catch (AccountStatusException e) &#123; throw e; &#125; catch (InternalAuthenticationServiceException e) &#123; throw e; &#125; catch (AuthenticationException e) &#123; lastException = e; &#125; &#125; // 5、登录成功 返回登录成功的token if (result != null) &#123; eventPublisher.publishAuthenticationSuccess(result); return result; &#125; &#125; AbstractUserDetailsAuthenticationProvider 1、authenticate AbstractUserDetailsAuthenticationProvider实现了AuthenticationProvider接口，并且实现了部分方法，DaoAuthenticationProvider继承于AbstractUserDetailsAuthenticationProvider类，所以我们先来看看AbstractUserDetailsAuthenticationProvider的实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public abstract class AbstractUserDetailsAuthenticationProvider implements AuthenticationProvider, InitializingBean, MessageSourceAware &#123; // 国际化处理 protected MessageSourceAccessor messages = SpringSecurityMessageSource.getAccessor(); /** * 对token一些检查，具体检查逻辑交给子类实现，抽象方法 */ protected abstract void additionalAuthenticationChecks(UserDetails userDetails, UsernamePasswordAuthenticationToken authentication) throws AuthenticationException; /** * 认证逻辑的实现，调用抽象方法retrieveUser根据username获取UserDetails对象 */ public Authentication authenticate(Authentication authentication) throws AuthenticationException &#123; // 1、获取usernmae String username = (authentication.getPrincipal() == null) ? \"NONE_PROVIDED\" : authentication.getName(); // 2、尝试去缓存中获取UserDetails对象 UserDetails user = this.userCache.getUserFromCache(username); // 3、如果为空，则代表当前对象没有缓存。 if (user == null) &#123; cacheWasUsed = false; try &#123; //4、调用retrieveUser去获取UserDetail对象，为什么这个方法是抽象方法大家很容易知道，如果UserDetail信息存在关系数据库 则可以重写该方法并且去关系数据库获取用户信息，如果UserDetail信息存在其他地方，可以重写该方法用其他的方法去获取用户信息，这样丝毫不影响整个认证流程，方便扩展。 user = retrieveUser(username, (UsernamePasswordAuthenticationToken) authentication); &#125; catch (UsernameNotFoundException notFound) &#123; // 捕获异常 日志处理 并且往上抛出，登录失败。 if (hideUserNotFoundExceptions) &#123; throw new BadCredentialsException(messages.getMessage( \"AbstractUserDetailsAuthenticationProvider.badCredentials\", \"Bad credentials\")); &#125; else &#123; throw notFound; &#125; &#125; &#125; try &#123; // 5、前置检查 判断当前用户是否锁定，禁用等等 preAuthenticationChecks.check(user); // 6、其他的检查，在DaoAuthenticationProvider是检查密码是否一致 additionalAuthenticationChecks(user, (UsernamePasswordAuthenticationToken) authentication); &#125; catch (AuthenticationException exception) &#123; &#125; // 7、后置检查，判断密码是否过期 postAuthenticationChecks.check(user); // 8、登录成功通过UserDetail对象重新构造一个认证通过的Token对象 return createSuccessAuthentication(principalToReturn, authentication, user); &#125; protected Authentication createSuccessAuthentication(Object principal, Authentication authentication, UserDetails user) &#123; // 调用第二个构造方法，构造一个认证通过的Token对象 UsernamePasswordAuthenticationToken result = new UsernamePasswordAuthenticationToken( principal, authentication.getCredentials(), authoritiesMapper.mapAuthorities(user.getAuthorities())); result.setDetails(authentication.getDetails()); return result; &#125;&#125; 接下来我们具体看看retrieveUser的实现，没看源码大家应该也可以知道，retrieveUser方法应该是调用UserDetailsService去数据库查询是否有该用户，以及用户的密码是否一致。 DaoAuthenticationProvider DaoAuthenticationProvider 主要是通过UserDetailService来获取UserDetail对象。 1、retrieveUser 123456789101112131415protected final UserDetails retrieveUser(String username, UsernamePasswordAuthenticationToken authentication) throws AuthenticationException &#123; try &#123; // 1、调用UserDetailsService接口的loadUserByUsername方法获取UserDeail对象 UserDetails loadedUser = this.getUserDetailsService().loadUserByUsername(username); // 2、如果loadedUser为null 代表当前用户不存在，抛出异常 登录失败。 if (loadedUser == null) &#123; throw new InternalAuthenticationServiceException( \"UserDetailsService returned null, which is an interface contract violation\"); &#125; // 3、返回查询的结果 return loadedUser; &#125; &#125; 2、additionalAuthenticationChecks 1234567891011121314151617181920212223protected void additionalAuthenticationChecks(UserDetails userDetails, UsernamePasswordAuthenticationToken authentication) throws AuthenticationException &#123; // 1、如果密码为空，则抛出异常、 if (authentication.getCredentials() == null) &#123; throw new BadCredentialsException(messages.getMessage( \"AbstractUserDetailsAuthenticationProvider.badCredentials\", \"Bad credentials\")); &#125; // 2、获取用户输入的密码 String presentedPassword = authentication.getCredentials().toString(); // 3、调用passwordEncoder的matche方法 判断密码是否一致 if (!passwordEncoder.matches(presentedPassword, userDetails.getPassword())) &#123; logger.debug(\"Authentication failed: password does not match stored value\"); // 4、如果不一致 则抛出异常。 throw new BadCredentialsException(messages.getMessage( \"AbstractUserDetailsAuthenticationProvider.badCredentials\", \"Bad credentials\")); &#125; &#125; 总结 至此，整认证流程已经分析完毕，大家如果有什么不懂可以关注我的公众号一起讨论。 学习是一个漫长的过程，学习源码可能会很困难但是只要努力一定就会有获取，大家一致共勉。","categories":[{"name":"SpringSecurity","slug":"SpringSecurity","permalink":"http://www.yukonga.cn/categories/SpringSecurity/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://www.yukonga.cn/tags/SpringBoot/"},{"name":"SpringSecurity","slug":"SpringSecurity","permalink":"http://www.yukonga.cn/tags/SpringSecurity/"}]},{"title":"【SpringSecurity系列01】初识SpringSecurity","slug":"【SpringSecurity系列01】初识SpringSecurity","date":"2019-04-11T08:20:09.000Z","updated":"2019-05-24T09:27:17.373Z","comments":true,"path":"2019/04/11/【SpringSecurity系列01】初识SpringSecurity/","link":"","permalink":"http://www.yukonga.cn/2019/04/11/【SpringSecurity系列01】初识SpringSecurity/","excerpt":"​ 什么是SpringSecurity ？","text":"​ 什么是SpringSecurity ？ ​ Spring Security是一个能够为基于Spring的企业应用系统提供声明式的安全访问控制解决方案的安全框架。它提供了一组可以在Spring应用上下文中配置的Bean，充分利用了Spring IoC，DI（控制反转Inversion of Control ,DI:Dependency Injection 依赖注入）和AOP（面向切面编程）功能，为应用系统提供声明式的安全访问控制功能，减少了为企业系统安全控制编写大量重复代码的工作。 以上来介绍来自wiki，比较官方。 ​ 用自己的话 简单介绍一下，Spring Security基于 Servlet 过滤器链的形式，为我们的web项目提供认证与授权服务。它来自于Spring，那么它与SpringBoot整合开发有着天然的优势，目前与SpringSecurity对应的开源框架还有shiro。接下来我将通过一个简单的例子带大家来认识SpringSecurity,然后通过分析它的源码带大家来认识一下SpringSecurity是如何工作，从一个简单例子入门，大家由浅入深的了解学习SpringSecurity。 通常大家在做一个后台管理的系统的时候，应该采用session判断用户是否登录。我记得我在没有接触学习SpringSecurity与shiro之前。对于用户登录功能实现通常是如下： 123456789101112public String login(User user, HttpSession session)&#123; //1、根据用户名或者id从数据库读取数据库中用户 //2、判断密码是否一致 //3、如果密码一致 session.setAttribute(\"user\",user); //4、否则返回登录页面 &#125;对于之后那些需要登录之后才能访问的url，通过SpringMvc的拦截器中的#preHandle来判断session中是否有user对象如果没有 则返回登录页面如果有， 则允许访问这个页面。 但是在SpringSecurity中，这一些逻辑已经被封装起来，我们只需要简单的配置一下就能使用。 接下来我通过一个简单例子大家认识一下SpringSecurity 本文基于SpringBoot，如果大家对SpringBoot不熟悉的话可以看看我之前写的SpringBoot入门系列 我使用的是： SpringBoot 2.1.4.RELEASE SpringSecurity 5 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.4.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.yukong&lt;/groupId&gt; &lt;artifactId&gt;springboot-springsecurity&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;springboot-springsecurity&lt;/name&gt; &lt;description&gt;springboot-springsecurity study&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 配置一下数据库 以及MyBatis 1234567spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://127.0.0.1:3306/db_test?useUnicode=true&amp;characterEncoding=utf8 password: abc123mybatis: mapper-locations: classpath:mapper/*.xml 这里我用的MySQL8.0 大家注意一下 MySQL8.0的数据库驱动的类的包改名了 在前面我有讲过SpringBoot中如何整合Mybatis，在这里我就不累述，有需要的话看这篇文章 user.sql 12345678CREATE TABLE `user` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键', `username` varchar(32) NOT NULL COMMENT '用户名', `svc_num` varchar(32) DEFAULT NULL COMMENT '用户号码', `password` varchar(100) DEFAULT NULL COMMENT '密码', `cust_id` bigint(20) DEFAULT NULL COMMENT '客户id 1对1', PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci; 对应的UserMapper.java 1234567891011121314151617package com.yukong.mapper;import com.yukong.entity.User;/** * * @author yukong * @date 2019-04-11 16:50 */public interface UserMapper &#123; int insertSelective(User record); User selectByUsername(String username);&#125; UserMapper.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.yukong.mapper.UserMapper\"&gt; &lt;resultMap id=\"BaseResultMap\" type=\"com.yukong.entity.User\"&gt; &lt;id column=\"id\" jdbcType=\"BIGINT\" property=\"id\" /&gt; &lt;result column=\"username\" jdbcType=\"VARCHAR\" property=\"username\" /&gt; &lt;result column=\"svc_num\" jdbcType=\"VARCHAR\" property=\"svcNum\" /&gt; &lt;result column=\"password\" jdbcType=\"VARCHAR\" property=\"password\" /&gt; &lt;result column=\"cust_id\" jdbcType=\"BIGINT\" property=\"custId\" /&gt; &lt;/resultMap&gt; &lt;sql id=\"Base_Column_List\"&gt; id, username, svc_num, `password`, cust_id &lt;/sql&gt; &lt;select id=\"selectByUsername\" parameterType=\"java.lang.String\" resultMap=\"BaseResultMap\"&gt; select &lt;include refid=\"Base_Column_List\" /&gt; from user where username = #&#123;username,jdbcType=VARCHAR&#125; &lt;/select&gt; &lt;insert id=\"insertSelective\" keyColumn=\"id\" keyProperty=\"id\" parameterType=\"com.yukong.entity.User\" useGeneratedKeys=\"true\"&gt; insert into user &lt;trim prefix=\"(\" suffix=\")\" suffixOverrides=\",\"&gt; &lt;if test=\"username != null\"&gt; username, &lt;/if&gt; &lt;if test=\"svcNum != null\"&gt; svc_num, &lt;/if&gt; &lt;if test=\"password != null\"&gt; `password`, &lt;/if&gt; &lt;if test=\"custId != null\"&gt; cust_id, &lt;/if&gt; &lt;/trim&gt; &lt;trim prefix=\"values (\" suffix=\")\" suffixOverrides=\",\"&gt; &lt;if test=\"username != null\"&gt; #&#123;username,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test=\"svcNum != null\"&gt; #&#123;svcNum,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test=\"password != null\"&gt; #&#123;password,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test=\"custId != null\"&gt; #&#123;custId,jdbcType=BIGINT&#125;, &lt;/if&gt; &lt;/trim&gt; &lt;/insert&gt;&lt;/mapper&gt; 在这里我们定义了两个方法。 国际惯例ctrl+shift+t创建mapper的测试方法，并且插入一条记录 12345678910111213141516171819202122232425262728293031package com.yukong.mapper;import com.yukong.SpringbootSpringsecurityApplicationTests;import com.yukong.entity.User;import org.junit.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.security.crypto.password.PasswordEncoder;import static org.junit.Assert.*;/** * @author yukong * @date 2019-04-11 16:53 */public class UserMapperTest extends SpringbootSpringsecurityApplicationTests &#123; @Autowired private UserMapper userMapper; @Test public void insert() &#123; User user = new User(); user.setUsername(\"yukong\"); user.setPassword(\"abc123\"); userMapper.insertSelective(user); &#125;&#125; 运行测试方法，并且成功插入一条记录。 创建UserController.java 12345678910111213141516171819202122232425package com.yukong.controller;import com.yukong.entity.User;import com.yukong.mapper.UserMapper;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;/** * @author yukong * @date 2019-04-11 15:22 */@RestControllerpublic class UserController &#123; @Autowired private UserMapper userMapper; @RequestMapping(\"/user/&#123;username&#125;\") public User hello(@PathVariable String username) &#123; return userMapper.selectByUsername(username); &#125;&#125; 这个方法就是根据用户名去数据库查找用户详细信息。 启动。因为我们之前插入过一条username=yukong的记录，所以我们查询一下,访问127.0.0.1:8080/user/yukong 我们可以看到 我们被重定向到了一个登录界面，这也是我们之前引入的spring-boot-security-starter起作用了。 大家可能想问了，用户名跟密码是什么，用户名默认是user，密码在启动的时候已经通过日志打印在控制台了。 现在我们输入用户跟密码并且登录。就可以成功访问我们想要访问的接口。 从这里我们可以知道，我只需要引入了Spring-Security的依赖，它就开始生效，并且保护我们的接口了，但是现在有一个问题就是，它的用户名只能是user并且密码是通过日志打印在控制台，但是我们希望它能通过数据来访问我们的用户并且判断登录。 其实想实现这个功能也很简单。这里我们需要了解两个接口。 UserDetails UserDetailsService 所以，我们需要将我们的User.java实现这个接口 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107package com.yukong.entity;import org.springframework.security.core.GrantedAuthority;import org.springframework.security.core.authority.AuthorityUtils;import org.springframework.security.core.userdetails.UserDetails;import java.util.Collection;/** * * @author yukong * @date 2019-04-11 16:50 */public class User implements UserDetails &#123; /** * 主键 */ private Long id; /** * 用户名 */ private String username; /** * 用户号码 */ private String svcNum; /** * 密码 */ private String password; /** * 客户id 1对1 */ private Long custId; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125; @Override public String getUsername() &#123; return username; &#125; @Override public boolean isAccountNonExpired() &#123; return false; &#125; @Override public boolean isAccountNonLocked() &#123; return false; &#125; @Override public boolean isCredentialsNonExpired() &#123; return false; &#125; @Override public boolean isEnabled() &#123; return false; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getSvcNum() &#123; return svcNum; &#125; public void setSvcNum(String svcNum) &#123; this.svcNum = svcNum; &#125; @Override public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123; // 这里我们没有用到权限，所以返回一个默认的admin权限 return AuthorityUtils.commaSeparatedStringToAuthorityList(\"admin\"); &#125; @Override public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public Long getCustId() &#123; return custId; &#125; public void setCustId(Long custId) &#123; this.custId = custId; &#125;&#125; 接下来我们再看看UserDetailsService 它只有一个方法的声明，就是通过用户名去查找用户信息，从这里我们应该知道了，SpringSecurity回调UserDetails#loadUserByUsername去获取用户，但是它不知道用户信息存在哪里，所以定义成接口，让使用者去实现。在我们这个项目用 我们的用户是存在了数据库中，所以我们需要调用UserMapper的方法去访问数据库查询用户信息。这里我们新建一个类叫MyUserDetailsServiceImpl 123456789101112131415161718192021222324package com.yukong.config;import com.yukong.mapper.UserMapper;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.security.core.userdetails.UserDetails;import org.springframework.security.core.userdetails.UserDetailsService;import org.springframework.security.core.userdetails.UsernameNotFoundException;import org.springframework.stereotype.Service;/** * @author yukong * @date 2019-04-11 17:35 */@Servicepublic class MyUserDetailServiceImpl implements UserDetailsService &#123; @Autowired private UserMapper userMapper; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; return userMapper.selectByUsername(username); &#125;&#125; 然后新建一个类去把我们的UserDetailsService配置进去 这里我们新建一个SecurityConfig 1234567891011121314151617181920212223242526272829303132333435package com.yukong.config;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;import org.springframework.security.core.userdetails.UserDetailsService;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;import org.springframework.security.crypto.password.PasswordEncoder;/** * @author yukong * @date 2019-04-11 15:08 */@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Autowired private UserDetailsService userDetailsService; @Bean public PasswordEncoder passwordEncoder()&#123; return new BCryptPasswordEncoder(); &#125; @Autowired public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception &#123; // 配置UserDetailsService 跟 PasswordEncoder 加密器 auth.userDetailsService(userDetailsService).passwordEncoder(passwordEncoder()); auth.eraseCredentials(false); &#125;&#125; 在这里我们还配置了一个PasswordEncoder加密我们的密码，大家都知道密码明文存数据库是很不安全的。 接下里我们插入一条记录，需要注意的是 密码需要加密。 123456789101112131415161718192021222324252627282930313233package com.yukong.mapper;import com.yukong.SpringbootSpringsecurityApplicationTests;import com.yukong.entity.User;import org.junit.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.security.crypto.password.PasswordEncoder;import static org.junit.Assert.*;/** * @author yukong * @date 2019-04-11 16:53 */public class UserMapperTest extends SpringbootSpringsecurityApplicationTests &#123; @Autowired private PasswordEncoder passwordEncoder; @Autowired private UserMapper userMapper; @Test public void insert() &#123; User user = new User(); user.setUsername(\"yukong\"); user.setPassword(passwordEncoder.encode(\"abc123\")); userMapper.insertSelective(user); &#125;&#125; 接下来启动程序，并且登录，这次只需要输入插入到数据中的那条记录的用户名跟密码即可。 在这里一节中，我们了解到如何使用springsecurity 完成一个登录功能，接下我们将通过分析源码来了解为什么需要这个配置，以及SpringSecurity的工作原理是什么。","categories":[{"name":"SpringSecurity","slug":"SpringSecurity","permalink":"http://www.yukonga.cn/categories/SpringSecurity/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://www.yukonga.cn/tags/SpringBoot/"},{"name":"SpringSecurity","slug":"SpringSecurity","permalink":"http://www.yukonga.cn/tags/SpringSecurity/"}]},{"title":"56. 合并区间(Merge Intervals)","slug":"56-合并区间-Merge-Intervals","date":"2019-01-18T08:37:47.000Z","updated":"2019-01-18T08:41:21.097Z","comments":true,"path":"2019/01/18/56-合并区间-Merge-Intervals/","link":"","permalink":"http://www.yukonga.cn/2019/01/18/56-合并区间-Merge-Intervals/","excerpt":"给出一个区间的集合，请合并所有重叠的区间。 示例 1: 123输入: [[1,3],[2,6],[8,10],[15,18]]输出: [[1,6],[8,10],[15,18]]解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]. 示例 2: 123输入: [[1,4],[4,5]]输出: [[1,5]]解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。","text":"给出一个区间的集合，请合并所有重叠的区间。 示例 1: 123输入: [[1,3],[2,6],[8,10],[15,18]]输出: [[1,6],[8,10],[15,18]]解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]. 示例 2: 123输入: [[1,4],[4,5]]输出: [[1,5]]解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。 12345解题思路：* 根据对象的start 升序排序* 遍历对象列表* 如果当前结果列表最后一个元素end比下一个元素的start小 则把下一个加入到结果列表* 否则 将当前结果列表中最后一个元素的end赋值 = max(res.get(last()).end, current.end) java 12345678910111213141516171819202122232425262728293031323334353637public class Solution &#123; public class Interval &#123; int start; int end; Interval() &#123; start = 0; end = 0; &#125; Interval(int s, int e) &#123; start = s; end = e; &#125; &#125; /** * Definition for an interval. * public class Interval &#123; * int start; * int end; * Interval() &#123; start = 0; end = 0; &#125; * Interval(int s, int e) &#123; start = s; end = e; &#125; * &#125; */ public List&lt;Interval&gt; merge(List&lt;Interval&gt; intervals) &#123; // 根据start排序 Collections.sort(intervals, (x,y) -&gt; (x.start - y.start)); LinkedList&lt;Interval&gt; res = new LinkedList&lt;&gt;(); for (Interval inerval: intervals ) &#123; if (res.isEmpty() || res.peekLast().end &lt; inerval.start) &#123; res.addLast(inerval); &#125; else &#123; res.peekLast().end = Math.max(inerval.end, res.peekLast().end ); &#125; &#125; return res; &#125;&#125; python 123456789101112131415161718192021# Definition for an interval.class Interval: def __init__(self, s=0, e=0): self.start = s self.end = eclass Solution: def merge(self, intervals): \"\"\" :type intervals: List[Interval] :rtype: List[Interval] \"\"\" intervals.sort(key=lambda x : x.start) res = [] for interval in intervals: if len(res) &lt;= 0 or res[len(res)-1].end &lt; interval.start: res.append(interval) else: res[len(res)-1].end = max(res[len(res)-1].end, interval.end) return res","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.yukonga.cn/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.yukonga.cn/tags/leetcode/"},{"name":"算法","slug":"算法","permalink":"http://www.yukonga.cn/tags/算法/"},{"name":"java","slug":"java","permalink":"http://www.yukonga.cn/tags/java/"}]},{"title":" 780. 到达终点 (Reaching Points)","slug":"780-到达终点-Reaching-Points","date":"2019-01-17T09:10:17.000Z","updated":"2019-01-18T08:38:55.566Z","comments":true,"path":"2019/01/17/780-到达终点-Reaching-Points/","link":"","permalink":"http://www.yukonga.cn/2019/01/17/780-到达终点-Reaching-Points/","excerpt":"从点 (x, y) 可以转换到 (x, x+y) 或者 (x+y, y)。 给定一个起点 (sx, sy) 和一个终点 (tx, ty)，如果通过一系列的转换可以从起点到达终点，则返回 True，否则返回 False。","text":"从点 (x, y) 可以转换到 (x, x+y) 或者 (x+y, y)。 给定一个起点 (sx, sy) 和一个终点 (tx, ty)，如果通过一系列的转换可以从起点到达终点，则返回 True，否则返回 False。 1234567891011121314示例:输入: sx = 1, sy = 1, tx = 3, ty = 5输出: True解释:可以通过以下一系列转换从起点转换到终点：(1, 1) -&gt; (1, 2)(1, 2) -&gt; (3, 2)(3, 2) -&gt; (3, 5)输入: sx = 1, sy = 1, tx = 2, ty = 2输出: False输入: sx = 1, sy = 1, tx = 1, ty = 1输出: True 注意: sx, sy, tx, ty 是范围在 [1, 10^9] 的整数。 由于本题按照题目给的思路正向一步一步走下去会存在多种情况，我们可以逆向推导。反推起点，因为这样只存在两种种情况。 if : tx &gt; ty then : tx = tx % ty if : ty &gt; tx then : ty = ty % tx java代码 12345678910111213141516171819class Solution &#123; public boolean reachingPoints(int sx, int sy, int tx, int ty) &#123; while(tx &gt; sx &amp;&amp; ty &gt; sy) &#123; if (tx &gt; ty) &#123; tx = tx % ty; &#125; else &#123; ty = ty % tx; &#125; &#125; if (tx == sx) &#123; return (ty - sy) % tx == 0; &#125; else if(ty == sy) &#123; return (tx - sx) % ty == 0; &#125; else &#123; return false; &#125; &#125;&#125; python代码 1234567891011121314151617181920class Solution: def reachingPoints(self, sx, sy, tx, ty): \"\"\" :type sx: int :type sy: int :type tx: int :type ty: int :rtype: bool \"\"\" while tx &gt; sx and ty &gt; sy: if tx &gt; ty: tx = tx % ty else: ty = ty % tx if tx == sx: return (ty - sy) % sx == 0 if ty == sy: return (tx - sx) % sy == 0 return False","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.yukonga.cn/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.yukonga.cn/tags/leetcode/"},{"name":"算法","slug":"算法","permalink":"http://www.yukonga.cn/tags/算法/"},{"name":"java","slug":"java","permalink":"http://www.yukonga.cn/tags/java/"}]},{"title":"基于SpringCloud Finchley.SR1 、SpringBoot 2.x、 vue、element-ui 微服务基础脚手架","slug":"基于SpringCloud-Finchley-SR1-、SpringBoot-2-x、-vue、element-ui-微服务基础脚手架","date":"2018-11-29T07:48:17.000Z","updated":"2019-05-07T06:29:20.276Z","comments":true,"path":"2018/11/29/基于SpringCloud-Finchley-SR1-、SpringBoot-2-x、-vue、element-ui-微服务基础脚手架/","link":"","permalink":"http://www.yukonga.cn/2018/11/29/基于SpringCloud-Finchley-SR1-、SpringBoot-2-x、-vue、element-ui-微服务基础脚手架/","excerpt":"panda是基于SpringCloud Finchley.SR1 、SpringBoot 2.x、 vue、element-ui 微服务基础脚手架 对于日常开发而言提供基础权限控制，动态菜单，才用前后端分离架构，前台采用vue 后台使用springcloud提供rest接口。对于以后开发，只需要在1panda-service` 添加业务模块即可，大大减少工作量。","text":"panda是基于SpringCloud Finchley.SR1 、SpringBoot 2.x、 vue、element-ui 微服务基础脚手架 对于日常开发而言提供基础权限控制，动态菜单，才用前后端分离架构，前台采用vue 后台使用springcloud提供rest接口。对于以后开发，只需要在1panda-service` 添加业务模块即可，大大减少工作量。 介绍 github 地址 跪求大家star panda微服务工程地址 panda-admin前台工程地址 panda是基于SpringCloud Finchley.SR1 、SpringBoot 2.x、 vue、element-ui 微服务基础脚手架 对于日常开发而言提供基础权限控制，动态菜单，才用前后端分离架构，前台采用vue 后台使用springcloud提供rest接口。对于以后开发，只需要在1panda-service` 添加业务模块即可，大大减少工作量。 panda-server 服务注册中心 panda-auth oauth2 认证服务器 提供token panda-common 公共模块集合 panda-config-server 配置中心服务器 panda-gateway 统一网关，提供动态路由 同时也是oauth2的资源服务器 panda-service 业务模块集合 panda-user-service 统一用户管理模块 panda-gen-service 代码生成器模块 后续会陆续支持 zipkin服务链路监控 springboot-admin 服务健康监控等 技术选型&amp;文档 Spring Boot（查看Spring Boot学习&amp;使用指南） Spring Cloud（查看官方中文文档） Spring Security Oauth2（查看官方中文文档） MyBatis（查看官方中文文档） MyBatis plus（查看官方中文文档） Vue.js（查看官方中文文档） ElementUI（查看官方中文文档） Redis RabbitMq OSS 进度 [x] 登录管理 [x] 登录 [x] 登出 [x] 系统管理 [x] 资源管理 [x] 查看资源 [x] 添加资源 [x] 修改资源 [x] 删除资源 [x] 角色管理 [x] 查看角色 [x] 添加角色 [x] 修改角色 [x] 分配资源 [x] 用户管理 [x] 查看用户 [x] 添加用户 [x] 修改用户 [x] 分配角色 [ ] 字典管理 [ ] 终端管理 [ ] 令牌管理 [x] 日志管理 [x] 登录日志 [x] 查询日志 [x] 操作日志 [x] 查询日志 [x] 异常日志 [x] 查询日志 [x] 研发管理 [x] 代码生成 [x] 查询表格 [x] 生成代码 [x] 接口文档 [ ] 个人中心 [ ] 查看资料 [ ] 修改资料 启动教程 根据init.sql 创建数据库 首先启动 panda-server 注册中心 然后启动panda-config-server配置注册中心 启动统一用户服务panda-user-service 启动认证服务panda-auth 以为认证服务依赖于统一用户服务，所以 统一用户服务器启动在前 最后启动panda-gateway 网关 然后启动前台工程 npm run dev / yarn run dev就可以 目前完成 基础权限模块，接下来会完善动态路由界面可视化配置，与个人中心模块。 github 地址 跪求大家star panda微服务工程地址 panda-admin前台工程地址 希望大家有兴趣一起完善的可以联系我 最后大家关注一下我的个人公众号把。关注我公众号即可获取源码","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://www.yukonga.cn/categories/SpringCloud/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://www.yukonga.cn/tags/SpringBoot/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://www.yukonga.cn/tags/SpringCloud/"},{"name":"Vue","slug":"Vue","permalink":"http://www.yukonga.cn/tags/Vue/"},{"name":"ElementUI","slug":"ElementUI","permalink":"http://www.yukonga.cn/tags/ElementUI/"}]},{"title":"【java并发编程实战6】AQS之独占锁ReentrantLock实现","slug":"【java并发编程实战6】AQS之独占锁ReentrantLock实现","date":"2018-09-10T10:11:08.000Z","updated":"2019-05-07T05:59:11.868Z","comments":true,"path":"2018/09/10/【java并发编程实战6】AQS之独占锁ReentrantLock实现/","link":"","permalink":"http://www.yukonga.cn/2018/09/10/【java并发编程实战6】AQS之独占锁ReentrantLock实现/","excerpt":"前言 自从JDK1.5后，jdk新增一个并发工具包java.util.concurrent，提供了一系列的并发工具类。而今天我们需要学习的是java.util.concurrent.lock也就是它下面的lock包，其中有一个最为常见类ReentrantLock， 我们知道ReentrantLock的功能是实现代码段的并发访问控制，也就是通常意义上所说的锁。之前我们也学习过一种锁的实现，也就是synchronized关键词，synchronized是在字节码层面，通过对象的监视器锁实现的。那么ReentrantLock又是怎么实现的呢？","text":"前言 自从JDK1.5后，jdk新增一个并发工具包java.util.concurrent，提供了一系列的并发工具类。而今天我们需要学习的是java.util.concurrent.lock也就是它下面的lock包，其中有一个最为常见类ReentrantLock， 我们知道ReentrantLock的功能是实现代码段的并发访问控制，也就是通常意义上所说的锁。之前我们也学习过一种锁的实现，也就是synchronized关键词，synchronized是在字节码层面，通过对象的监视器锁实现的。那么ReentrantLock又是怎么实现的呢？ 如果不看源码，可能会以为它的实现是通过类似于synchronized，通过对象的监视器锁实现的。但事实上它仅仅是一个工具类！没有使用更“高级”的机器指令，不是关键字，也不依靠JDK编译时的特殊处理，仅仅作为一个普普通通的类就完成了代码块的并发访问控制，这就更让人疑问它怎么实现的代码块的并发访问控制的了。 我们查看源码发现，它是通过继承抽象类实现的AbstractQueuedSynchronizer，为了方便描述，接下来我将用AQS代替AbstractQueuedSynchronizer。 关于AQS AQS，它是用来构建锁或者其他同步组建的基础框架，我们见过许多同步工具类都是基于它构建的。包括ReentrantLock、CountDownLatch等。在深入了解AQS了解之前，我们需要知道锁跟AQS的区别。锁，它是面向使用者的，它定义了使用者与锁交互的接口，隐藏了实现的细节；而AQS面像的是锁的实现者，它简化了锁的实现。锁与AQS很好的隔离使用者与实现者所需要关注的领域。那么我们今天就作为一个锁的实现者，一步一步分析锁的实现。 AQS又称同步器，它的内部有一个int成员变量state表示同步状态，还有一个内置的FIFO队列来实现资源获取线程的排队工作。通过它们我们就能实现锁。 在实现锁之前，我们需要考虑做为锁的使用者，锁会有哪几种？ 通常来说，锁分为两种，一种是独占锁(排它锁,互斥锁),另一种就是共享锁了。根据这两类，其实AQS也给我们提供了两套API。而我们作为锁的实现者，通常都是要么全部实现它的独占api，要么实现它的共享api，而不会出现一起实现的。即使juc内置的ReentrantReadWriteLock也是通过两个子类分别来实现的。 锁的实现 独占锁 独占锁又名互斥锁，同一时间，只有一个线程能获取到锁，其余的线程都会被阻塞等待。其中我们常用的ReentrantLock就是一种独占锁，我们一起来分ReentrantLock 析分析ReentrantLock的同时看一看AQS的实现，再推理出AQS独特的设计思路和实现方式。最后，再看其共享控制功能的实现。 首先我们来看看获取锁的过程 加锁 我们查看ReentrantLock的源码。来分析它的lock方法 123public void lock() &#123; sync.lock(); &#125; 与我们之前分析的一样，锁的具体实现由内部的代理类完成，lock只是暴露给锁的使用者的一套api。使用过ReentrantLock的同学应该知道，ReentrantLock又分为公平锁和非公平锁，所以，ReentrantLock内部只有两个sync的实现。 12345678 /** * Sync object for non-fair locks */ static final class NonfairSync extends Sync&#123;..&#125;/** * Sync object for fair locks */ static final class FairSync extends Sync&#123;..&#125; 公平锁 ：每个线程获取锁的顺序是按照调用lock方法的先后顺序来的。 非公平锁：每个线程获取锁的顺序是不会按照调用lock方法的先后顺序来的。完全看运气。 所以我们完全可以猜测到，这个公平与不公平的区别就体现在锁的获取过程。我们以公平锁为例，来分析获取锁过程，最后对比非公平锁的过程，寻找差异。 lock 查看FairSync的lock方法 123final void lock() &#123; acquire(1); &#125; 这里它调用到了父类AQS的acquire方法，所以我们继续查看acquire方法的代码 acquire 12345678910111213141516/** * Acquires in exclusive mode, ignoring interrupts. Implemented * by invoking at least once &#123;@link #tryAcquire&#125;, * returning on success. Otherwise the thread is queued, possibly * repeatedly blocking and unblocking, invoking &#123;@link * #tryAcquire&#125; until success. This method can be used * to implement method &#123;@link Lock#lock&#125;. * * @param arg the acquire argument. This value is conveyed to * &#123;@link #tryAcquire&#125; but is otherwise uninterpreted and * can represent anything you like. */ public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); &#125; 查看方法方法的注释我们可以知道这个方法的作用，这里我简单的翻译一下. Acquires方法是一个独占锁模式的方法，它是不会响应中断的。它至少执行一次tryAcquire去获取锁，如果返回true，则代表获取锁成功，否则它将会被加入等待队列阻塞，直到重新尝试获取锁成功。所以我们需要看看尝试获取锁的方法tryAcquire的实现 tryAcruire 123protected boolean tryAcquire(int arg) &#123; throw new UnsupportedOperationException(); &#125; 抛出一个异常，没有实现。所以我们需要查看它的子类，在我们这里就是FairSync的实现。 这里也会大家会有疑惑，没有实现为什么不写成抽象方法呢，前面我们提到过，我们不会同时在一个类中实现独占锁跟共享锁的api，那么tryAcruire是属于独占锁，那么如果我想一个共享锁也要重新独占锁的方法吗？所以大师的设计是绝对没有问题的。 12 目前为止，如果获取锁成功，则返回true，获取锁的过程结束，如果获取失败，则返回false 按照之前的逻辑，如果线程获取锁失败，则会被放入到队列中，但是在放入之前，需要给线程包装一下。 那么这个addWaiter就是包装线程并且放入到队列的过程实现的方法。 addWaiter 1234567891011121314151617181920/** * Creates and enqueues node for current thread and given mode. * * @param mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared * @return the new node */ private Node addWaiter(Node mode) &#123; Node node = new Node(Thread.currentThread(), mode); // Try the fast path of enq; backup to full enq on failure Node pred = tail; if (pred != null) &#123; node.prev = pred; if (compareAndSetTail(pred, node)) &#123; pred.next = node; return node; &#125; &#125; enq(node); return node; &#125; 注释: 把当前线程作为一个节点添加到队列中，并且为这个节点设置模式 模式： 也就是独占模式/共享模式,在这里模式是形参，所以我们看看起调方 acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) Node.EXCLUSIVE 就代表这是独占锁模式。 创建好节点后，将节点加入到队列尾部，此处，在队列不为空的时候，先尝试通过cas方式修改尾节点为最新的节点，如果修改失败，意味着有并发，这个时候才会进入enq中死循环，“自旋”方式修改。 将线程的节点接入到队里中后，当然还需要做一件事:将当前线程挂起！这个事，由acquireQueued来做。 在解释acquireQueued之前，我们需要先看下AQS中队列的内存结构，我们知道，队列由Node类型的节点组成，其中至少有两个变量，一个封装线程，一个封装节点类型。 而实际上，它的内存结构是这样的（第一次节点插入时，第一个节点是一个空节点，代表有一个线程已经获取锁，事实上，队列的第一个节点就是代表持有锁的节点）： 黄色节点为队列默认的头节点，每次有线程竞争失败，进入队列后其实都是插入到队列的尾节点（tail后面）后面。这个从enq方法可以看出来，上文中有提到enq方法为将节点插入队列的方法: enq 12345678910111213141516private Node enq(final Node node) &#123; for (;;) &#123; Node t = tail; if (t == null) &#123; // Must initialize // 一个空的节点，通常代表获取锁的线程 if (compareAndSetHead(new Node())) tail = head; &#125; else &#123; node.prev = t; if (compareAndSetTail(t, node)) &#123; t.next = node; return t; &#125; &#125; &#125; &#125; acquireQueued 接着我们来看看当节点被放入到队列中，如何将线程挂起，也就是看看acquireQueued方法的实现。 1234567891011121314151617181920212223242526272829final boolean acquireQueued(final Node node, int arg) &#123; boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; // 获取当前节点前驱结点 final Node p = node.predecessor(); // 如果前驱节点是head，那么它就是等待队列中的第一个线程 // 因为我们知道head就是获取线程的节点，那么它就有机会再次获取锁 if (p == head &amp;&amp; tryAcquire(arg)) &#123; //成功后，将上图中的黄色节点移除，Node1变成头节点。 也证实了head就是获取锁的线程的节点。 setHead(node); p.next = null; // help GC failed = false; return interrupted; &#125; // 1、检查前一个节点的状态，判断是否要挂起 // 2、如果需要挂起，则通过JUC下的LockSopport类的静态方法park挂起当前线程，直到被唤醒。 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; // 如果发生异常 if (failed) // 取消请求，也就是将当前节点重队列中移除。 cancelAcquire(node); &#125; &#125; 这里我还需要解释的是： 1、Node节点除了存储当前线程之外，节点类型，前驱后驱指针之后，还存储一个叫waitStatus的变量，该变量用于描述节点的状态。共有四种状态。 1234567891011/** waitStatus value to indicate thread has cancelled */ static final int CANCELLED = 1; /** waitStatus value to indicate successor's thread needs unparking */ static final int SIGNAL = -1; /** waitStatus value to indicate thread is waiting on condition */ static final int CONDITION = -2; /** * waitStatus value to indicate the next acquireShared should * unconditionally propagate */ static final int PROPAGATE = -3; 分别表示： 1 = 取消状态，该节点将会被队列移除。 -1 = 等待状态，后驱节点处于等待状态。 -2 = 等待被通知，该节点将会阻塞至被该锁的condition的await方法唤醒。 -3 = 共享传播状态，代表该节点的状态会向后传播。 到此为止，一个线程对于锁的一次竞争才告于段落，结果有两种，要么成功获取到锁（不用进入到AQS队列中），要么，获取失败，被挂起，等待下次唤醒后继续循环尝试获取锁，值得注意的是，AQS的队列为FIFO队列，所以，每次被CPU假唤醒，且当前线程不是出在头节点的位置，也是会被挂起的。AQS通过这样的方式，实现了竞争的排队策略。 释放锁 看完了加锁，再看释放锁。我们先不看代码也可以猜测到释放锁需要的步骤。 队列的头节点是当前获取锁的线程，所以我们需要移除头节点 释放锁，唤醒头节点后驱节点来竞争锁 接下来我们查看源码来验证我们的猜想是否在正确。 unlock 123public void unlock() &#123; sync.release(1);&#125; unlock方法调用AQS的release方法，因为我们的acquire的时候传入的是1，也就是同步状态量+1，那么对应的解锁就要-1。 release 123456789101112public final boolean release(int arg) &#123; // 尝试释放锁 if (tryRelease(arg)) &#123; // 释放锁成功，获取当前队列的头节点 Node h = head; if (h != null &amp;&amp; h.waitStatus != 0) // 唤醒当前节点的下一个节点 unparkSuccessor(h); return true; &#125; return false; &#125; tryRelease 同样的它是交给子类实现的 123456789101112131415protected final boolean tryRelease(int releases) &#123; int c = getState() - releases; // 当前线程不是获取锁的线程 抛出异常 if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; // 因为是重入的关系，不是每次释放锁c都等于0，直到最后一次释放锁时，才通知AQS不需要再记录哪个线程正在获取锁。 if (c == 0) &#123; free = true; setExclusiveOwnerThread(null); &#125; setState(c); return free; &#125; unparkSuccessor 释放锁成功之后，就唤醒头节点后驱节点来竞争锁 1234567891011121314private void unparkSuccessor(Node node) &#123; int ws = node.waitStatus; if (ws &lt; 0) compareAndSetWaitStatus(node, ws, 0); Node s = node.next; if (s == null || s.waitStatus &gt; 0) &#123; s = null; for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) if (t.waitStatus &lt;= 0) s = t; &#125; if (s != null) LockSupport.unpark(s.thread); &#125; 值得注意的是，寻找的顺序是从队列尾部开始往前去找的最前面的一个waitStatus小于0的节点。因为大于0 就是1状态的节点是取消状态。 公平锁与非公平锁 到此我们锁获取跟锁的释放已经分析的差不多。那么公平锁跟非公平锁的区别在于加锁的过程。对比代码 1234567static final class FairSync extends Sync &#123; private static final long serialVersionUID = -3000897897090466540L; final void lock() &#123; acquire(1); &#125;&#125; 1234567891011121314static final class NonfairSync extends Sync &#123; private static final long serialVersionUID = 7316153563782823691L; /** * Performs lock. Try immediate barge, backing up to normal * acquire on failure. */ final void lock() &#123; if (compareAndSetState(0, 1)) setExclusiveOwnerThread(Thread.currentThread()); else acquire(1); &#125;&#125; 从代码中也可以看出来，非公平在公平锁的加锁的逻辑之前先直接cas修改一次state变量（尝试获取锁），成功就返回，不成功再排队，从而达到不排队直接抢占的目的。 欢迎大家关注一下我的个人公众号。一起交流一起学习，有问必答。","categories":[{"name":"java并发编程实战","slug":"java并发编程实战","permalink":"http://www.yukonga.cn/categories/java并发编程实战/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.yukonga.cn/tags/java/"},{"name":"多线程","slug":"多线程","permalink":"http://www.yukonga.cn/tags/多线程/"},{"name":"独占锁","slug":"独占锁","permalink":"http://www.yukonga.cn/tags/独占锁/"},{"name":"AQS","slug":"AQS","permalink":"http://www.yukonga.cn/tags/AQS/"}]},{"title":"【java并发编程实战5】线程与线程通信","slug":"【java并发编程实战5】线程与线程通信","date":"2018-09-07T09:36:13.000Z","updated":"2019-05-07T05:59:08.364Z","comments":true,"path":"2018/09/07/【java并发编程实战5】线程与线程通信/","link":"","permalink":"http://www.yukonga.cn/2018/09/07/【java并发编程实战5】线程与线程通信/","excerpt":"现代操作系统在运行一个程序，会为其创建一个进程。然后它调度的最小单元是线程，线程也叫轻量级进程(Light Weight Process)，在一个进程中可以创建多个线程，这些线程都有各自的计算器，堆，栈和局部变量","text":"现代操作系统在运行一个程序，会为其创建一个进程。然后它调度的最小单元是线程，线程也叫轻量级进程(Light Weight Process)，在一个进程中可以创建多个线程，这些线程都有各自的计算器，堆，栈和局部变量 线程介绍 线程定义 现代操作系统在运行一个程序，会为其创建一个进程。然后它调度的最小单元是线程，线程也叫轻量级进程(Light Weight Process)，在一个进程中可以创建多个线程，这些线程都有各自的计算器，堆，栈和局部变量，并且都能访问共享的内存变量。处理器在这些线程上高速切换，让用户感觉这些线程在同时在执行。 线程优先级 在计算机操作系统，操作系统采用的是时间片轮转法来调度线程的。操作系统会为每个线程分配时间片，当线程的时间片用了，就会发生线程调度，并且等待下次分配，线程分配到的时间片的多与少就决定线程能占用cpu的时间。 线程优先级就是决定线程能分配的时间片的多与少。在java线程中，可以通过priority来控制线程优先级，线程优先级的范围从1~10。默认值是5，优先级大的分配的时间片会大于优先级低，所以频繁阻塞线程可以设置高优先级，而占用cpu比较长的线程（计算线程）可以设置较低的优先级。但是在有的操作系统会无视对线程有限制。 线程的状态 状态名称 解释 NEW 初始状态，线程被构建，但是还没执行start()方法 RUNNABLE 运行状态，Java中将就绪与运行统称为 ”运行中“ BLOCKED 阻塞状态，表示线程阻塞与获取锁的过程 WAITING 等待状态，表示线程进入等待状态，进入该状态需要等待其他线程做出一些特定的动作（通知或者中断） TIME_WAITING 超时等待状态，该状态不同于WAITING，它是可以在指定时间能自行返回的 TERMINATED 终止状态，表示当前下才能已经执行完成 下面就用代码演示各种方法时线程的状态。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class ThreadState &#123; public static void main(String[] args) &#123; new Thread(new TimeWaiting(), \"TimeWaitingThread\").start(); new Thread(new Waiting(), \"WaitingThread\").start(); new Thread(new Blocked(), \"BlockedThread - 1\").start(); new Thread(new Blocked(), \"BlockedThread - 2\").start(); &#125; static class TimeWaitnging implements Runnable &#123; @override public void run() &#123; while(true) &#123; try &#123; TimeUnit.SECONDS.sleep(1000L); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; static class Waitnging implements Runnable &#123; @override public void run() &#123; while(true) &#123; synchronized(Waiting.class) &#123; try &#123; Waiting.class.wait() &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; static class Blocked implements Runnable &#123; @override public void run() &#123; synchronized(Blocked.class) &#123; while(true) &#123; try &#123; TimeUnit.SECONDS.sleep(1000L); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125;&#125; java中线程状态的变迁如下图 线程通信 通知等待机制 首先我们需要了解一下wait()与notify方法 wait() 调用该方法的线程会进入WAITING状态，只有等待另外线程通知或者被中断才能返回，wait方法会释放对象锁 wait(long) 调用该方法的线程会进入TIME_WAITING状态， 超过等待一段时间，参数单位是毫秒，意味着等待n毫秒后，如果没有通知就返回 wait(long, int) 控制跟粒度更细，到纳秒 notify) 通知一个在此对象上等待的线程，从其从wait()方法返回，返回的前提是该线程获取到了对象的线程锁。 notifyAll() 通知在此对象上等待的所有线程。 现在我们可以通过 synchronized+wait+notify来实现一个简单的通知\\等待模型 等待方（消费者） 1）获取对象锁 2）如果条件不满足，那么调用对象的wait()方法，被通知依旧要检查条件。 3）条件满足则执行对应的逻辑 伪代码： 123456synchronized(对象) &#123; while (条件不满足) &#123; 对象.wait(); &#125; 处理对应逻辑&#125; 通知方法 (生产者) 1）获取对象锁 2）改变条件 3）通知所有等在在此对象上的线程 对应伪代码 1234synchronized(对象) &#123; 改变条件 对象.notifyAll();&#125; 根据上面的通知等待机制，我们可以实现一个简单的线程池。 首先我们先定义一下线程池的接口。 123456789101112131415161718192021222324252627282930313233343536/** * @author yukong * @date 2018/9/5 * @description 线程池接口，抽象出来，定义规范 */public interface ThreadPool&lt;Job extends Runnable&gt; &#123; /** * 执行任务，这个任务需要继承Runnable接口 * @param job 任务 */ void execute(Job job); /** * 关闭线程池 */ void shutdown(); /** * 添加工作者数目 * @param num 要添加的数量 */ void addWorkers(int num); /** * 减少工作者数目 * @param num 要减少的数量 */ void removeWorks(int num); /** * 获取正在等待执行的任务数量 * @return */ int getJobCount();&#125; 然后编写一个实现类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141/** * @author yukong * @date 2018/9/5 * @description */public class DefaultThreadPool&lt;Job extends Runnable&gt; implements ThreadPool&lt;Job&gt; &#123; /** * 线程池最大数 */ private static final int MAX_WORKER_NUMBERS = 10; /** * 线程池默认数 */ private static final int DEFAULT_WORKER_NUMBERS = 5; /** * 线程池最小数 */ private static final int MIN_WORKER_NUMBERS = 1; /** * 任务队列 */ private final LinkedList&lt;Job&gt; jobs = new LinkedList&lt;&gt;(); /** * 工作者列表 */ private final List&lt;Worker&gt; workers = Collections.synchronizedList(new ArrayList&lt;&gt;()); /** * 工作者线程数量 */ private int workerNum = DEFAULT_WORKER_NUMBERS; /** * 线程编号生成 */ private AtomicInteger threadNum = new AtomicInteger(); public DefaultThreadPool(int workerNum) &#123; this.workerNum = workerNum &gt; MAX_WORKER_NUMBERS ? MAX_WORKER_NUMBERS : workerNum &lt; MIN_WORKER_NUMBERS ? MIN_WORKER_NUMBERS : workerNum; initializeWorkers(this.workerNum); &#125; private void initializeWorkers(int num) &#123; for (int i = 0; i &lt; num; i++) &#123; Worker worker = new Worker(); workers.add(worker); Thread thread = new Thread(worker, \"ThreadPool-Worker-\" + threadNum.incrementAndGet()); thread.start(); &#125; &#125; @Override public void execute(Job job) &#123; if (job != null) &#123; synchronized (jobs) &#123; jobs.addLast(job); jobs.notifyAll(); &#125; &#125; &#125; @Override public void shutdown() &#123; for (Worker worker: workers) &#123; worker.shutdown(); &#125; &#125; @Override public void addWorkers(int num) &#123; synchronized (jobs) &#123; // 限制新增的数目与已有的数目之和超过最大数 if (num + this.workerNum&gt; MAX_WORKER_NUMBERS) &#123; num = MAX_WORKER_NUMBERS - this.workerNum; &#125; initializeWorkers(num); this.workerNum += num; &#125; &#125; @Override public void removeWorks(int num) &#123; synchronized (jobs) &#123; if (num &gt; this.workerNum) &#123; throw new IllegalArgumentException(\"beyond workNum\"); &#125; int count = 0; while (count &lt; num) &#123; Worker worker = workers.get(count); if (workers.remove(worker)) &#123; worker.shutdown(); count++; &#125; &#125; this.workerNum -= num; &#125; &#125; @Override public int getJobCount() &#123; return jobs.size(); &#125; class Worker implements Runnable &#123; private volatile Boolean running = true; @Override public void run() &#123; while (running) &#123; Job job = null; synchronized (jobs) &#123; while (jobs.isEmpty()) &#123; try &#123; jobs.wait(); &#125; catch (InterruptedException e) &#123; // 设置中断标记，让外界感知 Thread.currentThread().interrupt(); return; &#125; &#125; job = jobs.removeFirst(); &#125; if (job != null) &#123; job.run(); &#125; &#125; &#125; public void shutdown() &#123; running = false; &#125; &#125;&#125; 至此我们就实现了一个简单的线程池了。 欢迎大家关注一下我的个人公众号。一起交流一起学习，有问必答。","categories":[{"name":"java并发编程实战","slug":"java并发编程实战","permalink":"http://www.yukonga.cn/categories/java并发编程实战/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.yukonga.cn/tags/java/"},{"name":"多线程","slug":"多线程","permalink":"http://www.yukonga.cn/tags/多线程/"},{"name":"线程通信","slug":"线程通信","permalink":"http://www.yukonga.cn/tags/线程通信/"}]},{"title":"【java并发编程实战4】偏向锁-轻量锁-重量锁的那点秘密synchronize实现原理","slug":"【java并发编程实战4】偏向锁-轻量锁-重量锁的那点秘密synchronize实现原理","date":"2018-09-07T00:26:12.000Z","updated":"2019-05-07T06:24:00.818Z","comments":true,"path":"2018/09/07/【java并发编程实战4】偏向锁-轻量锁-重量锁的那点秘密synchronize实现原理/","link":"","permalink":"http://www.yukonga.cn/2018/09/07/【java并发编程实战4】偏向锁-轻量锁-重量锁的那点秘密synchronize实现原理/","excerpt":"在多线程并发编程中，synchronized一直都是元老级别的角色，人们都通常称呼它为重量锁，但是在jdk1.6版本之后，jdk就对synchronized做了大量的优化，这时候我们就不能称呼它为重量锁了，有的时候它也是很轻的，那么接下来我们就调调，synchronized是怎么被优化的，它跟偏向锁、轻量锁、重量锁又有什么渊源。","text":"在多线程并发编程中，synchronized一直都是元老级别的角色，人们都通常称呼它为重量锁，但是在jdk1.6版本之后，jdk就对synchronized做了大量的优化，这时候我们就不能称呼它为重量锁了，有的时候它也是很轻的，那么接下来我们就调调，synchronized是怎么被优化的，它跟偏向锁、轻量锁、重量锁又有什么渊源。 synchronized 回顾一下synchronized是怎么使用的呢。 1、同步普通方法 123public synchronized void sync1() &#123; // do somethings&#125; 在该方法中，synchronized锁的是当前实例的对象 2、同步静态方法 123public static synchronized void sync2() &#123; // do somethings&#125; 由于该方法是一个静态方法，那么它锁的当前类的class对象。 3、同步方法快 1234567891011public void sync3() &#123; synchronized(this) &#123; // do somethings &#125;&#125;public void sync4() &#123; synchronized(MyTest.css) &#123; // do somethings &#125;&#125; 那么同步方法快是需要根据方法中具体同步的对象来实现的。 在上面代码中其实sync3()跟同步普通方法一样，锁的是当前实例对象；那么sync4方法就与同步静态方法一样，锁的是当前类的class对象。 从上面代码可以看出来的，我们通过使用synchronized关键字可以很简单的解决并发问题，但是其实是jvm底层通过使用一种叫内置锁的手段，简化了开发人员实现并发的复杂度，在jdk1.6以前 synchronized是基于重量锁实现的，即每次遇到同步代码都要获取锁，然后释放锁，在jdk1.6之后对其优化，根据不同场景使用不同的策略，这也就是 偏向锁、轻量锁、重量锁的来由。在介绍他们之前我先介绍一下另一个锁-自旋锁。听到这么多锁，是不是头晕，当初我学习的时候也是这样的。但是当你慢慢学习深入，你就会很容易的理解每个锁的作用。 自旋锁 自旋锁顾名思义，就是自己旋转转圈等待，那么它有什么作用呢？ 当前线程尝试去竞争锁 竞争失败，准备阻塞自己 但是并没有阻塞自己，而是采用自旋锁，进入自旋状态 进入自旋状态，并且重新不断竞争锁 如果在自旋期间成功获取锁，那么结束自旋状态，否则进入阻塞状态 如果在自旋期间成功获取锁，那么就减少一次线程的切换。 根据上面解释我们可以很容易的明白自旋锁的意义，因为cpu从内核态切换至用户态，线程的阻塞与恢复会浪费资源的，但是通过自旋而不是去阻塞当前线程，那么就会节省这个一个cpu状态切换。 所以自旋锁适合在** 持有锁的时间长，且竞争不激烈**的场景下使用。 使用-XX:-UseSpinning参数关闭自旋锁优化；-XX:PreBlockSpin参数修改默认的自旋次数 偏向锁 在实际场景中，如果一个同步方法，没有多线程竞争，并且总是由同一个线程多次获取锁，如果每次还有阻塞线程，唤醒cpu从用户态转核心态，那么对于cpu是一种资源的浪费，为了解决这类问题，旧引入了偏向锁的概念。 “偏向”的意思是，偏向锁假定将来只有第一个申请锁的线程会使用锁（不会有任何线程再来申请锁），因此，只需要在Mark Word中CAS记录owner（本质上也是更新，但初始值为空），如果记录成功，则偏向锁获取成功，记录锁状态为偏向锁，以后当前线程等于owner就可以零成本的直接获得锁；否则，说明有其他线程竞争，膨胀为轻量级锁。 具体的步骤如下 访问同步代码块 检查对象头是否owner是否存储当前现成的id 如果没有，进行CAS尝试替换mark word中的owner 如果有执行同步代码（代表获取锁成功） 修改成功 （代表无竞争）owner修改为当前线程id,执行同步代码 修改失败(代表有竞争) 进入撤销偏向锁，暂停线程并将owner置空，进入轻量锁。 偏向锁无法使用自旋锁优化，因为一旦有其他线程申请锁，就破坏了偏向锁的假定。 如果你确定应用程序中所有的锁通常是在竞争状态，你可以通过JVM参数关闭偏向锁 UseBiasedLocking = false，那么程序会默认进入轻量锁状态。 轻量锁 如果说偏向锁是为了解决同步代码在单线程下访问性能问题，那么轻量锁是为了解决减少无实际竞争情况下，使用重量级锁产生的性能消耗 轻量锁，顾名思义，轻量是相对于重量的问题，使用轻量锁时，不需要申请互斥量(mutex) ,而是将mark word中的信息复制到当前线程的栈中，然后通过cas尝试修改mark word并替换成轻量锁，如果替换成功则执行同步代码。如果此时有线程2来竞争，并且他也尝试cas修改mark word但是失败了，那么线程2会进入自旋状态，如果在自旋状态也没有修改成功，那么轻量锁将膨胀成状态，mark word会被修改成重量锁标记(10) ,线程进入阻塞状态。 当然，由于轻量级锁天然瞄准不存在锁竞争的场景，如果存在锁竞争但不激烈，仍然可以用自旋锁优化，自旋失败后再膨胀为重量级锁。 重量锁 在jvm规范中，synchronized是基于监视器锁(monitor)来实现的，它会在同步代码之前添加一个monitorenter指令，获取到该对象的monitor，同时它会在同步代码结束处和异常处添加一个monitorexit指令去释放该对象的monitor,需要注意的是每一个对象都有一个monitor与之配对，当一个monitor被获取之后 也就是被monitorenter，它会处于一个锁定状态，其他尝试获取该对象的monitor的线程会获取失败，只有当获取该对象的monitor的线程执行了monitorexit指令后，其他线程才有可能获取该对象的monitor成功。 所以从上面描述可以得出，监视器锁就是monitor它是互斥的(mutex)。由于它是互斥的，那么它的操作成本就非常的高，包括系统调用引起的内核态与用户态切换、线程阻塞造成的线程切换等。因此，后来称这种锁为“重量级锁”。 小结 偏向锁、轻量级锁、重量级锁适用于不同的并发场景： 偏向锁：无实际竞争，且将来只有第一个申请锁的线程会使用锁。 轻量级锁：无实际竞争，多个线程交替使用锁；允许短时间的锁竞争。 重量级锁：有实际竞争，且锁竞争时间长。 另外，如果锁竞争时间短，可以使用自旋锁进一步优化轻量级锁、重量级锁的性能，减少线程切换。 如果锁竞争程度逐渐提高（缓慢），那么从偏向锁逐步膨胀到重量锁，能够提高系统的整体性能。 同时需要注意锁可以升级，但是不能降级。 另外通过这次学习，大家应该也知道自从jdk1.6以后 synchronized已经被优化了，性能不会比Lock差 所以jdk.16版本及其以后版本的同学可以放心大胆的使用了。 最后附一张从偏向锁膨胀至重量锁的完全的流程图 欢迎大家关注一下我的个人公众号。一起交流一起学习，有问必答。","categories":[{"name":"java并发编程实战","slug":"java并发编程实战","permalink":"http://www.yukonga.cn/categories/java并发编程实战/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.yukonga.cn/tags/java/"},{"name":"多线程","slug":"多线程","permalink":"http://www.yukonga.cn/tags/多线程/"},{"name":"synchronized","slug":"synchronized","permalink":"http://www.yukonga.cn/tags/synchronized/"}]},{"title":"【SpringBoot2.0系列11】SpringBoot之@Elasticsearch完成CURD","slug":"【SpringBoot2-0系列11】SpringBoot之-Elasticsearch完成CURD","date":"2018-09-04T10:37:47.000Z","updated":"2019-05-07T06:07:34.476Z","comments":true,"path":"2018/09/04/【SpringBoot2-0系列11】SpringBoot之-Elasticsearch完成CURD/","link":"","permalink":"http://www.yukonga.cn/2018/09/04/【SpringBoot2-0系列11】SpringBoot之-Elasticsearch完成CURD/","excerpt":"ElasticSearch是一个基于Lucene的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。Elasticsearch是用Java开发的，并作为Apache许可条款下的开放源码发布，是当前流行的企业级搜索引擎。设计用于云计算中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。","text":"ElasticSearch是一个基于Lucene的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。Elasticsearch是用Java开发的，并作为Apache许可条款下的开放源码发布，是当前流行的企业级搜索引擎。设计用于云计算中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。 如果在springboot使用Easticsearch呢。在这里我们使用spring-boot-starter-data-elasticsearch。 它提供一系列简单的api给我们使用，让我们有种操作关系数据库的感觉。 好了话不多说，先说一下环境。 spring boot2.x jdk8 elasticsearch5.x(6.x也可以) 依赖 引入依赖 12345678910111213141516171819202122232425&lt;dependencies&gt; &lt;!-- lombok --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.22&lt;/version&gt; &lt;/dependency&gt; &lt;!-- elasticsearch --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 在这里我们分别引入elasticsearch跟lombok的依赖，关于lombok的介绍大家可以看看这篇文章 讲的很详细。我这简单的介绍一下在项目中使用Lombok可以减少很多重复代码的书写。比如说getter/setter/toString等方法的编写。 配置es地址 在下文中我将用es代替elasticsearch。我们打开application.yml文件 配置如下 1234567spring:data: elasticsearch: # 集群的名字 cluster-name: wali # 节点的ip与端口 注意端口是9300不是9200 cluster-nodes: 127.0.0.1:9300 构建文档对象 假设这是一个商品索引goods，他有一个类型是电脑computer。 分别有四个字段 id 唯一标识 name 商品名称 number 商品数量 desc 商品具体描述 我们根据上面的描述，编写出对应的实体类 1234567891011121314151617181920@Data@ToString@Accessors(chain = true)@Document(indexName = \"goods\", type = \"computer\")public class Good &#123; /** * 主键,注意这个搜索是id类型是string，与我们常用的不同 * Id注解加上后，在Elasticsearch里相应于该列就是主键了，在查询时就可以直接用主键查询 */ @Id private String id; private String name; private String desc; private Integer number;&#125; 其中@Data @ToString @Accessors(chain = true) 是属于lombok注解。 @Data 会自动上传get/set方法 @ToString 会生成tostring方法 @Accessors(chain = true) 会让我们set方法可以链式调用 @Document注解 @Document注解里面的几个属性，类比mysql的话是这样： indexName –&gt; 索引库的名称，建议以项目的名称命名，就相当于数据库DB type –&gt; 类型，建议以实体的名称命名Table ，就相当于数据库中的表table Document –&gt; row 就相当于某一个具体对象 jpa构建文档库 接着，我们可以通过jpa构建文档库，来操作我们的goods对应的文档。 因为我们引入的是spring data的elasticsearch所以它遵循spring data的接口，也就是说操作elasticSearch与操作spring data jpa的方法是完全一样的，我们只将文档库继承ElasticsearchRepository即可。 1234567891011public interface GoodRepository extends ElasticsearchRepository&lt;Good, String&gt; &#123; /** * 根据商品名称查询 分页 * @param name * @param pageable * @return */ Page&lt;Good&gt; findByName(String name, Pageable pageable);&#125; 然后创建对应的测试类。前面说过快捷键ctrl+shift+t 并且编写测试方法，我们分别需要测试添加 删除 修改 查询 分页查询方法。 123456789101112131415161718192021222324@Component@FixMethodOrder(MethodSorters.NAME_ASCENDING)public class GoodRepositoryTest extends Chapter10ApplicationTests &#123; @Autowired private GoodRepository goodRepository; @Test public void save()&#123;&#125; @Test public void update()&#123;&#125; @Test public void select()&#123;&#125; @Test public void delete()&#123;&#125; @Test public void findByName() &#123; &#125;&#125; 上面代码我们是通过基础主测试类然后使用@Component注解就可以，这样就不需要每个测试都要@SpringTest注解与@RunWith注解了 另外@FixMethodOrder(MethodSorters.NAME_ASCENDING)这个注解是表示按照方法名的顺序来排序，不然它不会按照我们方法书写的顺序执行，那么就有可能导致，还没save就select，这样就会失败了。 接下来继续编写方法体。goodRepository跟我们直接data-jpa的respository用法基本一致。都有继承save,delete,find方法的。 1234567891011121314151617181920212223242526272829303132333435@Test public void save()&#123; Good good = new Good(); good.setId(\"100\") .setName(\"联想e541\") .setDesc(\"联想e系列\") .setNumber(10); Good result = goodRepository.save(good); Assert.assertNotNull(result); &#125; @Test public void select()&#123; // 需要注意find方法返回的死Optional对象 需要调用get方法返回具体的实体类对象 Good result = goodRepository.findById(\"100\").get(); Assert.assertNotNull(result); &#125; @Test public void update()&#123; Good result = goodRepository.findById(\"100\").get(); result.setNumber(300); // 更新也是调用save方法 Good good = goodRepository.save(result); Assert.assertNotNull(good); &#125; @Test public void delete()&#123; goodRepository.deleteById(\"100\"); &#125; 我们首先测试增删改查方法。并且通过Assert断言来判断。 测试通过， 接下来我测试一下分页查询方法，首页我们看一下es中、goods索引computer类别下有哪些文档。 1curl -XGET 'http://127.0.0.1:9200/goods/computer/_search?pretty' 结果如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&#123; \"took\" : 21, \"timed_out\" : false, \"_shards\" : &#123; \"total\" : 5, \"successful\" : 5, \"skipped\" : 0, \"failed\" : 0 &#125;, \"hits\" : &#123; \"total\" : 3, \"max_score\" : 1.0, \"hits\" : [ &#123; \"_index\" : \"goods\", \"_type\" : \"computer\", \"_id\" : \"_search\", \"_score\" : 1.0, \"_source\" : &#123; \"id\" : \"_search\", \"name\" : \"macbook\", \"number\" : 20, \"desc\" : \"macbook air\" &#125; &#125;, &#123; \"_index\" : \"goods\", \"_type\" : \"computer\", \"_id\" : \"2\", \"_score\" : 1.0, \"_source\" : &#123; \"id\" : \"2\", \"name\" : \"think pad\", \"number\" : 20, \"desc\" : \"联想旗下thinkpad系列\" &#125; &#125;, &#123; \"_index\" : \"goods\", \"_type\" : \"computer\", \"_id\" : \"1\", \"_score\" : 1.0, \"_source\" : &#123; \"id\" : \"1\", \"name\" : \"macbook\", \"number\" : 20, \"desc\" : \"macbook pro\" &#125; &#125; ] &#125;&#125; 我看到在computer类别中存有三条文档，name分别是 macbook think pad macbook,所以我们查询一下name=macbook的文档，pageSize=1,pageNum=1. 123456789@Test public void findByName() &#123; String name = \"macbook\"; Pageable pageable = new PageRequest(1,1); Page&lt;Good&gt; goods = goodRepository.findByName(name, pageable); System.out.println(goods.getContent()); Assert.assertEquals(1, goods.getSize()); &#125; 我们查询name为macbook的数据，并且限制每页一条，所以我们查询的结果总数应该是一条。结果如下。 在这节，我们了解了springboot与es的curd操作，都是比较简单的，那么下节我们会详细了解springboot对es如何进行复杂查询，与聚合查询。 最后本节的配套代码地址为https://github.com/YuKongEr/SpringBoot-Study/tree/master/chapter10 最后欢迎大家关注一下我的个人公众号。一起交流一起学习，有问必答。","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://www.yukonga.cn/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://www.yukonga.cn/tags/SpringBoot/"},{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"http://www.yukonga.cn/tags/ElasticSearch/"}]},{"title":"【java并发编程实战3】解密volatile","slug":"【java并发编程实战3】解密volatile","date":"2018-09-03T11:19:22.000Z","updated":"2019-05-07T06:24:45.274Z","comments":true,"path":"2018/09/03/【java并发编程实战3】解密volatile/","link":"","permalink":"http://www.yukonga.cn/2018/09/03/【java并发编程实战3】解密volatile/","excerpt":"自从jdk1.5以后，volatile可谓发生了翻天覆地的变化，从一个一直被吐槽的关键词，变成一个轻量级的线程通信代名词。","text":"自从jdk1.5以后，volatile可谓发生了翻天覆地的变化，从一个一直被吐槽的关键词，变成一个轻量级的线程通信代名词。 接下来我们将从以下几个方面来分析以下volatile。 重排序与as if serial的关系 volatile的特点 volatile的内存语义 volatile的使用场景 重排序与as if serial的关系 重排序值得是编译器与处理器为了优化程序的性能，而对指令序列进行重新排序的。 但是并不是什么情况下都可以重排序的， 数据依赖 12a = 1; // 1b = 2; // 2 在这种情况，1、2不存在数据依赖，是可以重排序的。 12a = 1; // 1b = a; // 2 在这种情况，1、2存在数据依赖，是禁止重排序的。 as if serial 简单的理解就是。不管怎么重排序，在单线程情况下程序的执行结果是一致。 根据 as if serial原则，它强调了单线程。那么多线程发生重排序又是怎么样的呢？ 请看下面代码 1234567891011121314151617181920212223242526public class VolatileExample1 &#123; /** * 共享变量 name */ private static String name = \"init\"; /** * 共享变量 flag */ private static boolean flag = false; public static void main(String[] args) throws InterruptedException &#123; Thread threadA = new Thread(() -&gt; &#123; name = \"yukong\"; // 1 flag = true; // 2 &#125;); Thread threadB = new Thread(() -&gt; &#123; if (flag) &#123; // 3 System.out.println(\"flag = \" + flag + \" name = \" +name); // 4 &#125;; &#125;); &#125;&#125; 上面代码中，name输出一定是yukong吗，答案是不一定，根据happen-before原则与as if serial 原则，由于 1、2不存在依赖关系，可以重排序，操作3、操作4也不存在数据依赖，也可以重排序。 那么就有可能发生下面的情况 上图中，操作1与操作2发生了重排序，程序运行的时候，线程A先将flag更改成true，然后线程B读取flag变量并且判断，由于此时flag已经是true，线程B将继续读取name的值，由于此时线程name的值还没有被线程A写入，那么线程此时输出的name就是初始值，因为在多线程的情况下，重排序存在线程安全问题。 volatile的特点 volatile变量具有以下的特点。 可见性。对于一个volatile变量的读，总是能看到任意线程对这个变量的最后的修改。 有序性。对于存在指令重排序的情况，volatile会禁止部分指令重排序。 这里我先介绍一下volatile关键词的特点，接下来我们将会从它的内存语义来解释，为什么它会具有以上的特点，以及它使用的场景。 volatile的内存语义 当写一个volatile变量时，JMM会立即将本地变量中对应的共享变量值刷新到主内存中。 当读一个volatile变量时，JMM会将线程本地变量存储的值，置为无效值，线程接下来将从主内存中读取共享变量。 如果一个场景存在对volatile变量的读写场景，在读线程B读一个volatile变量后，，写线程A在写这个volatile变量前所有的所见的共享变量的值都将会立即变得对读线程B可见。 那么这种内存语义是怎么实现的呢？ 其实编译器生产字节码的时候，会在指令序列中插入内存屏障来禁止指令排序。下面就是JMM内存屏障插入的策略。 在每一个volatile写操作前插入一个StoreStore屏障 在每一个volatile写操作后插入一个StoreLoad屏障 在每一个volatile写操作后插入一个LoadLoad屏障 在每一个volatile读操作后插入一个LoadStore屏障 那么这些策略中，插入这些屏障有什么作用呢？我们逐条逐条分析一下。 在每一个volatile写操作前插入一个StoreStore屏障，这条策略保证了volatile写变量与之前的普通变量写不会重排序，即是只有当volatile变量之前的普通变量写完，volatile变量才会写。 这样就保证volatile变量写不会跟它之前的普通变量写重排序 在每一个volatile写操作后插入一个StoreLoad屏障，这条策略保证了volatile写变量与之后的volatile写/读不会重排序，即是只有当volatile变量写完之后，你后面的volatile读写才能操作。 这样就保证volatile变量写不会跟它之后的普通变量读重排序 在每一个volatile读操作后插入一个LoadLoad屏障，这条策略保证了volatile读变量与之后的普通读不会重排序，即只有当前volatile变量读完，之后的普通读才能读。 这样就保证volatile变量读不会跟它之后的普通变量读重排序 在每一个volatile读操作后插入一个LoadStore屏障，这条策略保证了volatile读变量与之后的普通写不会重排序，即只有当前volatile变量读完，之后的普通写才能写。样就保证volatile变量读不会跟它之后的普通变量写重排序 根据这些策略，volatile变量禁止了部分的重排序，这样也是为什么我们会说volatile具有一定的有序的原因。 根据以上分析的volatile的内存语义，大家也就知道了为什么前面我们提到的happen-before原则会有一条 volatile的写happen-before与volaile的读。 那么根据volatile的内存语义，我们只需要更改之前的部分代码，只能让它正确的执行。 即把flag定义成一个volatile变量即可。 1234567891011121314151617181920212223242526public class VolatileExample1 &#123; /** * 共享变量 name */ private static String name = \"init\"; /** * 共享变量 flag */ private volatile static boolean flag = false; public static void main(String[] args) throws InterruptedException &#123; Thread threadA = new Thread(() -&gt; &#123; name = \"yukong\"; // 1 flag = true; // 2 &#125;); Thread threadB = new Thread(() -&gt; &#123; if (flag) &#123; // 3 System.out.println(\"flag = \" + flag + \" name = \" +name); // 4 &#125;; &#125;); &#125;&#125; 我们来分析一下 由于 flag是volatile变量 那么在volatile写之前插入一个storestore内存屏障，所以1,2不会发生重排序,即1happen before 2 由于 flag是volatile变量 那么在volatile读之后插入一个loadload内存屏障，所以3,4不会发生重排序,即3happen before 4 根据happen-before原则，volatile写happen before volatile读，即是 2happen before 3。 根据happen-before的传递性，所以1 happen before4。 volatile的使用场景 标记变量，也就是上面的flag使用 double check 单例模式中 下面我们看看double check的使用 1234567891011121314151617class Singleton&#123; private volatile static Singleton instance = null; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if(instance==null) &#123; synchronized (Singleton.class) &#123; if(instance==null) instance = new Singleton(); &#125; &#125; return instance; &#125;&#125; 至于为何需要这么写请参考： 《Java 中的双重检查（Double-Check）》http://www.iteye.com/topic/652440 最后大家希望关注一下我的个人公众号。 欢迎大家关注一下我的个人公众号。一起交流一起学习，有问必答。","categories":[{"name":"java并发编程实战","slug":"java并发编程实战","permalink":"http://www.yukonga.cn/categories/java并发编程实战/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.yukonga.cn/tags/java/"},{"name":"多线程","slug":"多线程","permalink":"http://www.yukonga.cn/tags/多线程/"},{"name":"volatile","slug":"volatile","permalink":"http://www.yukonga.cn/tags/volatile/"}]},{"title":"【java并发编程实战2】无锁编程CAS与atomic包","slug":"【java并发编程实战2】无锁编程CAS与atomic包","date":"2018-08-30T06:35:34.000Z","updated":"2019-05-07T06:25:04.030Z","comments":true,"path":"2018/08/30/【java并发编程实战2】无锁编程CAS与atomic包/","link":"","permalink":"http://www.yukonga.cn/2018/08/30/【java并发编程实战2】无锁编程CAS与atomic包/","excerpt":"无锁编程可能大家在面试的时候会被经常问道，那么何为无锁编程CAS，怎么实现无锁编程CAS？","text":"无锁编程可能大家在面试的时候会被经常问道，那么何为无锁编程CAS，怎么实现无锁编程CAS？ 1、无锁编程CAS 1.1、CAS CAS的全称是Compare And Swap 即比较交换，其算法核心思想如下 执行函数：CAS(V,E,N) 其包含3个参数 V表示要更新的变量 E表示预期值 N表示新值 如果V值等于E值，则将V的值设为N。若V值和E值不同，则说明已经有其他线程做了更新，则当前线程什么都不做。通俗的理解就是CAS操作需要我们提供一个期望值，当期望值与当前线程的变量值相同时，说明还没线程修改该值，当前线程可以进行修改，也就是执行CAS操作，但如果期望值与当前线程不符，则说明该值已被其他线程修改，此时不执行更新操作，但可以选择重新读取该变量再尝试再次修改该变量，也可以放弃操作，原理图如下 由于CAS操作属于乐观派，它总认为自己可以成功完成操作，当多个线程同时使用CAS操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作，这点从图中也可以看出来。基于这样的原理，CAS操作即使没有锁，同样知道其他线程对共享资源操作影响，并执行相应的处理措施。同时从这点也可以看出，由于无锁操作中没有锁的存在，因此不可能出现死锁的情况，也就是说无锁操作天生免疫死锁。 1.2、CPU指令对CAS的支持 或许我们可能会有这样的疑问，假设存在多个线程执行CAS操作并且CAS的步骤很多，有没有可能在判断V和E相同后，正要赋值时，切换了线程，更改了值。造成了数据不一致呢？答案是否定的，因为CAS是一种系统原语，原语属于操作系统用语范畴，是由若干条指令组成的，用于完成某个功能的一个过程，并且原语的执行必须是连续的，在执行过程中不允许被中断，也就是说CAS是一条CPU的原子指令，不会造成所谓的数据不一致问题。 2、 atomic族类 在atomic包下共有AtomicBoolean、AtomicInteger、AtomicIntegerArray、AtmoicReference、AtomicReferenceFieldUpdater、LongAdder等类。 在上面线程不安全的例子中，我们用1000个线程调用整型变量的i的自增，然后输出i最后的大小，在多线程情况下，这明显是线程不安全的，因为i++不是原子操作，这里我们可以使用AtomicInteger代替Integer。 12345678910111213141516171819202122232425262728293031public class AtomicIntegerExample &#123; /** * 并发线程数目 */ private static int threadNum = 1000; /** * 闭锁 */ private static CountDownLatch countDownLatch = new CountDownLatch(threadNum); private static AtomicInteger i = new AtomicInteger(0); public static void main(String[] args) throws InterruptedException &#123; ExecutorService executorService = Executors.newCachedThreadPool(); for (int j = 0; j &lt; threadNum; j++) &#123; executorService.execute(() -&gt; &#123; add(); &#125;); &#125; // 使用闭锁保证当所有统计线程完成后，主线程输出统计结果。 其实这里也可以使用Thread.sleep() 让主线程阻塞等待一会儿实现 countDownLatch.await(); System.out.println(i.get()); &#125; private static void add() &#123; countDownLatch.countDown(); i.getAndIncrement(); &#125;&#125; 上面的代码就是线程安全的，运行输出 i=1000,这是为什么呢。我们来看看getAndIncrement()方法的实现 12345678/** * Atomically increments by one the current value. * * @return the previous value */ public final int getAndIncrement() &#123; return unsafe.getAndAddInt(this, valueOffset, 1); &#125; 我们看到方法是由一个unsafe对象的getAndAddInt方法实现。我们继续点进去看看getAndAddInt方法的实现。 123456789public final int getAndAddInt(Object var1, long var2, int var4) &#123; // int var5; do &#123; var5 = this.getIntVolatile(var1, var2); &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4)); return var5; &#125; 上面就是getAndAddInt方法的实现,具体流程如下， 1、首先根据当前的传过来的对象指针，获取期望的值 var5, 2、然后while判断调用compareAndSwapInt方法 ，这是一个native本地方法，它有四个参数， 第一个参数，当前的对象，第二个参数实际的值，第三个参数期望的值，第四个参数想要更新的值。 只有实际的值等于期望的值的时候，才会把值更新成第四个参数，也就是想要的更新的值，否则一直循环尝试。 这也就是无锁编程，CAS。 在高并发的场景，这种循环尝试的次数会比较高，成功率会比较低，这样性能会比较差。但是在JDK8中推出了一个新的类名为LongAdder 我们看看它的用法。我们也继续上面的求和的例子，只需要把AtomicInteger改成LongAddr然后更改对应调用的方法即可。具体代码如下。 1234567891011121314151617181920212223242526272829303132public class LongAdderExample &#123; /** * 并发线程数目 */ private static int threadNum = 1000; /** * 闭锁 */ private static CountDownLatch countDownLatch = new CountDownLatch(threadNum); private static LongAdder i = new LongAdder(); public static void main(String[] args) throws InterruptedException &#123; ExecutorService executorService = Executors.newCachedThreadPool(); for (int j = 0; j &lt; threadNum; j++) &#123; executorService.execute(() -&gt; &#123; add(); &#125;); &#125; // 使用闭锁保证当所有统计线程完成后，主线程输出统计结果。 其实这里也可以使用Thread.sleep() 让主线程阻塞等待一会儿实现 countDownLatch.await(); System.out.println(i); &#125; private static void add() &#123; countDownLatch.countDown(); i.increment(); &#125;&#125; 运行程序，发现结果与预期的一样i=1000，是线程安全的。那么我们看看它又是如何。保证线程安全的呢。 由于篇幅原因我不跟入源码讲解了，大致思想与ConcurrentHashMapy大致一致，采用的是热点分离法， 把value分成base+cells数组，避免所有的写操作都是在value上面，这样就保证提高性能，但是在多线程情况下，统计会有误差。 接着我们讲解CAS中常常会遇到的ABA问题。 比如说一个线程one从内存位置V中取出A，这时候另一个线程two也从内存中取出A，并且two进行了一些操作变成了B，然后two又将V位置的数据变成A，这时候线程one进行CAS操作发现内存中仍然是A，然后one操作成功。尽管线程one的CAS操作成功，但是不代表这个过程就是没有问题的。如果链表的头在变化了两次后恢复了原值，但是不代表链表就没有变化。 这里我们可以借助乐观锁的一个概念，使用version版本号来判断是否一致，每次操作后版本号加1如果两次对比版本号一致才交换，这样就避免了ABA问题，在atomic包下面也提供了对应的类AtomicStampedReference。 AtomicStampedReference每次操作前判断更新的时间戳与预期的时间戳是否一致，这样就巧妙的避免了ABA问题。 最后大家希望关注一下我的个人公众号。 欢迎大家关注一下我的个人公众号。一起交流一起学习，有问必答。","categories":[{"name":"java并发编程实战","slug":"java并发编程实战","permalink":"http://www.yukonga.cn/categories/java并发编程实战/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.yukonga.cn/tags/java/"},{"name":"多线程","slug":"多线程","permalink":"http://www.yukonga.cn/tags/多线程/"},{"name":"CAS","slug":"CAS","permalink":"http://www.yukonga.cn/tags/CAS/"},{"name":"atomic","slug":"atomic","permalink":"http://www.yukonga.cn/tags/atomic/"}]},{"title":"【java并发编程实战1】何为线程安全性","slug":"【java并发编程实战1】何为线程安全性","date":"2018-08-29T11:17:02.000Z","updated":"2019-05-07T06:25:27.596Z","comments":true,"path":"2018/08/29/【java并发编程实战1】何为线程安全性/","link":"","permalink":"http://www.yukonga.cn/2018/08/29/【java并发编程实战1】何为线程安全性/","excerpt":"多线程问题，一直是我们老生常谈的一个问题，在面试中也会被经常问到，如何去学习理解多线程，何为线程安全性，那么大家跟我的脚步一起来学习一下。","text":"多线程问题，一直是我们老生常谈的一个问题，在面试中也会被经常问到，如何去学习理解多线程，何为线程安全性，那么大家跟我的脚步一起来学习一下。 线程安全性 定义： 当多个线程访问某个类时，不管运行时环境采用何种调度方式 或者这些线程如何交替执行，并且在主调代码中不需要任何额外的同步或者协同，这个类都能表现正确的行为,那么称这个类时线程安全的。 线程的安全性主要体现在三个方法 原子性：即不可分割，提供互斥访问，同一时刻只能有一个线程对它进行操作 可见性：一个线程对共享变量的修改，可以及时被其他线程观察到 有序性：序在执行的时候，程序的代码执行顺序和语句的顺序是一致的。 1、原子性 1、访问（读/写）某个共享变量的操作从其执行线程以外的线程来看，该操作要么已经执行结果，有么尚未执行，也就是说其他线程不会看到“该操作执行了部分的效果”。 2、访问同一组共享变量的原子操作 不能够被交错的。 在java中实现原子性的两种方式： 使用CAS也是atomic包下的类。 使用锁 在java语言中，除long/double之外的任何类型的变量的写操作都是原子操作。 java语言中任何变量的读操作都是原子操作。 需要注意的是 原子操作 + 原子操作 != 原子操作 例如 i++ 先读后写 读跟写都是原子操作，但是 i++并不是原子操作 下面用代码讲一下实现的两种方式 例子 123456789101112131415161718192021222324252627282930313233343536/** * @author yukong * @date 2018/8/29 * @description 线程不安全 */public class CountExample &#123; /** * 并发线程数目 */ private static int threadNum = 1000; /** * 闭锁 */ private static CountDownLatch countDownLatch = new CountDownLatch(threadNum); private static Integer i = 0; public static void main(String[] args) throws InterruptedException &#123; ExecutorService executorService = Executors.newCachedThreadPool(); for (int j = 0; j &lt; threadNum; j++) &#123; executorService.execute(() -&gt; &#123; add(); &#125;); &#125; // 使用闭锁保证当所有统计线程完成后，主线程输出统计结果。 其实这里也可以使用Thread.sleep() 让主线程阻塞等待一会儿实现 countDownLatch.await(); System.out.println(i); &#125; private static void add() &#123; countDownLatch.countDown(); i++; &#125;&#125; 上面这段代码很明显因为i++不是原子性操作，所以不是线程安全的。 那么根据上面讲的，我们可以使用锁，或者atomic包下的类实现。 2、可见性 一个线程对共享变量的修改能够及时被其他线程所观察。 这句话怎么理解呢？ 在JMM（Java Memory Model）的定义中，所有的变量都需要存储在主体内存中，主内存是共享内存区域，所有的线程都能访问的，但是线程对变量的操作（读、写）必须在工作内存中完成。 1、首先将变量从主内存中拷贝到自己的工作内存。 2、对变量进行读写操作。 3、操作完成，将变量回写到主内存中。 从上面可以得知，线程不能直接操作主内存的变量，必须要在工作内存中操作。 简单了解一下JMM的规定，那么我们就可以很容易的理解可见性了。 由上图可知 ，在多线程情况下，线程对共享变量的的操作都是拷贝一份副本到自己的工作内存中操作的，然后才写回到主内存中，这就可能存在一个问题，线程1修改了共享变量X的值，但是还未写回主内存，另外一个线程2又对主内存中的同一个共享变量x进行操作，但此时线程1工作内存中的变量x对线程n并不可以，这种工作内存与主内存同步延迟的问题就造成了可见性问题，另外指令重排序也会导致可见性问题。 那么对于可见性问题，使用什么解决方法呢？ synchronized关键字 volatile关键词 为什么synchronized能保证可见性呢？根据JMM关于synchronized的规定 线程解锁前，必须把共享变量的最新刷新到主内存。 线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要重新从主内存中读取最新值。 那么volatile又是怎么实现可见性的呢？ 其实volatile是通过加入内存屏障和禁止指令重排序优化来实现的。 对volatile变量写操作时，会在写操作后加入一条store屏障指令，将工作内存中的共享变量值刷新到主内存中 对于volatile变量读操作时，会在读操作前加入一条load屏障指定，从主内存读取共享变量最新的值到工作内存中。 那大家可能就会想问了，我把上面的代码的i变量用volatile修饰一下，是不是就保证线程安全，输出的结果就是1000呢，答案是否定的，volatile保证的是可见性，并不能保证原子性。但是利用volatile可见性这个特点，我们可以利用它完全一些线程中的通信 12345678910111213volatile boolean flag = false; // thread a&#123; flag = true; // do somethings&#125;// thread b&#123; while (flag) &#123; // do somethings &#125;&#125; 这样就完全一个线程中通信的案例。 3、有序性 在JMM（java 内存 模型）中，运行编译器和处理器对指令就行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响多线程并发执行的正确性。 在java中，可以通过volatile关键字来保证一定的有序性。另外也可以通过synchronized和Lock来保证有序性。很显然，synchronized跟lock保证每个时刻是只有一个线程执行同步代码，相当于让线程属性执行同步代码，自然保证了有序性。 另外java内存模型也具备一些先天的有序性,即不需要通过任何手段就能够保证的有序性，这个通常也称为Happen-Before原则。如果两个操作的资源无法从Happen-Before原则推导出来，那么他们就不能保证它的有序性，虚拟机就可以随机对他们进行重排序。 那么下面就详细介绍Happen-Before(先行发生原则)： 线程次序规则： 在一个线程内，按照代码顺序，书写在前的代码先行发生于书写在后的代码操作。 锁定原则：一个unlock操作先行发生于后面的对同一个锁的lock操作。 volatile变量原则，对同一个变量的写操作先行发生于后面对这个变量的读操作。 传递原则：如果操作A先行发生于操作B,而且操作B又先行发生于操作C，则可以得出操作A先行发生于操作C。 线程启动原则：Thread对象的start()方法先行发生于此线程的每一个操作。 线程中断原则：Thread对象的interrupt()方法先行发生于被中断线程检测到中断事件的发生 线程终结原则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束，Thread.isAlive()的返回值手段检测线程是否已经终止。 线程终结原则：一个对象的初始化完成先行发生于他的finalize()方法的开始。 4、总结 如果一个操作具有以上的三种特性，那么我们称它为线程安全的。 最后欢迎大家关注一下我的个人公众号 程序咖啡厅 每天一杯逐渐成长。 欢迎大家关注一下我的个人公众号。一起交流一起学习，有问必答。","categories":[{"name":"java并发编程实战","slug":"java并发编程实战","permalink":"http://www.yukonga.cn/categories/java并发编程实战/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.yukonga.cn/tags/java/"},{"name":"多线程","slug":"多线程","permalink":"http://www.yukonga.cn/tags/多线程/"},{"name":"并发编程","slug":"并发编程","permalink":"http://www.yukonga.cn/tags/并发编程/"}]},{"title":"【SpringBoot2.0系列10】SpringBoot之@Scheduled任务调度","slug":"【SpringBoot2-0系列10】SpringBoot之-Scheduled任务调度","date":"2018-08-27T12:24:29.000Z","updated":"2019-05-07T06:08:47.120Z","comments":true,"path":"2018/08/27/【SpringBoot2-0系列10】SpringBoot之-Scheduled任务调度/","link":"","permalink":"http://www.yukonga.cn/2018/08/27/【SpringBoot2-0系列10】SpringBoot之-Scheduled任务调度/","excerpt":"相信大家在实际工作场景中会遇到这样的情况，系统之间存在数据交换，为了不影响正常服务器运，我们需要在每天的凌晨来进行数据交换，但是让程序每天凌晨自动执行呢，下面带大家来了解一下springboot定时任务调度。","text":"相信大家在实际工作场景中会遇到这样的情况，系统之间存在数据交换，为了不影响正常服务器运，我们需要在每天的凌晨来进行数据交换，但是让程序每天凌晨自动执行呢，下面带大家来了解一下springboot定时任务调度。 实现 其实在springboot中实现定时任务调度十分的，下面我们将实现一个简单的定时任务调度调度。 1、依赖 scheduled 依赖是spring-context这个jar包其中我们的spring-boot-starter已经依赖spring的一些核心jar，所以我们只需要添加spring-boot-starter即可 123456789101112&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2、引入@EnableScheduling 我们需要在Spring Boot的主类中加入@EnableScheduling注解，开启定时任务的配置 123456789101112/** * @author yukong * @data 2018年8月27日19:00:21 */@EnableScheduling@SpringBootApplicationpublic class Chapter9Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Chapter9Application.class, args); &#125;&#125; 3、实现定时任务 我们创建一个名为ScheduledTask的任务类 3.1.1 @Scheduled(fixedDelay= 5000) @Scheduled(fixedDelay= 5000) 指的是上一次开始执行时间点之后5秒再执行。可能大家不知道什么意思那么下面代码编写，运行一下就知道了。 12345678910111213141516171819202122/** * @author yukong * @date 2018/8/27 * @description */@Componentpublic class ScheduledTask &#123; Logger logger = LoggerFactory.getLogger(ScheduledTask.class); private static final SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); /** * 从当前方法开始执行后5s再次执行 */ @Scheduled(fixedDelay= 5000) public void scheduledTask2() throws InterruptedException &#123; logger.info(\"当前时间为：&#123;&#125;\", simpleDateFormat.format(new Date())); Thread.sleep(3000L); &#125;&#125; 上面需要注意的是我们通过@Scheduled注解表示这个一个定时调度的任务，具体的调度策略是根据注解中的属性决定，在当前代码中fixedDelay= 5000代表从当前方法开始执行完成后5s再次执行,注意加粗部分。另外需要注意的我们的类需要用@Component注解标识，不然spring是无法感知这些定时任务的。 3.1.2测试、结论 运行结果如下 图中是每隔8s执行一次，但是我们明明设置的5s的间隔，这是怎么回事呢。回头看看我刚刚说的fixedDelay = 5000的特点：代表从当前方法开始执行完成后5s再次执行。在看看定时调用的方法中Thread.sleep(3000)就瞬间明白了。原来fixedDelay = 代表从当前方法开始执行完成后间隔一定时间再次执行。那么不需要等待当前方法执行完成又是怎么写的呢？ 3.2.1 @Scheduled(fixedRate= 5000) 其实很简单的，我们只需要将fixedDelay = 5000改成fixedRate = 5000即可。 fixedRate = 5000代表 从当前方开始执后5s再次执行，代码如下： 12345678/** * 从当前方法开始执行后5s再次执行 */@Scheduled(fixedRate = 5000)public void scheduledTask1() throws InterruptedException &#123; logger.info(\"当前时间为：&#123;&#125;\", simpleDateFormat.format(new Date())); Thread.sleep(3000L);&#125; 3.2.2测试、结论 执行结果如图，如预期的一样每隔5s秒执行一次。 3.3.1 @Scheduled(cron = “0,5,15 * * * * ?”) 如果你还需要更复杂的定时任务策略，那么你就可能需要用到cron表达式。 1.cron表达式格式： {秒数} {分钟} {小时} {日期} {月份} {星期} {年份(可为空)} 2.cron表达式各占位符解释： {秒数} ==&gt; 允许值范围: 0~59 ,不允许为空值，若值不合法，调度器将抛出SchedulerException异常 “*” 代表每隔1秒钟触发； “,” 代表在指定的秒数触发，比如&quot;0,15,45&quot;代表0秒、15秒和45秒时触发任务 &quot;-&quot;代表在指定的范围内触发，比如&quot;25-45&quot;代表从25秒开始触发到45秒结束触发，每隔1秒触发1次 “/“代表触发步进(step)，”/“前面的值代表初始值(”*“等同&quot;0”)，后面的值代表偏移量，比如&quot;0/20&quot;或者”*/20&quot;代表从0秒钟开始，每隔20秒钟触发1次，即0秒触发1次，20秒触发1次，40秒触发1次；&quot;5/20&quot;代表5秒触发1次，25秒触发1次，45秒触发1次；&quot;10-45/20&quot;代表在[10,45]内步进20秒命中的时间点触发，即10秒触发1次，30秒触发1次 {分钟} ==&gt; 允许值范围: 0~59 ,不允许为空值，若值不合法，调度器将抛出SchedulerException异常 “*” 代表每隔1分钟触发； &quot;,&quot;代表在指定的分钟触发，比如&quot;10,20,40&quot;代表10分钟、20分钟和40分钟时触发任务 “-” 代表在指定的范围内触发，比如&quot;5-30&quot;代表从5分钟开始触发到30分钟结束触 发，每隔1分钟触发 “/“代表触发步进(step)，”/“前面的值代表初始值(”*“等同&quot;0”)，后面的值代表偏移量，比如&quot;0/25&quot;或者”*/25&quot;代表从0分钟开始，每隔25分钟触发1次，即0分钟触发1次，第25分钟触发1次，第50分钟触发1次；&quot;5/25&quot;代表5分钟触发1次，30分钟触发1次，55分钟触发1次；&quot;10-45/20&quot;代表在[10,45]内步进20分钟命中的时间点触发，即10分钟触发1次，30分钟触发1次 {小时} ==&gt; 允许值范围: 0~23 ,不允许为空值，若值不合法，调度器将抛出SchedulerException异常 “*” 代表每隔1小时触发； &quot;,&quot;代表在指定的时间点触发，比如&quot;10,20,23&quot;代表10点钟、20点钟和23点触发任务 &quot;-&quot;代表在指定的时间段内触发，比如&quot;20-23&quot;代表从20点开始触发到23点结束触发，每隔1小时触发 “/“代表触发步进(step)，”/“前面的值代表初始值(”*“等同&quot;0”)，后面的值代表偏移量，比如&quot;0/1&quot;或者”*/1&quot;代表从0点开始触发，每隔1小时触发1次；&quot;1/2&quot;代表从1点开始触发，以后每隔2小时触发一次；&quot;19-20/2&quot;表达式将只在19点触发 {日期} ==&gt; 允许值范围: 1~31 ,不允许为空值，若值不合法，调度器将抛出SchedulerException异常 “*” 代表每天触发； &quot;?&quot;与{星期}互斥，即意味着若明确指定{星期}触发，则表示{日期}无意义，以免引起 冲突和混乱 “,” 代表在指定的日期触发，比如&quot;1,10,20&quot;代表1号、10号和20号这3天触发 &quot;-&quot;代表在指定的日期范围内触发，比如&quot;10-15&quot;代表从10号开始触发到15号结束触发，每隔1天触发 “/“代表触发步进(step)，”/“前面的值代表初始值(”*“等同&quot;1”)，后面的值代表偏移量，比如&quot;1/5&quot;或者”*/5&quot;代表从1号开始触发，每隔5天触发1次；&quot;10/5&quot;代表从10号开始触发，以后每隔5天触发一次；“1-10/2&quot;表达式意味着在[1,10]范围内，每隔2天触发，即1号，3号，5号，7号，9号触发 “L” 如果{日期}占位符如果是&quot;L”，即意味着当月的最后一天触发 &quot;W &quot;意味着在本月内离当天最近的工作日触发，所谓最近工作日，即当天到工作日的前后最短距离，如果当天即为工作日，则距离为0；所谓本月内的说法，就是不能跨月取到最近工作日，即使前/后月份的最后一天/第一天确实满足最近工作日；因此，&quot;LW&quot;则意味着本月的最后一个工作日触发，&quot;W&quot;强烈依赖{月份} “C” 根据日历触发，由于使用较少，暂时不做解释 {月份} ==&gt; 允许值范围: 1~12 (JAN-DEC),不允许为空值，若值不合法，调度器将抛出SchedulerException异常 “*” 代表每个月都触发； “,” 代表在指定的月份触发，比如&quot;1,6,12&quot;代表1月份、6月份和12月份触发任务 &quot;-&quot;代表在指定的月份范围内触发，比如&quot;1-6&quot;代表从1月份开始触发到6月份结束触发，每隔1个月触发 “/“代表触发步进(step)，”/“前面的值代表初始值(”*“等同&quot;1”)，后面的值代表偏移量，比如&quot;1/2&quot;或者”*/2&quot;代表从1月份开始触发，每隔2个月触发1次；&quot;6/6&quot;代表从6月份开始触发，以后每隔6个月触发一次；&quot;1-6/12&quot;表达式意味着每年1月份触发 {星期} ==&gt; 允许值范围: 1~7 (SUN-SAT),1代表星期天(一星期的第一天)，以此类推，7代表星期六(一星期的最后一天)，不允许为空值，若值不合法，调度器将抛出SchedulerException异常 “*” 代表每星期都触发； &quot;?&quot;与{日期}互斥，即意味着若明确指定{日期}触发，则表示{星期}无意义，以免引起冲突和混乱 “,” 代表在指定的星期约定触发，比如&quot;1,3,5&quot;代表星期天、星期二和星期四触发 &quot;-&quot;代表在指定的星期范围内触发，比如&quot;2-4&quot;代表从星期一开始触发到星期三结束触发，每隔1天触发 “/“代表触发步进(step)，”/“前面的值代表初始值(”*“等同&quot;1”)，后面的值代表偏移量，比如&quot;1/3&quot;或者”*/3&quot;代表从星期天开始触发，每隔3天触发1次；&quot;1-5/2&quot;表达式意味着在[1,5]范围内，每隔2天触发，即星期天、星期二、星期四触发 “L&quot;如果{星期}占位符如果是&quot;L”，即意味着星期的的最后一天触发，即星期六触发，L= 7或者 L = SAT，因此，&quot;5L&quot;意味着一个月的最后一个星期四触发 &quot;#“用来指定具体的周数，”#“前面代表星期，”#&quot;后面代表本月第几周，比如&quot;2#2&quot;表示本月第二周的星期一，&quot;5#3&quot;表示本月第三周的星期四，因此，“5L&quot;这种形式只不过是”#&quot;的特殊形式而已 “C” 根据日历触发，由于使用较少，暂时不做解释 {年份} ==&gt; 允许值范围: 1970~2099 ,允许为空，若值不合法，调度器将抛出SchedulerException异常 &quot;*&quot;代表每年都触发； &quot;,&quot;代表在指定的年份才触发，比如&quot;2011,2012,2013&quot;代表2011年、2012年和2013年触发任务 &quot;-“代表在指定的年份范围内触发，比如&quot;2011-2020&quot;代表从2011年开始触发到2020年结束触发，每隔1年触发 “/“代表触发步进(step)，”/“前面的值代表初始值(”*“等同&quot;1970”)，后面的值代表偏移量，比如&quot;2011/2&quot;或者”*/2&quot;代表从2011年开始触发，每隔2年触发1次 注意：除了{日期}和{星期}可以使用”?&quot;来实现互斥，表达无意义的信息之外，其他占位符都要具有具体的时间含义，且依赖关系为：年-&gt;月-&gt;日期(星期)-&gt;小时-&gt;分钟-&gt;秒数 具体cron你可以参考cron详解 现在我们实现一个每分钟的第0,5,15秒执行一次，那么对应的cron表达式应为0,5,15 * * * * ? 实现的代码如下 1234@Scheduled(cron = \"0,5,15 * * * * ?\") public void cronTask() &#123; logger.info(\"当前时间为：&#123;&#125;\", simpleDateFormat.format(new Date())); &#125; 3.3.2运行 启动，运行结果如下： 每分钟的第0,5,15秒都执行，如果你还需要其他的规则，只需要更改对应cron表达式，相信cron的强大能够满足所有的业务场景。 结语 相信通过本次学习，大家应该知道如何在springboot使用定时任务了。 最后配套教程的代码全部在这里 github https://github.com/YuKongEr/SpringBoot-Study。麻烦点个star或者fork吧。 最后欢迎大家关注一下我的个人公众号。一起交流一起学习，有问必答。","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://www.yukonga.cn/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://www.yukonga.cn/tags/SpringBoot/"},{"name":"Scheduled","slug":"Scheduled","permalink":"http://www.yukonga.cn/tags/Scheduled/"}]},{"title":"解开BIO、NIO、AIO神秘的面纱","slug":"解开BIO、NIO、AIO神秘的面纱","date":"2018-08-25T07:14:05.000Z","updated":"2019-06-13T01:25:24.130Z","comments":true,"path":"2018/08/25/解开BIO、NIO、AIO神秘的面纱/","link":"","permalink":"http://www.yukonga.cn/2018/08/25/解开BIO、NIO、AIO神秘的面纱/","excerpt":"本文内容涉及同步与异步, 阻塞与非阻塞, BIO、NIO、AIO等概念, 这块内容本身比较复杂, 很难用三言两语说明白. 而书上的定义更不容易理解是什么意思. 下面跟着我一起解开它们神秘的面纱。","text":"本文内容涉及同步与异步, 阻塞与非阻塞, BIO、NIO、AIO等概念, 这块内容本身比较复杂, 很难用三言两语说明白. 而书上的定义更不容易理解是什么意思. 下面跟着我一起解开它们神秘的面纱。 BIO 传统的socket编程，属于同步阻塞模型 NIO 官方(new io) jdk1.4推出 俗称(non-block io) ，属于同步非阻塞模式 AIO 又称NIO2.0在jdk1.7推出，属于异步非阻塞模式 #解读同步异步，阻塞非阻塞。 阻塞和非阻塞 从简单的开始，我们以经典的读取文件的模型举例。（对操作系统而言，所有的输入输出设备都被抽象成文件。） 在发起读取文件的请求时，应用层会调用系统内核的I/O接口。 如果应用层调用的是阻塞型I/O，那么在调用之后，应用层即刻被挂起，一直出于等待数据返回的状态，直到系统内核从磁盘读取完数据并返回给应用层，应用层才用获得的数据进行接下来的其他操作。 如果应用层调用的是非阻塞I/O，那么调用后，系统内核会立即返回（虽然还没有文件内容的数据），应用层并不会被挂起，它可以做其他任意它想做的操作。（至于文件内容数据如何返回给应用层，这已经超出了阻塞和非阻塞的辨别范畴。） 这便是（脱离同步和异步来说之后）阻塞和非阻塞的区别。总结来说，是否是阻塞还是非阻塞，关注的是接口调用（发出请求）后等待数据返回时的状态。被挂起无法执行其他操作的则是阻塞型的，可以被立即「抽离」去完成其他「任务」的则是非阻塞型的。 同步和异步 阻塞和非阻塞解决了应用层等待数据返回时的状态问题，那系统内核获取到的数据到底如何返回给应用层呢？这里不同类型的操作便体现的是同步和异步的区别。 对于同步型的调用，应用层需要自己去向系统内核问询，如果数据还未读取完毕，那此时读取文件的任务还未完成，应用层根据其阻塞和非阻塞的划分，或挂起或去做其他事情（所以同步和异步并不决定其等待数据返回时的状态）；如果数据已经读取完毕，那此时系统内核将数据返回给应用层，应用层即可以用取得的数据做其他相关的事情。 而对于异步型的调用，应用层无需主动向系统内核问询，在系统内核读取完文件数据之后，会主动通知应用层数据已经读取完毕，此时应用层即可以接收系统内核返回过来的数据，再做其他事情。 这便是（脱离阻塞和非阻塞来说之后）同步和异步的区别。也就是说，是否是同步还是异步，关注的是任务完成时消息通知的方式。由调用方盲目主动问询的方式是同步调用，由被调用方主动通知调用方任务已完成的方式是异步调用。 假设小明需要在网上下载一个软件： 如果小明点击下载按钮之后，就一直干瞪着进度条不做其他任何事情直到软件下载完成，这是同步阻塞； 如果小明点击下载按钮之后，就一直干瞪着进度条不做其他任何事情直到软件下载完成，但是软件下载完成其实是会「叮」的一声通知的（但小明依然那样干等着），这是异步阻塞；（不常见） 如果小明点击下载按钮之后，就去做其他事情了，不过他总需要时不时瞄一眼屏幕看软件是不是下载完成了，这是同步非阻塞； 如果小明点击下载按钮之后，就去做其他事情了，软件下载完之后「叮」的一声通知小明，小明再回来继续处理下载完的软件，这是异步非阻塞。 相信看完以上这个案例之后，这几个概念已经能够分辨得很清楚了。 总的来说，同步和异步关注的是任务完成消息通知的机制，而阻塞和非阻塞关注的是等待任务完成时请求者的状态。 java网络编程 我们通过 客户端像服务端查询信息作为一个例子。分别通过三种模型来实现。 1.1、传统的BIO 在传统的网络编程中，服务端监听端口，客户端请求服务端的ip跟监听的端口，跟服务端通信，必须三次握手建立。如果连接成功，通过套接字（socket）进行通信。 在BIO通信模型：采用BIO通信模型的服务端，通常由一个独立的Acceptor线程负责监听客户端的连接，它接收到客户端连接请求之后为每个客户端创建一个新的线程进行链路处理没处理完成后，通过输出流返回应答给客户端，线程销毁。即典型的一请求一应答通信模型。 从图中可以得知，该模型中每一个请求对应一个线程处理，在线程数量有限的情况下，请求数量多，那么服务器就会因为资源不足而挂掉。 服务端代码 12345678910111213141516171819202122232425262728293031323334/** * @author yukong * @date 2018年8月24日18:51:40 * 服务端 */public class Server &#123; /** * 默认端口 */ private static final Integer DEFAULT_PORT = 6789; public void start() throws IOException &#123; start(DEFAULT_PORT); &#125; public void start(Integer port) throws IOException &#123; ServerSocket serverSocket = new ServerSocket(port); System.out.println(\"小yu机器人启动，监听端口为：\" + port); //通过无线循环监听客户端连接 while (true) &#123; // 阻塞方法，直至有客户端连接成功 Socket socket = serverSocket.accept(); // 多线程处理客户端请求 new Thread(new ServerHandler(socket)).start(); &#125; &#125; public static void main(String[] args) throws IOException &#123; new Server().start(); &#125;&#125; 服务端处理器代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * @author yukong * @date 2018年8月24日18:51:40 * 服务端业务逻辑处理器 */public class ServerHandler implements Runnable&#123; private Socket socket; public ServerHandler(Socket socket) &#123; this.socket = socket; &#125; @Override public void run() &#123; BufferedReader in = null; PrintWriter out = null; try &#123; // 获取socket的字符缓存输入流 也就是获取客户端给服务器的字符流 in = new BufferedReader( new InputStreamReader(this.socket.getInputStream())); // 获取socket的字符输出流 也就是发送的客户的字符流 第二个参数自动刷新 out = new PrintWriter( new OutputStreamWriter(this.socket.getOutputStream()), true); String request, response; // 读取输入流的消息 如果为空 则退出读取 while ((request = in.readLine()) != null) &#123; System.out.println(\"[\" + Thread.currentThread().getName()+ \"]\" + \"小yu机器人收到消息：\" + request); // 具体业务逻辑处理 查询信息。 response = ResponseUtil.queryMessage(request); out.println(response); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; // 资源释放 if (in != null) &#123; try &#123; in.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; in = null; &#125; if (out != null) &#123; out.close(); out = null; &#125; if (socket != null) &#123; try &#123; socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; socket = null; &#125; &#125; &#125;&#125; 客户端代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * @author yukong * @date 2018年8月24日18:51:40 * 客户端 */public class Client &#123; /** * 默认端口 */ private static final Integer DEFAULT_PORT = 6789; /** * 默认端口 */ private static final String DEFAULT_HOST = \"localhost\"; public void send(String key)&#123; send(DEFAULT_PORT,key); &#125; public void send(int port,String key)&#123; System.out.println(\"查询的key为：\" + key); Socket socket = null; BufferedReader in = null; PrintWriter out = null; try&#123; socket = new Socket(DEFAULT_HOST,port); in = new BufferedReader(new InputStreamReader(socket.getInputStream())); out = new PrintWriter(socket.getOutputStream(),true); out.println(key); System.out.println(\"查询的结果为：\" + in.readLine()); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally&#123; if(in != null)&#123; try &#123; in.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; in = null; &#125; if(out != null)&#123; out.close(); out = null; &#125; if(socket != null)&#123; try &#123; socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; socket = null; &#125; &#125; &#125; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); Client client = new Client(); while (scanner.hasNext()) &#123; String key = scanner.next(); client.send(key); &#125; &#125;&#125; 从代码中可以得知，我们每次请求都是new Thread去处理，意味着线程消耗巨大，可能会有朋友说道，那就用线程池，同样的如果使用线程池，当达到线程最大数量，也会达到瓶颈。该模式不适合高并发的访问。 1.2 NIO模型 NIO提供了与传统BIO模型中的Socket和ServerSocket相对应的SocketChannel和ServerSocketChannel两种不同的套接字通道实现。 新增的着两种通道都支持阻塞和非阻塞两种模式。 阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。 对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用NIO的非阻塞模式来开发。 下面会先对基础知识进行介绍。 1.2.1、缓冲区 Buffer Buffer是一个对象，包含一些要写入或者读出的数据。 在NIO库中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的；在写入数据时，也是写入到缓冲区中。任何时候访问NIO中的数据，都是通过缓冲区进行操作。 缓冲区实际上是一个数组，并提供了对数据结构化访问以及维护读写位置等信息。 具体的缓存区有这些：ByteBuffe、CharBuffer、 ShortBuffer、IntBuffer、LongBuffer、FloatBuffer、DoubleBuffer。他们实现了相同的接口：Buffer。 1.2.2、通道 Channel 我们对数据的读取和写入要通过Channel，它就像水管一样，是一个通道。通道不同于流的地方就是通道是双向的，可以用于读、写和同时读写操作。 底层的操作系统的通道一般都是全双工的，所以全双工的Channel比流能更好的映射底层操作系统的API。 Channel主要分两大类： SelectableChannel：用户网络读写 FileChannel：用于文件操作 后面代码会涉及的ServerSocketChannel和SocketChannel都是SelectableChannel的子类。 1. 2.3、多路复用器 Selector Selector是Java NIO 编程的基础。 Selector提供选择已经就绪的任务的能力：Selector会不断轮询注册在其上的Channel，如果某个Channel上面发生读或者写事件，这个Channel就处于就绪状态，会被Selector轮询出来，然后通过SelectionKey可以获取就绪Channel的集合，进行后续的I/O操作。 一个Selector可以同时轮询多个Channel，因为JDK使用了epoll()代替传统的select实现，所以没有最大连接句柄1024/2048的限制。所以，只需要一个线程负责Selector的轮询，就可以接入成千上万的客户端。 服务端代码 1234567891011121314151617181920212223242526272829303132333435/** * 服务端 */public class Server &#123; /** * 默认端口 */ private static final Integer DEFAULT_PORT = 6780; public void start() throws IOException &#123; start(DEFAULT_PORT); &#125; public void start(Integer port) throws IOException &#123; // 打开多路复用选择器 Selector selector = Selector.open(); // 打开服务端监听通道 ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); // 设置为非阻塞模式 serverSocketChannel.configureBlocking(false); // 绑定监听的端口 serverSocketChannel.bind(new InetSocketAddress(port)); // 将选择器绑定到监听信道,只有非阻塞信道才可以注册选择器.并在注册过程中指出该信道可以进行Accept操作 serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT); System.out.println(\"小yu机器人启动，监听端口为：\" + port); new Thread(new ServerHandler(selector)).start(); &#125; public static void main(String[] args) throws IOException &#123; new Server().start(); &#125;&#125; 服务端处理器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384public class ServerHandler implements Runnable&#123; private Selector selector; public ServerHandler(Selector selector) &#123; this.selector = selector; &#125; @Override public void run() &#123; try &#123; while (true) &#123; // 等待某信道就绪(或超时) if(selector.select(1000)==0)&#123;// System.out.print(\"独自等待.\"); continue; &#125; // 取得迭代器.selectedKeys()中包含了每个准备好某一I/O操作的信道的SelectionKey Iterator&lt;SelectionKey&gt; keyIterator=selector.selectedKeys().iterator(); while (keyIterator.hasNext())&#123; SelectionKey sk = keyIterator.next(); // 删除已选的key 以防重负处理 keyIterator.remove(); // 处理key handlerSelect(sk); &#125; &#125; &#125; catch (IOException e) &#123; &#125; &#125; private void handlerSelect(SelectionKey sk) throws IOException &#123; // 处理新接入的请求 if (sk.isAcceptable()) &#123; ServerSocketChannel ssc = (ServerSocketChannel) sk.channel(); //通过ServerSocketChannel的accept创建SocketChannel实例 //完成该操作意味着完成TCP三次握手，TCP物理链路正式建立 SocketChannel sc = ssc.accept(); //设置为非阻塞的 sc.configureBlocking(false); //注册为读 sc.register(selector, SelectionKey.OP_READ); &#125; // 读操作 if (sk.isReadable()) &#123; String request, response; SocketChannel sc = (SocketChannel) sk.channel(); // 创建一个ByteBuffer 并设置大小为1m ByteBuffer byteBuffer = ByteBuffer.allocate(1024); // 获取到读取的字节长度 int readBytes = sc.read(byteBuffer); // 判断是否有数据 if (readBytes &gt; 0) &#123; //将缓冲区当前的limit设置为position=0，用于后续对缓冲区的读取操作 byteBuffer.flip(); //根据缓冲区可读字节数创建字节数组 byte[] bytes = new byte[byteBuffer.remaining()]; // 复制至新的缓冲字节流 byteBuffer.get(bytes); request = new String(bytes, \"UTF-8\"); System.out.println(\"[\" + Thread.currentThread().getName()+ \"]\" + \"小yu机器人收到消息：\" + request); // 具体业务逻辑处理 查询信息。 response = ResponseUtil.queryMessage(request); //将消息编码为字节数组 byte[] responseBytes = response.getBytes(); //根据数组容量创建ByteBuffer ByteBuffer writeBuffer = ByteBuffer.allocate(responseBytes.length); //将字节数组复制到缓冲区 writeBuffer.put(responseBytes); //flip操作 writeBuffer.flip(); //发送缓冲区的字节数组 sc.write(writeBuffer); &#125; &#125; &#125;&#125; 客户端 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * 客户端 */public class Client &#123; // 通道选择器 private Selector selector; // 与服务器通信的通道 SocketChannel socketChannel; /** * 默认端口 */ private static final Integer DEFAULT_PORT = 6780; /** * 默认端口 */ private static final String DEFAULT_HOST = \"127.0.0.1\"; public void send(String key) throws IOException &#123; send(DEFAULT_PORT, DEFAULT_HOST, key); &#125; public void send(int port,String host, String key) throws IOException &#123; init(port, host); System.out.println(\"查询的key为：\" + key); //将消息编码为字节数组 byte[] bytes = key.getBytes(); //根据数组容量创建ByteBuffer ByteBuffer writeBuffer = ByteBuffer.allocate(bytes.length); //将字节数组复制到缓冲区 writeBuffer.put(bytes); //flip操作 writeBuffer.flip(); //发送缓冲区的字节数组 socketChannel.write(writeBuffer); //****此处不含处理“写半包”的代码 &#125; public void init(int port,String host) throws IOException &#123; // 创建选择器 selector = Selector.open(); // 设置链接的服务端地址 InetSocketAddress socketAddress = new InetSocketAddress(host, port); // 打开通道 socketChannel = SocketChannel.open(socketAddress);// 非阻塞 socketChannel.configureBlocking(false); socketChannel.register(selector, SelectionKey.OP_READ); new Thread(new ClientHandler(selector)).start(); &#125; public static void main(String[] args) throws IOException &#123; Scanner scanner = new Scanner(System.in); Client client = new Client(); while (scanner.hasNext()) &#123; String key = scanner.next(); client.send(key); &#125; &#125;&#125; 客户端处理器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class ClientHandler implements Runnable &#123; private Selector selector; public ClientHandler(Selector selector) &#123; this.selector = selector; &#125; @Override public void run() &#123; try &#123; while (true) &#123; if(selector.select(1000) &lt; 0) &#123; continue; &#125; Set&lt;SelectionKey&gt; keys = selector.selectedKeys(); Iterator&lt;SelectionKey&gt; selectionKeyIterator = keys.iterator(); while (selectionKeyIterator.hasNext()) &#123; SelectionKey sc = selectionKeyIterator.next(); selectionKeyIterator.remove(); //读消息 if (sc.isReadable()) &#123; SocketChannel socketChannel = (SocketChannel) sc.channel(); //创建ByteBuffer，并开辟一个1M的缓冲区 ByteBuffer byteBuffer = ByteBuffer.allocate(1024); //读取请求码流，返回读取到的字节数 int byteSize = socketChannel.read(byteBuffer); if (byteSize &gt; 0) &#123; //将缓冲区当前的limit设置为position=0，用于后续对缓冲区的读取操作 byteBuffer.flip(); //根据缓冲区可读字节数创建字节数组 总长度减去空余的 byte[] bytes = new byte[byteBuffer.remaining()]; // 复制至新的缓冲字节流 byteBuffer.get(bytes); String message = new String(bytes, \"UTF-8\"); System.out.println(message); &#125; &#125; &#125; &#125; &#125; catch (IOException e) &#123; &#125; &#125;&#125; 从代码中 我们也能看出来，nio解决的是阻塞与非阻塞的，通过selector轮询上注册的channel的状态，来获取对应准备就绪channel的 那么请求者就不用一直去accpet阻塞，等待了。那为什么是同步呢，因为还是我们请求者不停的轮询selector是否有完全就绪的channel。 3、AIO编程 NIO 2.0引入了新的异步通道的概念，并提供了异步文件通道和异步套接字通道的实现。 异步的套接字通道时真正的异步非阻塞I/O，对应于UNIX网络编程中的事件驱动I/O（AIO）。他不需要过多的Selector对注册的通道进行轮询即可实现异步读写，从而简化了NIO的编程模型。 服务端代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112/** * 异步非阻塞服务端 */public class Sever &#123; /** * 默认端口 */ private static final Integer DEFAULT_PORT = 6780; private AsynchronousServerSocketChannel serverChannel; //作为handler接收客户端连接 class ServerCompletionHandler implements CompletionHandler&lt;AsynchronousSocketChannel, Void&gt; &#123; private AsynchronousServerSocketChannel serverChannel; private ByteBuffer buffer = ByteBuffer.allocateDirect(1024); private CharBuffer charBuffer; private CharsetDecoder decoder = Charset.defaultCharset().newDecoder(); public ServerCompletionHandler(AsynchronousServerSocketChannel serverChannel) &#123; this.serverChannel = serverChannel; &#125; @Override public void completed(AsynchronousSocketChannel result, Void attachment) &#123; //立即接收下一个请求,不停顿 serverChannel.accept(null, this); try &#123; while (result.read(buffer).get() != -1) &#123; buffer.flip(); charBuffer = decoder.decode(buffer); String request = charBuffer.toString().trim(); System.out.println(\"[\" + Thread.currentThread().getName()+ \"]\" + \"小yu机器人收到消息：\" + request); // 具体业务逻辑处理 查询信息。 String response = ResponseUtil.queryMessage(request); //将消息编码为字节数组 byte[] responseBytes = response.getBytes(); //根据数组容量创建ByteBuffer ByteBuffer outBuffer = ByteBuffer.allocate(responseBytes.length); //将字节数组复制到缓冲区 outBuffer.put(responseBytes); //flip操作 outBuffer.flip(); //发送缓冲区的字节数组 result.write(outBuffer).get(); if (buffer.hasRemaining()) &#123; buffer.compact(); &#125; else &#123; buffer.clear(); &#125; &#125; &#125; catch (InterruptedException | ExecutionException e) &#123; e.printStackTrace(); &#125; catch (CharacterCodingException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; result.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; @Override public void failed(Throwable exc, Void attachment) &#123; //立即接收下一个请求,不停顿 serverChannel.accept(null, this); throw new RuntimeException(\"connection failed!\"); &#125; &#125; public void init() throws IOException, InterruptedException &#123; init(DEFAULT_PORT); &#125; public void init(Integer port) throws IOException, InterruptedException &#123; // 打开异步通道 this.serverChannel = AsynchronousServerSocketChannel.open(); // 判断通道是否打开 if (serverChannel.isOpen()) &#123; serverChannel.setOption(StandardSocketOptions.SO_RCVBUF, 4 * 1024); serverChannel.setOption(StandardSocketOptions.SO_REUSEADDR, true); serverChannel.bind(new InetSocketAddress(port)); &#125; else &#123; throw new RuntimeException(\"Channel not opened!\"); &#125; start(port); &#125; public void start(Integer port) throws InterruptedException &#123; System.out.println(\"小yu机器人启动，监听端口为：\" + port); this.serverChannel.accept(null, new ServerCompletionHandler(serverChannel)); // 保证线程不会挂了 while (true) &#123; Thread.sleep(5000); &#125; &#125; public static void main(String[] args) throws IOException, InterruptedException &#123; Sever server = new Sever(); server.init(); &#125;&#125; 客户端 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384public class Client &#123; class ClientCompletionHandler implements CompletionHandler&lt;Void, Void&gt; &#123; private AsynchronousSocketChannel channel; private CharBuffer charBufferr = null; private CharsetDecoder decoder = Charset.defaultCharset().newDecoder(); private BufferedReader clientInput = new BufferedReader(new InputStreamReader(System.in)); public ClientCompletionHandler(AsynchronousSocketChannel channel) &#123; this.channel = channel; &#125; @Override public void completed(Void result, Void attachment) &#123; System.out.println(\"Input Client Reuest:\"); String request; try &#123; request = clientInput.readLine(); channel.write(ByteBuffer.wrap(request.getBytes())); ByteBuffer buffer = ByteBuffer.allocateDirect(1024); while(channel.read(buffer).get() != -1)&#123; buffer.flip(); charBufferr = decoder.decode(buffer); System.out.println(charBufferr.toString()); if(buffer.hasRemaining())&#123; buffer.compact(); &#125; else&#123; buffer.clear(); &#125; request = clientInput.readLine(); channel.write(ByteBuffer.wrap(request.getBytes())).get(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; channel.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; @Override public void failed(Throwable exc, Void attachment) &#123; throw new RuntimeException(\"channel not opened!\"); &#125; &#125; public void start() throws IOException, InterruptedException&#123; AsynchronousSocketChannel channel = AsynchronousSocketChannel.open(); if(channel.isOpen())&#123; channel.setOption(StandardSocketOptions.SO_RCVBUF, 128*1024); channel.setOption(StandardSocketOptions.SO_SNDBUF, 128*1024); channel.setOption(StandardSocketOptions.SO_KEEPALIVE,true); channel.connect(new InetSocketAddress(\"127.0.0.1\",6780),null,new ClientCompletionHandler(channel)); while(true)&#123; Thread.sleep(5000); &#125; &#125; else&#123; throw new RuntimeException(\"Channel not opened!\"); &#125; &#125; public static void main(String[] args) throws IOException, InterruptedException&#123; Client client = new Client(); client.start(); &#125;&#125; 4、各种I/O的对比 先以一张表来直观的对比一下： 5 References 完全理解同步/异步与阻塞/非阻塞 Java 网络IO编程总结 下面是配套的完整代码地址 完整代码地址","categories":[{"name":"java网络编程","slug":"java网络编程","permalink":"http://www.yukonga.cn/categories/java网络编程/"}],"tags":[{"name":"NIO","slug":"NIO","permalink":"http://www.yukonga.cn/tags/NIO/"},{"name":"AIO","slug":"AIO","permalink":"http://www.yukonga.cn/tags/AIO/"},{"name":"BIO","slug":"BIO","permalink":"http://www.yukonga.cn/tags/BIO/"},{"name":"Socket","slug":"Socket","permalink":"http://www.yukonga.cn/tags/Socket/"}]},{"title":"【SpringBoot2.0系列09】SpringBoot之rabbitmq使用","slug":"【SpringBoot2-0系列09】SpringBoot之rabbitmq使用","date":"2018-08-22T13:44:02.000Z","updated":"2019-05-07T06:14:09.987Z","comments":true,"path":"2018/08/22/【SpringBoot2-0系列09】SpringBoot之rabbitmq使用/","link":"","permalink":"http://www.yukonga.cn/2018/08/22/【SpringBoot2-0系列09】SpringBoot之rabbitmq使用/","excerpt":"消息队列中间件是分布式系统中重要的组件，主要解决应用耦合，异步消息，流量削锋等问题实现高性能，高可用，可伸缩和最终一致性架构 使用较多的消息队列有ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaMQ，RocketMQ。 今天我们将会了解到在SpringBoot中使用rabbitmq","text":"消息队列中间件是分布式系统中重要的组件，主要解决应用耦合，异步消息，流量削锋等问题实现高性能，高可用，可伸缩和最终一致性架构 使用较多的消息队列有ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaMQ，RocketMQ。 今天我们将会了解到在SpringBoot中使用rabbitmq 实现 1.1 rabbitmq简介 RabbitMQ是由Erlang语言编写的实现了高级消息队列协议（AMQP）的开源消息代理软件（也可称为 面向消息的中间件）。支持Windows、Linux/Unix、MAC OS X操作系统和包括JAVA在内的多种编程语言。 AMQP，即Advanced Message Queuing Protocol，一个提供统一消息服务的应用层标准高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受 客户端/中间件 不同产品，不同的开发语言等条件的限制 使用rabbitmq主要三种分发模式 1.1.1 工作队列模式(Work Queue) 避免立即做一个资源密集型任务，必须等待它完成，而是把这个任务安排到稍后再做。我们将任务封装为消息并将其发送给队列。后台运行的工作进程将弹出任务并最终执行作业。当有多个worker同时运行时，任务将在它们之间共享。 1.1.2 分发模式(Fanout Exchange) 一个生产者，多个消费者，每一个消费者都有自己的一个队列，生产者没有将消息直接发送到队列，而是发送到了交换机，每个队列绑定交换机，生产者发送的消息经过交换机，到达队列，实现一个消息被多个消费者获取的目的。需要注意的是，如果将消息发送到一个没有队列绑定的exchange上面，那么该消息将会丢失，这是因为在rabbitMQ中exchange不具备存储消息的能力，只有队列具备存储消息的能力。 1.1.3 通配符模式（Topic Exchange） 这种模式添加了一个路由键，生产者发布消息的时候添加路由键，消费者绑定队列到交换机时添加键值，这样就可以接收到需要接收的消息。 符号“#”匹配一个或多个词，符号“*”匹配不多不少一个词 1.2、安装rabbitmq 1.2.1 window 因为rabbitmq是erlang实现，所以我们需要先下载安装erlang，然后再下载rabbitmq 1.2.2 mac 在mac系统中可以直接使用brew安装，它会帮我们自动安装管理依赖。 12brew updatebrew install rabbitmq 这样，我们就可以使用rabbit-server启动Rabbit服务了。 1.2.3 centos 在centos中可以使用yum安装 1sudo yum install rabbitmq 1.3 springboot整合 首先新建一个项目名为rabbit-producer 消息生产者工程 并且添加依赖。 123456789101112131415161718&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 在yml配置rabbitmq地址 123456# rabbitmq配置spring: rabbitmq: addresses: 127.0.0.1 username: guest password: guest: 同理创建rabbit-consumer 消息消费者工程 1、普通工作队列模式 首先在rabbit-producer工程中新建RabbitConfig文件，用于配置我们rabbitmq相关的资源 代码如下 1234567891011121314151617181920212223242526272829package com.yukong.rabbitproducer;import org.springframework.amqp.core.*;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * @author yukong * @date 2018/8/22 * @description rabbitmq配置类 */@Configurationpublic class RabbitConfig &#123; /** * 定义队列名 */ private final static String STRING = \"string\"; /** * 定义string队列 * @return */ @Bean public Queue string() &#123; return new Queue(STRING); &#125; 定义了名为string的队列。然后我们创建生产者RabbitProducer 1234567891011121314151617181920212223242526272829package com.yukong.rabbitproducer;import org.springframework.amqp.core.AmqpTemplate;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;import javax.xml.ws.Action;import java.text.SimpleDateFormat;import java.util.Date;/** * @author yukong * @date 2018/8/22 * @description rabbit消息生产者 */@Componentpublic class RabbitProducer &#123; @Autowired private AmqpTemplate rabbitTemplate; public void stringSend() &#123; Date date = new Date(); String dateString = new SimpleDateFormat(\"YYYY-mm-DD hh:MM:ss\").format(date); System.out.println(\"[string] send msg:\" + dateString); // 第一个参数为刚刚定义的队列名称 this.rabbitTemplate.convertAndSend(\"string\", dateString); &#125;&#125; 这里注入一个AmqpTemplate来发布消息 接下来我们需要在rabbit-consumer工程配置一下消费者。 创建StringConsumer 1234567891011121314151617181920212223242526272829package com.yukong.rabbitmqconsumer;import org.springframework.amqp.core.AmqpTemplate;import org.springframework.amqp.rabbit.annotation.RabbitHandler;import org.springframework.amqp.rabbit.annotation.RabbitListener;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;/** * @author yukong * @date 2018/8/22 * @description rabbitmq消费者 @RabbitListener(queues = \"simpleMsg\") 监听名simpleMsg的队列 */@Component@RabbitListener(queues = \"string\")public class StringConsumer &#123; @Autowired private AmqpTemplate rabbitmqTemplate; /** * 消息消费 * @RabbitHandler 代表此方法为接受到消息后的处理方法 */ @RabbitHandler public void recieved(String msg) &#123; System.out.println(\"[string] recieved message:\" + msg); &#125;&#125; 每一个注解的作用代码里面的注释说的很详细了我就不重复说了。 然后我们来测试， 首先在生产者工程新建一个测试类，用于生产消息。 代码如下 1234567891011121314151617181920212223package com.yukong.rabbitproducer;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;@RunWith(SpringRunner.class)@SpringBootTestpublic class RabbitProducerApplicationTests &#123; @Autowired private RabbitProducer producer; @Test public void testStringSend() &#123; for (int i = 0; i &lt; 10; i++) &#123; producer.stringSend(); &#125; &#125;&#125; 首先启动生产者工程的测试类。然后再启动消费者工程。 消息生产成功，一共十条。 启动消费者工程。 消费者成功消费消息。 2、 fanout模式 fanout属于广播模式，只要跟它绑定的队列都会通知并且接受到消息。 我们同理在RabbitConfig中配置一下fanout模式的队列跟交换机。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//=================== fanout 模式 ==================== @Bean public Queue fanoutA() &#123; return new Queue(\"fanout.a\"); &#125; @Bean public Queue fanoutB() &#123; return new Queue(\"fanout.b\"); &#125; @Bean public Queue fanoutC() &#123; return new Queue(\"fanout.c\"); &#125; /** * 定义个fanout交换器 * @return */ @Bean FanoutExchange fanoutExchange() &#123; // 定义一个名为fanoutExchange的fanout交换器 return new FanoutExchange(\"fanoutExchange\"); &#125; /** * 将定义的fanoutA队列与fanoutExchange交换机绑定 * @return */ @Bean public Binding bindingExchangeWithA() &#123; return BindingBuilder.bind(fanoutA()).to(fanoutExchange()); &#125; /** * 将定义的fanoutB队列与fanoutExchange交换机绑定 * @return */ @Bean public Binding bindingExchangeWithB() &#123; return BindingBuilder.bind(fanoutB()).to(fanoutExchange()); &#125; /** * 将定义的fanoutC队列与fanoutExchange交换机绑定 * @return */ @Bean public Binding bindingExchangeWithC() &#123; return BindingBuilder.bind(fanoutC()).to(fanoutExchange()); &#125; 在代码中我们配置了三个队列名、一个fanout交换机，并且将这三个队列绑定到了fanout交换器上。只要我们往这个交换机生产新的消息，那么这三个队列都会收到。 接下来，我们在RabbitProducer 中添加fanout的生产方法。 1234567public void fanoutSend() &#123; Date date = new Date(); String dateString = new SimpleDateFormat(\"YYYY-mm-DD hh:MM:ss\").format(date); System.out.println(\"[fanout] send msg:\" + dateString); // 注意 第一个参数是我们交换机的名称 ，第二个参数是routerKey 我们不用管空着就可以，第三个是你要发送的消息 this.rabbitTemplate.convertAndSend(\"fanoutExchange\", \"\", dateString); &#125; 同理我们需要在消费者工程新建三个消费者的类 代码分别如下 12345678910111213141516@Component@RabbitListener(queues = \"fanout.a\")public class FanoutAConsumer &#123; @Autowired private AmqpTemplate rabbitmqTemplate; /** * 消息消费 * @RabbitHandler 代表此方法为接受到消息后的处理方法 */ @RabbitHandler public void recieved(String msg) &#123; System.out.println(\"[fanout.a] recieved message:\" + msg); &#125;&#125; 12345678910111213141516@Component@RabbitListener(queues = \"fanout.b\")public class FanoutBConsumer &#123; @Autowired private AmqpTemplate rabbitmqTemplate; /** * 消息消费 * @RabbitHandler 代表此方法为接受到消息后的处理方法 */ @RabbitHandler public void recieved(String msg) &#123; System.out.println(\"[fanout.b] recieved message:\" + msg); &#125;&#125; 12345678910111213141516@Component@RabbitListener(queues = \"fanout.c\")public class FanoutCConsumer &#123; @Autowired private AmqpTemplate rabbitmqTemplate; /** * 消息消费 * @RabbitHandler 代表此方法为接受到消息后的处理方法 */ @RabbitHandler public void recieved(String msg) &#123; System.out.println(\"[fanout.c] recieved message:\" + msg); &#125;&#125; 然后编写一个名为testFanout()的方法启动我们的fanout生产方法， 1234@Test public void testFanoutSend() &#123; producer.fanoutSend(); &#125; 然后重启消费者工程 三个队列的消费都成功接收到消息。 3、topic模式， 同样，配置topic队列跟交换器，注意的是这里需要多配置一个bindingKey 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//#################topic模式######################## @Bean public Queue topiocA() &#123; return new Queue(\"topic.a\"); &#125; @Bean public Queue topicB() &#123; return new Queue(\"topic.b\"); &#125; @Bean public Queue topicC() &#123; return new Queue(\"topic.c\"); &#125; /** * 定义个topic交换器 * @return */ @Bean TopicExchange topicExchange() &#123; // 定义一个名为fanoutExchange的fanout交换器 return new TopicExchange(\"topicExchange\"); &#125; /** * 将定义的topicA队列与topicExchange交换机绑定 * @return */ @Bean public Binding bindingTopicExchangeWithA() &#123; return BindingBuilder.bind(topiocA()).to(topicExchange()).with(\"topic.msg\"); &#125; /** * 将定义的topicB队列与topicExchange交换机绑定 * @return */ @Bean public Binding bindingTopicExchangeWithB() &#123; return BindingBuilder.bind(topicB()).to(topicExchange()).with(\"topic.#\"); &#125; /** * 将定义的topicC队列与topicExchange交换机绑定 * @return */ @Bean public Binding bindingTopicExchangeWithC() &#123; return BindingBuilder.bind(topicC()).to(topicExchange()).with(\"topic.*.z\"); &#125; topicA的key为topic.msg 那么他只会接收包含topic.msg的消息 topicB的key为topic.#那么他只会接收topic开头的消息 topicC的key为topic.*.Z那么他只会接收topic.B.z这样格式的消息 同理在RabbitProducer完成topic生产方法 1234567891011121314151617181920212223242526272829public void topicTopic1Send() &#123; Date date = new Date(); String dateString = new SimpleDateFormat(\"YYYY-mm-DD hh:MM:ss\").format(date); dateString = \"[topic.msg] send msg:\" + dateString; System.out.println(dateString); // 注意 第一个参数是我们交换机的名称 ，第二个参数是routerKey topic.msg，第三个是你要发送的消息 // 这条信息将会被 topic.a topic.b接收 this.rabbitTemplate.convertAndSend(\"topicExchange\", \"topic.msg\", dateString); &#125; public void topicTopic2Send() &#123; Date date = new Date(); String dateString = new SimpleDateFormat(\"YYYY-mm-DD hh:MM:ss\").format(date); dateString = \"[topic.good.msg] send msg:\" + dateString; System.out.println(dateString); // 注意 第一个参数是我们交换机的名称 ，第二个参数是routerKey ，第三个是你要发送的消息 // 这条信息将会被topic.b接收 this.rabbitTemplate.convertAndSend(\"topicExchange\", \"topic.good.msg\", dateString); &#125; public void topicTopic3Send() &#123; Date date = new Date(); String dateString = new SimpleDateFormat(\"YYYY-mm-DD hh:MM:ss\").format(date); dateString = \"[topic.m.z] send msg:\" + dateString; System.out.println(dateString); // 注意 第一个参数是我们交换机的名称 ，第二个参数是routerKey ，第三个是你要发送的消息 // 这条信息将会被topic.b、topic.b接收 this.rabbitTemplate.convertAndSend(\"topicExchange\", \"topic.m.z\", dateString); &#125; 然后在消费者工程新建队列队列的消费类 12345678910111213141516@Component@RabbitListener(queues = \"topic.a\")public class TopicAConsumer &#123; @Autowired private AmqpTemplate rabbitmqTemplate; /** * 消息消费 * @RabbitHandler 代表此方法为接受到消息后的处理方法 */ @RabbitHandler public void recieved(String msg) &#123; System.out.println(\"[topic.a] recieved message:\" + msg); &#125;&#125; 12345678910111213141516@Component@RabbitListener(queues = \"topic.b\")public class TopicBConsumer &#123; @Autowired private AmqpTemplate rabbitmqTemplate; /** * 消息消费 * @RabbitHandler 代表此方法为接受到消息后的处理方法 */ @RabbitHandler public void recieved(String msg) &#123; System.out.println(\"[topic.b] recieved message:\" + msg); &#125;&#125; 12345678910111213141516@Component@RabbitListener(queues = \"topic.c\")public class TopicCConsumer &#123; @Autowired private AmqpTemplate rabbitmqTemplate; /** * 消息消费 * @RabbitHandler 代表此方法为接受到消息后的处理方法 */ @RabbitHandler public void recieved(String msg) &#123; System.out.println(\"[topic.c] recieved message:\" + msg); &#125;&#125; 同理为topic新建测试方法 123456@Test public void testTopic() &#123; producer.topicTopic1Send(); producer.topicTopic2Send(); producer.topicTopic3Send(); &#125; 消息成功发出。 启动消费者工程，看看消息是不是按照规则被发送消息 其中 队列topic.a只配置topic.msg一条消息，正确 其中 队列topic.b匹配三条消息，因为三条消息都是topic开头的 正确 其中 队列topic.c匹配一条消息，只有一条消息满足（也就是topic.m.z这条消息） 最后配套教程的代码全部在这里 github https://github.com/YuKongEr/SpringBoot-Study。麻烦点个star或者fork吧。 欢迎大家关注一下我的个人公众号。一起交流一起学习，有问必答。","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://www.yukonga.cn/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://www.yukonga.cn/tags/SpringBoot/"},{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://www.yukonga.cn/tags/RabbitMQ/"}]},{"title":"【SpringBoot2.0系列08】SpringBoot之redis数据缓存管理","slug":"【SpringBoot2-0系列08】SpringBoot之redis数据缓存管理","date":"2018-08-21T06:00:17.000Z","updated":"2019-05-07T06:15:38.708Z","comments":true,"path":"2018/08/21/【SpringBoot2-0系列08】SpringBoot之redis数据缓存管理/","link":"","permalink":"http://www.yukonga.cn/2018/08/21/【SpringBoot2-0系列08】SpringBoot之redis数据缓存管理/","excerpt":"实现数据缓存，如果缓存中没有数据，则从数据库查询，并且写入redis缓存，如果redis缓存中有数据，则直接从redis中读取，同事删除更新等操作也需要维护缓存。本文基于前面两篇文章而来，部分重复就不贴。","text":"实现数据缓存，如果缓存中没有数据，则从数据库查询，并且写入redis缓存，如果redis缓存中有数据，则直接从redis中读取，同事删除更新等操作也需要维护缓存。本文基于前面两篇文章而来，部分重复就不贴。 实现 1、依赖 1234567891011121314151617181920212223242526272829303132&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- redis依赖commons-pool 这个依赖一定要添加 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2、配置redis跟mybatis yml配置如下: 12345678910111213141516171819202122232425server: port: 8989spring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&amp;characterEncoding=utf8 username: root password: root redis: host: 127.0.0.1 port: 6379 lettuce: pool: max-idle: 8 min-idle: 0 max-active: 8mybatis: config-location: classpath:/mybatis/config/mybatis-config.xml mapper-locations: classpath:/mybatis/mapper/*.xmllogging: level: com: yukong: chapter7: repository: debug 这里就是配置了一下mybati跟redis 但是比之前多了一点就是配置了我们 com.yukong.chapter.repository包的日志级别为debug这样sql就会打印出来。 然后之前一样的配置一下RedisConfig.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485 /** * @author xiongping22369 * @date 2018/8/20 15:33 * @description redis配置 配置序列化方式以及缓存管理器 @EnableCaching 开启缓存 */@EnableCaching@Configuration@AutoConfigureAfter(RedisAutoConfiguration.class)public class RedisConfig &#123; /** * 配置自定义redisTemplate * * @param connectionFactory * @return */ @Bean public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory) &#123; RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;(); template.setConnectionFactory(connectionFactory); template.setValueSerializer(jackson2JsonRedisSerializer()); //使用StringRedisSerializer来序列化和反序列化redis的key值 template.setKeySerializer(new StringRedisSerializer()); template.setHashKeySerializer(new StringRedisSerializer()); template.setHashValueSerializer(jackson2JsonRedisSerializer()); template.afterPropertiesSet(); return template; &#125; /** * json序列化 * @return */ @Bean public RedisSerializer&lt;Object&gt; jackson2JsonRedisSerializer() &#123; //使用Jackson2JsonRedisSerializer来序列化和反序列化redis的value值 Jackson2JsonRedisSerializer serializer = new Jackson2JsonRedisSerializer(Object.class); ObjectMapper mapper = new ObjectMapper(); mapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); serializer.setObjectMapper(mapper); return serializer; &#125; /** * 配置缓存管理器 * @param redisConnectionFactory * @return */ @Bean public CacheManager cacheManager(RedisConnectionFactory redisConnectionFactory) &#123; // 生成一个默认配置，通过config对象即可对缓存进行自定义配置 RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig(); // 设置缓存的默认过期时间，也是使用Duration设置 config = config.entryTtl(Duration.ofMinutes(1)) // 设置 key为string序列化 .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(new StringRedisSerializer())) // 设置value为json序列化 .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer())) // 不缓存空值 .disableCachingNullValues(); // 设置一个初始化的缓存空间set集合 Set&lt;String&gt; cacheNames = new HashSet&lt;&gt;(); cacheNames.add(\"timeGroup\"); cacheNames.add(\"user\"); // 对每个缓存空间应用不同的配置 Map&lt;String, RedisCacheConfiguration&gt; configMap = new HashMap&lt;&gt;(); configMap.put(\"timeGroup\", config); configMap.put(\"user\", config.entryTtl(Duration.ofSeconds(120))); // 使用自定义的缓存配置初始化一个cacheManager RedisCacheManager cacheManager = RedisCacheManager.builder(redisConnectionFactory) // 一定要先调用该方法设置初始化的缓存名，再初始化相关的配置 .initialCacheNames(cacheNames) .withInitialCacheConfigurations(configMap) .build(); return cacheManager; &#125;&#125; 相比上节，我们多配置了一个缓存管理器，在springboot2中配置缓存管理是新的api也就是builder模式构建。然后通过@EnableCaching 开启缓存注解。然后需要注意的是 你在redistemplate中的配置的key，value序列化方法并不会生效，需要在RedisCacheConfiguration中单独配置。 3、使用caching注解 一般缓存在service层中使用。 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * @author yukong * @date 2018/8/20 14:35 * @description user业务层实现 */@Servicepublic class UserServiceImpl implements UserService &#123; @Autowired private UserMapper userMapper; @Override public User saveUser(User user) &#123; userMapper.save(user); // 返回用户信息，带id return user; &#125; /** * @CacheEvict 应用到删除数据的方法上，调用方法时会从缓存中删除对应key的数据 * condition 与unless相反，只有表达式为真才会执行。 * @param id 主键id * @return */ @CacheEvict(value = \"user\", key = \"#root.args[0]\", condition = \"#result eq true\") @Override public Boolean removeUser(Long id) &#123; // 如果删除记录不为1 则是失败 return userMapper.deleteById(id) == 1; &#125; /** * @Cacheable 应用到读取数据的方法上，先从缓存中读取，如果没有再从DB获取数据，然后把数据添加到缓存中 * key 缓存在redis中的key * unless 表示条件表达式成立的话不放入缓存 * @param id 主键id * @return */ @Cacheable(value = \"user\", key = \"#root.args[0]\", unless = \"#result eq null \") @Override public User getById(Long id) &#123; return userMapper.selectById(id); &#125; /** * @CachePut 应用到写数据的方法上，如新增/修改方法，调用方法时会自动把相应的数据放入缓存 * @param user 用户信息 * @return */ @CachePut(value = \"user\", key = \"#root.args[0]\", unless = \"#user eq null \") @Override public User updateUser(User user) &#123; userMapper.update(user); return user; &#125;&#125; 其中每个注解的作用都写在注释中了。 4、测试 然后我们编写一下对应的rest接口来测试 123456789101112131415161718192021222324252627282930313233/** * @author yukong * @date 2018/8/20 15:27 * @description user控制器 */@RequestMapping(\"/user\")@RestControllerpublic class UserController &#123; @Autowired private UserService userService; @PostMapping public User save(@RequestBody User user) &#123; return userService.saveUser(user); &#125; @PutMapping public User update(@RequestBody User user) &#123; return userService.updateUser(user); &#125; @DeleteMapping(value = \"/id/&#123;id&#125;\") public Boolean delete(@PathVariable Long id) &#123; return userService.removeUser(id); &#125; @GetMapping(value = \"/id/&#123;id&#125;\") public User findById (@PathVariable Long id) &#123; return userService.getById(id); &#125;&#125; 启动程序。首先访问http://localhost:8989/user/id/2 成功请求数据 并且控制台打印sql 查看redis是否成功缓存数据。 成功缓存数据，并且key为主键id。 再次刷新访问。 并没有打印sql，说明缓存生效，数据是从缓存中去的，而没有去访问数据库。 至于修改跟删除两个注解就交给大家测试。 关于本文，其中mybatis相关的代码并没有贴出，全部代码放在github上，地址如下。 最后配套教程的代码全部在这里 github https://github.com/YuKongEr/SpringBoot-Study。麻烦点个star或者fork吧。 欢迎大家关注一下我的个人公众号。一起交流一起学习，有问必答。","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://www.yukonga.cn/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://www.yukonga.cn/tags/SpringBoot/"},{"name":"Redis","slug":"Redis","permalink":"http://www.yukonga.cn/tags/Redis/"},{"name":"SpringCache","slug":"SpringCache","permalink":"http://www.yukonga.cn/tags/SpringCache/"}]},{"title":"【SpringBoot2.0系列07】SpringBoot之redis使用（Lettuce版本）","slug":"【SpringBoot2-0系列07】SpringBoot之redis使用（Lettuce版本）","date":"2018-08-20T06:00:04.000Z","updated":"2019-05-07T06:16:17.426Z","comments":true,"path":"2018/08/20/【SpringBoot2-0系列07】SpringBoot之redis使用（Lettuce版本）/","link":"","permalink":"http://www.yukonga.cn/2018/08/20/【SpringBoot2-0系列07】SpringBoot之redis使用（Lettuce版本）/","excerpt":"前面三节我们讲解了springboot与关系型数据库交互，现在我们需要了解一下springboot,今天我们就需要学习了与nosql数据库交互，今天我们主要讲一下springboot如果操作redis。 目前java操作redis的客户端有jedis跟Lettuce。在springboot1.x系列中，其中使用的是jedis,但是到了springboot2.x其中使用的是Lettuce。 因为我们的版本是springboot2.x系列，所以今天使用的是Lettuce。 关于jedis跟lettuce的区别： Lettuce 和 Jedis 的定位都是Redis的client，所以他们当然可以直接连接redis server。 Jedis在实现上是直接连接的redis server，如果在多线程环境下是非线程安全的，这个时候只有使用连接池，为每个Jedis实例增加物理连接 Lettuce的连接是基于Netty的，连接实例（StatefulRedisConnection）可以在多个线程间并发访问，应为StatefulRedisConnection是线程安全的，所以一个连接实例（StatefulRedisConnection）就可以满足多线程环境下的并发访问，当然这个也是可伸缩的设计，一个连接实例不够的情况也可以按需增加连接实例。","text":"前面三节我们讲解了springboot与关系型数据库交互，现在我们需要了解一下springboot,今天我们就需要学习了与nosql数据库交互，今天我们主要讲一下springboot如果操作redis。 目前java操作redis的客户端有jedis跟Lettuce。在springboot1.x系列中，其中使用的是jedis,但是到了springboot2.x其中使用的是Lettuce。 因为我们的版本是springboot2.x系列，所以今天使用的是Lettuce。 关于jedis跟lettuce的区别： Lettuce 和 Jedis 的定位都是Redis的client，所以他们当然可以直接连接redis server。 Jedis在实现上是直接连接的redis server，如果在多线程环境下是非线程安全的，这个时候只有使用连接池，为每个Jedis实例增加物理连接 Lettuce的连接是基于Netty的，连接实例（StatefulRedisConnection）可以在多个线程间并发访问，应为StatefulRedisConnection是线程安全的，所以一个连接实例（StatefulRedisConnection）就可以满足多线程环境下的并发访问，当然这个也是可伸缩的设计，一个连接实例不够的情况也可以按需增加连接实例。 实现 1、依赖 新建一个springboot工程，添加如下依赖。 123456789101112131415161718192021222324&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- redis依赖commons-pool 这个依赖一定要添加 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 然后在application.yml配置一下redis服务器的地址 1234567891011121314151617server: port: 8989spring: redis: host: 127.0.0.1 port: 6379 # 密码 没有则可以不填 password: 123456 # 如果使用的jedis 则将lettuce改成jedis即可 lettuce: pool: # 最大活跃链接数 默认8 max-active: 8 # 最大空闲连接数 默认8 max-idle: 8 # 最小空闲连接数 默认0 min-idle: 0 2、 redis配置 接下来我们需要配置redis的key跟value的序列化方式，默认使用的JdkSerializationRedisSerializer 这样的会导致我们通过redis desktop manager显示的我们key跟value的时候显示不是正常字符。 所以我们需要手动配置一下序列化方式 新建一个config包，在其下新建一个RedisConfig.java 具体代码如下 12345678910111213141516171819202122232425262728293031323334353637/** * @Auther: yukong * @Date: 2018/8/17 14:58 * @Description: redis配置 */@Configuration@AutoConfigureAfter(RedisAutoConfiguration.class)public class RedisConfig &#123; /** * 配置自定义redisTemplate * @return */ @Bean RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) &#123; RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;(); template.setConnectionFactory(redisConnectionFactory); //使用Jackson2JsonRedisSerializer来序列化和反序列化redis的value值 Jackson2JsonRedisSerializer serializer = new Jackson2JsonRedisSerializer(Object.class); ObjectMapper mapper = new ObjectMapper(); mapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); serializer.setObjectMapper(mapper); template.setValueSerializer(serializer); //使用StringRedisSerializer来序列化和反序列化redis的key值 template.setKeySerializer(new StringRedisSerializer()); template.setHashKeySerializer(new StringRedisSerializer()); template.setHashValueSerializer(serializer); template.afterPropertiesSet(); return template; &#125;&#125; 其中@Configuration 代表这个类是一个配置类，然后@AutoConfigureAfter(RedisAutoConfiguration.class) 是让我们这个配置类在内置的配置类之后在配置，这样就保证我们的配置类生效，并且不会被覆盖配置。其中需要注意的就是方法名一定要叫redisTemplate 因为@Bean注解是根据方法名配置这个bean的name的。 3、测试 我们需要测试在redis缓存对象的用例，所以我们需要新建一个实体类。 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public class User implements Serializable &#123; private static final long serialVersionUID = 1222221L; private Long id; /** * 用户名 */ private String username; /** * 密码 */ private String password; /** * 年龄 */ private Integer age; /** * 性别 1=男 2=女 其他=保密 */ private Integer sex; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public Integer getSex() &#123; return sex; &#125; public void setSex(Integer sex) &#123; this.sex = sex; &#125; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125; @Override public String toString() &#123; return \"User&#123;\" + \"id=\" + id + \", username='\" + username + '\\'' + \", password='\" + password + '\\'' + \", age=\" + age + \", sex=\" + sex + '&#125;'; &#125;&#125;我们在`Chapter6Application.java`测试一下 代码如下 12345678910111213141516171819202122232425262728@RunWith(SpringRunner.class)@SpringBootTestpublic class Chapter6ApplicationTests &#123; @Autowired private RedisTemplate redisTemplate; @Test public void redisTest() &#123; // redis存储数据 String key = \"name\"; redisTemplate.opsForValue().set(key, \"yukong\"); // 获取数据 String value = (String) redisTemplate.opsForValue().get(key); System.out.println(\"获取缓存中key为\" + key + \"的值为：\" + value); User user = new User(); user.setUsername(\"yukong\"); user.setSex(18); user.setId(1L); String userKey = \"yukong\"; redisTemplate.opsForValue().set(userKey, user); User newUser = (User) redisTemplate.opsForValue().get(userKey); System.out.println(\"获取缓存中key为\" + userKey + \"的值为：\" + newUser); &#125;&#125; 首先我们引入springboot的测试环境，然后注入一个RedisTemplate对象，这里我解释一下为什么我前面让大家在配置redis的时候 放回RedisTemplate的方法的方法名一定要叫redisTemplate因为 如果查询结果刚好为一个，就将该bean装配给@Autowired指定的数据 如果查询的结果不止一个，那么@Autowired会根据名称来查找。 如果查询的结果为空，那么会抛出异常。解决方法时，使用required=false 如果我们没有把哪个bean命名为redisTemplate 而这里又这么注入，会导致我们使用的springboot内置的tempalte而不是我们配置的，导致我们的配置不生效，从而埋坑，所以最好的方法就是把方法命名为redisTemplate从而覆盖系统内置的。 接下来我们运行测试类。结果如下。 同时查看redis中缓存的结果。 中文成功显示，并且对象在redis以json方式存储，代表我们配置成功。 下列的就是Redis其它类型所对应的操作方式 opsForValue： 对应 String（字符串） opsForZSet： 对应 ZSet（有序集合） opsForHash： 对应 Hash（哈希） opsForList： 对应 List（列表） opsForSet： 对应 Set（集合） 最后配套教程的代码全部在这里 github https://github.com/YuKongEr/SpringBoot-Study。麻烦点个star或者fork吧。 欢迎大家关注一下我的个人公众号。一起交流一起学习，有问必答。","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://www.yukonga.cn/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://www.yukonga.cn/tags/SpringBoot/"},{"name":"Redis","slug":"Redis","permalink":"http://www.yukonga.cn/tags/Redis/"},{"name":"Lettuce","slug":"Lettuce","permalink":"http://www.yukonga.cn/tags/Lettuce/"}]},{"title":"【SpringBoot2.0系列06】SpringBoot之多数据源动态切换数据源","slug":"【SpringBoot2-0系列06】SpringBoot之多数据源动态切换数据源","date":"2018-08-19T05:59:55.000Z","updated":"2019-05-07T06:19:11.069Z","comments":true,"path":"2018/08/19/【SpringBoot2-0系列06】SpringBoot之多数据源动态切换数据源/","link":"","permalink":"http://www.yukonga.cn/2018/08/19/【SpringBoot2-0系列06】SpringBoot之多数据源动态切换数据源/","excerpt":"在前面两节我们已经完成springboot操作mysql数据库，但是在实际业务场景中，数据量迅速增长，一个库一个表已经满足不了我们的需求的时候，我们就会考虑分库分表的操作，那么接下来我们就去学习一下，在springboot中如何实现多数据源，动态数据源切换，读写分离等操作。","text":"在前面两节我们已经完成springboot操作mysql数据库，但是在实际业务场景中，数据量迅速增长，一个库一个表已经满足不了我们的需求的时候，我们就会考虑分库分表的操作，那么接下来我们就去学习一下，在springboot中如何实现多数据源，动态数据源切换，读写分离等操作。 实现 1、建库建表 首先，我们在本地新建三个数据库名分别为master,slave1,slave2，我们的目前就是写入操作都是在master，查询是 slave1,slave2 因此我们在上一篇也就是【SpringBoot2.0系列05】SpringBoot之整合Mybatis基础上进行改动， 我们在master slave1 slave2中都创建user表 其中初始化salve1库的user表数据为 slave2库的user表 具体的数据库脚本如下 123456789101112131415161718192021222324252627282930313233343536373839create table master.user( id bigint auto_increment comment '主键' primary key, age int null comment '年龄', password varchar(32) null comment '密码', sex int null comment '性别', username varchar(32) null comment '用户名')engine=MyISAM collate=utf8mb4_bin;create table slave1.user( id bigint auto_increment comment '主键' primary key, age int null comment '年龄', password varchar(32) null comment '密码', sex int null comment '性别', username varchar(32) null comment '用户名')engine=MyISAM collate=utf8mb4_bin;INSERT INTO slave1.user (id, age, password, sex, username) VALUES (2, 22, 'admin', 1, 'admin');create table slave2.user( id bigint auto_increment comment '主键' primary key, age int null comment '年龄', password varchar(32) null comment '密码', sex int null comment '性别', username varchar(32) null comment '用户名')engine=MyISAM collate=utf8mb4_bin;INSERT INTO slave2.user (id, age, password, sex, username) VALUES (3, 19, 'uuu', 2, 'user');INSERT INTO slave2.user (id, age, password, sex, username) VALUES (4, 18, 'bbbb', 1, 'zzzz'); 2、配置多数据源 经过上面初始化 我们的master.user是一张空表，我们等下的插入与更新操作就在这上面，那么我们的查询操作就是在slave1.user跟slave2.user上面了。 上面我们的数据库初始化工作完成了，接下来就是实现动态数据源的过程 首先我们需要在我们的application.yml配置我们的三个数据源 1234567891011121314151617181920212223242526server: port: 8989spring: datasource: master: password: root url: jdbc:mysql://127.0.0.1:3306/master?useUnicode=true&amp;characterEncoding=UTF-8 driver-class-name: com.mysql.jdbc.Driver username: root type: com.zaxxer.hikari.HikariDataSource cluster: - key: slave1 password: root url: jdbc:mysql://127.0.0.1:3306/slave1?useUnicode=true&amp;characterEncoding=UTF-8 idle-timeout: 20000 driver-class-name: com.mysql.jdbc.Driver username: root type: com.zaxxer.hikari.HikariDataSource - key: slave2 password: root url: jdbc:mysql://127.0.0.1:3306/slave2?useUnicode=true&amp;characterEncoding=UTF-8 driver-class-name: com.mysql.jdbc.Driver username: rootmybatis: mapper-locations: classpath:/mybatis/mapper/*.xml config-location: classpath:/mybatis/config/mybatis-config.xml 在上面我们配置了三个数据，其中第一个作为默认数据源也就是我们的master数据源。主要是写操作，那么读操作交给我们的slave1跟slave2 其中 master 数据源是一定要配置 作为我们的默认数据源，其次cluster集群中，其他的数据不配置也不会影响程序的运行（相当于单数据源），如果你想添加新的一个数据源 就在cluster下新增一个数据源即可，其中key为必须项，用于数据源的唯一标识，以及接下来切换数据源的标识。 3、注册数据源 在上面我们已经配置了三个数据源，但是这是我们自定义的配置，springboot是无法给我们自动配置，所以需要我们自己注册数据源. 那么就要实现 EnvironmentAware用于读取上下文环境变量用于构建数据源，同时也需要实现 ImportBeanDefinitionRegistrar接口注册我们构建的数据源。com.yukong.chapter5.register.DynamicDataSourceRegister具体代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154/** * 动态数据源注册 * 实现 ImportBeanDefinitionRegistrar 实现数据源注册 * 实现 EnvironmentAware 用于读取application.yml配置 */public class DynamicDataSourceRegister implements ImportBeanDefinitionRegistrar, EnvironmentAware &#123; private static final Logger logger = LoggerFactory.getLogger(DynamicDataSourceRegister.class); /** * 配置上下文（也可以理解为配置文件的获取工具） */ private Environment evn; /** * 别名 */ private final static ConfigurationPropertyNameAliases aliases = new ConfigurationPropertyNameAliases(); /** * 由于部分数据源配置不同，所以在此处添加别名，避免切换数据源出现某些参数无法注入的情况 */ static &#123; aliases.addAliases(\"url\", new String[]&#123;\"jdbc-url\"&#125;); aliases.addAliases(\"username\", new String[]&#123;\"user\"&#125;); &#125; /** * 存储我们注册的数据源 */ private Map&lt;String, DataSource&gt; customDataSources = new HashMap&lt;String, DataSource&gt;(); /** * 参数绑定工具 springboot2.0新推出 */ private Binder binder; /** * ImportBeanDefinitionRegistrar接口的实现方法，通过该方法可以按照自己的方式注册bean * * @param annotationMetadata * @param beanDefinitionRegistry */ @Override public void registerBeanDefinitions(AnnotationMetadata annotationMetadata, BeanDefinitionRegistry beanDefinitionRegistry) &#123; // 获取所有数据源配置 Map config, defauleDataSourceProperties; defauleDataSourceProperties = binder.bind(\"spring.datasource.master\", Map.class).get(); // 获取数据源类型 String typeStr = evn.getProperty(\"spring.datasource.master.type\"); // 获取数据源类型 Class&lt;? extends DataSource&gt; clazz = getDataSourceType(typeStr); // 绑定默认数据源参数 也就是主数据源 DataSource consumerDatasource, defaultDatasource = bind(clazz, defauleDataSourceProperties); DynamicDataSourceContextHolder.dataSourceIds.add(\"master\"); logger.info(\"注册默认数据源成功\"); // 获取其他数据源配置 List&lt;Map&gt; configs = binder.bind(\"spring.datasource.cluster\", Bindable.listOf(Map.class)).get(); // 遍历从数据源 for (int i = 0; i &lt; configs.size(); i++) &#123; config = configs.get(i); clazz = getDataSourceType((String) config.get(\"type\")); defauleDataSourceProperties = config; // 绑定参数 consumerDatasource = bind(clazz, defauleDataSourceProperties); // 获取数据源的key，以便通过该key可以定位到数据源 String key = config.get(\"key\").toString(); customDataSources.put(key, consumerDatasource); // 数据源上下文，用于管理数据源与记录已经注册的数据源key DynamicDataSourceContextHolder.dataSourceIds.add(key); logger.info(\"注册数据源&#123;&#125;成功\", key); &#125; // bean定义类 GenericBeanDefinition define = new GenericBeanDefinition(); // 设置bean的类型，此处DynamicRoutingDataSource是继承AbstractRoutingDataSource的实现类 define.setBeanClass(DynamicRoutingDataSource.class); // 需要注入的参数 MutablePropertyValues mpv = define.getPropertyValues(); // 添加默认数据源，避免key不存在的情况没有数据源可用 mpv.add(\"defaultTargetDataSource\", defaultDatasource); // 添加其他数据源 mpv.add(\"targetDataSources\", customDataSources); // 将该bean注册为datasource，不使用springboot自动生成的datasource beanDefinitionRegistry.registerBeanDefinition(\"datasource\", define); logger.info(\"注册数据源成功，一共注册&#123;&#125;个数据源\", customDataSources.keySet().size() + 1); &#125; /** * 通过字符串获取数据源class对象 * * @param typeStr * @return */ private Class&lt;? extends DataSource&gt; getDataSourceType(String typeStr) &#123; Class&lt;? extends DataSource&gt; type; try &#123; if (StringUtils.hasLength(typeStr)) &#123; // 字符串不为空则通过反射获取class对象 type = (Class&lt;? extends DataSource&gt;) Class.forName(typeStr); &#125; else &#123; // 默认为hikariCP数据源，与springboot默认数据源保持一致 type = HikariDataSource.class; &#125; return type; &#125; catch (Exception e) &#123; throw new IllegalArgumentException(\"can not resolve class with type: \" + typeStr); //无法通过反射获取class对象的情况则抛出异常，该情况一般是写错了，所以此次抛出一个runtimeexception &#125; &#125; /** * 绑定参数，以下三个方法都是参考DataSourceBuilder的bind方法实现的，目的是尽量保证我们自己添加的数据源构造过程与springboot保持一致 * * @param result * @param properties */ private void bind(DataSource result, Map properties) &#123; ConfigurationPropertySource source = new MapConfigurationPropertySource(properties); Binder binder = new Binder(new ConfigurationPropertySource[]&#123;source.withAliases(aliases)&#125;); // 将参数绑定到对象 binder.bind(ConfigurationPropertyName.EMPTY, Bindable.ofInstance(result)); &#125; private &lt;T extends DataSource&gt; T bind(Class&lt;T&gt; clazz, Map properties) &#123; ConfigurationPropertySource source = new MapConfigurationPropertySource(properties); Binder binder = new Binder(new ConfigurationPropertySource[]&#123;source.withAliases(aliases)&#125;); // 通过类型绑定参数并获得实例对象 return binder.bind(ConfigurationPropertyName.EMPTY, Bindable.of(clazz)).get(); &#125; /** * @param clazz * @param sourcePath 参数路径，对应配置文件中的值，如: spring.datasource * @param &lt;T&gt; * @return */ private &lt;T extends DataSource&gt; T bind(Class&lt;T&gt; clazz, String sourcePath) &#123; Map properties = binder.bind(sourcePath, Map.class).get(); return bind(clazz, properties); &#125; /** * EnvironmentAware接口的实现方法，通过aware的方式注入，此处是environment对象 * * @param environment */ @Override public void setEnvironment(Environment environment) &#123; logger.info(\"开始注册数据源\"); this.evn = environment; // 绑定配置器 binder = Binder.get(evn); &#125;&#125; 上面代码需要注意的是在springboot2.x系列中用于绑定的工具类如RelaxedPropertyResolver已经无法现在使用Binder代替。上面代码主要是读取application中数据源的配置，先读取spring.datasource.master构建默认数据源,然后在构建cluster中的数据源。 在这里注册完数据源之后，我们需要通过@import注解把我们的数据源注册器导入到spring中 在启动类Chapter5Application.java加上如下注解@Import(DynamicDataSourceRegister.class)。 其中我们用到了一个DynamicDataSourceContextHolder 中的静态变量来保存我们已经注册成功的数据源的key,至此我们的数据源注册就已经完成了。 4、配置数据源上下文 我们需要新建一个数据源上下文，用户记录当前线程使用的数据源的key是什么，以及记录所有注册成功的数据源的key的集合。对于线程级别的私有变量，我们首先ThreadLocal来实现。 com.yukong.chapter5.config.DynamicDataSourceContextHolder代码取下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * @Auther: yukong * @Date: 2018/8/15 10:49 * @Description: 数据源上下文 */public class DynamicDataSourceContextHolder &#123; private static Logger logger = LoggerFactory.getLogger(DynamicDataSourceContextHolder.class); /** * 存储已经注册的数据源的key */ public static List&lt;String&gt; dataSourceIds = new ArrayList&lt;&gt;(); /** * 线程级别的私有变量 */ private static final ThreadLocal&lt;String&gt; HOLDER = new ThreadLocal&lt;&gt;(); public static String getDataSourceRouterKey () &#123; return HOLDER.get(); &#125; public static void setDataSourceRouterKey (String dataSourceRouterKey) &#123; logger.info(\"切换至&#123;&#125;数据源\", dataSourceRouterKey); HOLDER.set(dataSourceRouterKey); &#125; /** * 设置数据源之前一定要先移除 */ public static void removeDataSourceRouterKey () &#123; HOLDER.remove(); &#125; /** * 判断指定DataSrouce当前是否存在 * * @param dataSourceId * @return */ public static boolean containsDataSource(String dataSourceId)&#123; return dataSourceIds.contains(dataSourceId); &#125;&#125; 5、动态数据源路由 前面我们以及新建了数据源上下文，用于存储我们当前线程的数据源key那么怎么通知spring用key当前的数据源呢，查阅资料可知，spring提供一个接口，名为AbstractRoutingDataSource的抽象类，我们只需要重写determineCurrentLookupKey方法就可以，这个方法看名字就知道，就是返回当前线程的数据源的key，那我们只需要从我们刚刚的数据源上下文中取出我们的key即可，那么具体代码取下。 com.yukong.chapter5.config.DynamicRoutingDataSource 123456789101112131415161718/** * @Auther: yukong * @Date: 2018/8/15 10:47 * @Description: 动态数据源路由配置 */public class DynamicRoutingDataSource extends AbstractRoutingDataSource &#123; private static Logger logger = LoggerFactory.getLogger(DynamicRoutingDataSource.class); @Override protected Object determineCurrentLookupKey() &#123; String dataSourceName = DynamicDataSourceContextHolder.getDataSourceRouterKey(); logger.info(\"当前数据源是：&#123;&#125;\", dataSourceName); return DynamicDataSourceContextHolder.getDataSourceRouterKey(); &#125;&#125; 6、通过aop+注解实现动态数据源的切换 现在spring也已经知道通过key来取对应的数据源，我们现在只需要实现给对应的类或者方法设置他们的数据源的key，并且保存在数据源上下文中即可。这里我们采用注解来设置数据源，通过aop拦截并且保存到数据源上下中。 我们新建一个标识数据源的注解@DataSource具体代码取下 com.yukong.chapter5.annotation.DataSource 123456789/** * 切换数据注解 可以用于类或者方法级别 方法级别优先级 &gt; 类级别 */@Target(&#123;ElementType.METHOD, ElementType.TYPE, ElementType.PARAMETER&#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface DataSource &#123; String value() default \"master\"; //该值即key值&#125; 其中他的默认值是master,因为我们默认数据源的key也是master。也就是说如果你直接用注解，而不指定value的话，那么默认就使用master默认数据源。 然后我们新建一个aop类来拦截。代码如下 com.yukong.chapter5.aop 123456789101112131415161718192021222324252627282930313233343536package com.yukong.chapter5.aop;import com.yukong.chapter5.annotation.DataSource;import com.yukong.chapter5.config.DynamicDataSourceContextHolder;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.annotation.After;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Component;import org.springframework.util.StringUtils;@Aspect@Componentpublic class DynamicDataSourceAspect &#123; private static final Logger logger = LoggerFactory.getLogger(DynamicDataSourceAspect.class); @Before(\"@annotation(ds)\") public void changeDataSource(JoinPoint point, DataSource ds) throws Throwable &#123; String dsId = ds.value(); if (DynamicDataSourceContextHolder.dataSourceIds.contains(dsId)) &#123; logger.debug(\"Use DataSource :&#123;&#125; &gt;\", dsId, point.getSignature()); &#125; else &#123; logger.info(\"数据源[&#123;&#125;]不存在，使用默认数据源 &gt;&#123;&#125;\", dsId, point.getSignature()); DynamicDataSourceContextHolder.setDataSourceRouterKey(dsId); &#125; &#125; @After(\"@annotation(ds)\") public void restoreDataSource(JoinPoint point, DataSource ds) &#123; logger.debug(\"Revert DataSource : \" + ds.value() + \" &gt; \" + point.getSignature()); DynamicDataSourceContextHolder.removeDataSourceRouterKey(); &#125;&#125; 通过aop拦截，获取注解上面的value的值key，然后取判断我们注册的keys集合中是否有这个key,如果没有，则使用默认数据源，如果有，则设置上下文中当前数据源的key为注解的value。 7、测试 最后我们在对应的方法上面加上注解来测试一下即可 我们在UserMapper.java上面加上注解，并且进行测试。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * @Auther: yukong * @Date: 2018/8/13 19:47 * @Description: UserMapper接口 */public interface UserMapper &#123; /** * 新增用户 * @param user * @return */ @DataSource //默认数据源 int save(User user); /** * 更新用户信息 * @param user * @return */ @DataSource //默认数据源 int update(User user); /** * 根据id删除 * @param id * @return */ @DataSource //默认数据源 int deleteById(Long id); /** * 根据id查询 * @param id * @return */ @DataSource(\"slave1\") //slave1 User selectById(Long id); /** * 查询所有用户信息 * @return */ @DataSource(\"slave2\") //slave2 List&lt;User&gt; selectAll();&#125; 上面代码可以知道，我们的新增，修改，删除方法都是在默认数据master上，我们的id查询是在slave1，我们的查询所有在slave2，我们编写测试类来测试把。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * @Auther: yukong * @Date: 2018/8/14 16:34 * @Description: */@SpringBootTest@RunWith(SpringJUnit4ClassRunner.class)public class UserMapperTest &#123; @Autowired private UserMapper userMapper; @Test public void save() &#123; User user = new User(); user.setUsername(\"master\"); user.setPassword(\"master\"); user.setSex(1); user.setAge(18); Assert.assertEquals(1,userMapper.save(user)); &#125; @Test public void update() &#123; User user = new User(); user.setId(8L); user.setPassword(\"newpassword\"); // 返回插入的记录数 ，期望是1条 如果实际不是一条则抛出异常 Assert.assertEquals(1,userMapper.update(user)); &#125; @Test public void selectById() &#123; User user = userMapper.selectById(2L); System.out.println(\"id:\" + user.getId()); System.out.println(\"name:\" + user.getUsername()); System.out.println(\"password:\" + user.getPassword()); &#125; @Test public void deleteById() &#123; Assert.assertEquals(1,userMapper.deleteById(1L)); &#125; @Test public void selectAll() &#123; List&lt;User&gt; users= userMapper.selectAll(); users.forEach(user -&gt; &#123; System.out.println(\"id:\" + user.getId()); System.out.println(\"name:\" + user.getUsername()); System.out.println(\"password:\" + user.getPassword()); &#125;); &#125;&#125; 首先测试save方法，它将会把数据存到master库的user表， 现在user表是空的，如图 运行save方法。 绿色，测试通过，并且日志提示数据源注册成功，一共三个。并且当前使用的master数据源，我们再去master数据库看看有没有数据。 如上图，插入成功。 新增方法测试完成了。我们在测试一下修改与删除。 修改方法也测试通过，查看数据库。 修改成功，删除方法我就不测试， 我们在测试测试，slave1跟slave2数据源的方法， 首先测试slave1的主键查询方法，先看数据库 slave1有哪些数据。 slave1.user就一条id为2 的数据并且id为2 的数据就slave1才有，我们测试一下能不能查到。 运行通过，数据源为slave1并且数据也正确显示。 最后我们来测试一下slave2的selectAll方法把，同样先看看slave2.user中有什么数据。 从图中，得知slave2.user中有两条数据，id分别为3，4。接下来运行测试方法。 结果如图。 日志提示数据源切换值slave2，并且id为3，4的数据也成功打印。 那么至此我们的多数据源动态数据源就完成了。 主要的思路就是 配置文件中配置多个数据源 启动类注册动态数据源 在需要的方法上使用注解指定数据源 最后配套教程的代码全部在这里 github https://github.com/YuKongEr/SpringBoot-Study。麻烦点个star或者fork吧。 欢迎大家关注一下我的个人公众号。一起交流一起学习，有问必答。","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://www.yukonga.cn/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://www.yukonga.cn/tags/SpringBoot/"},{"name":"DynamicDataSource","slug":"DynamicDataSource","permalink":"http://www.yukonga.cn/tags/DynamicDataSource/"},{"name":"DataSource","slug":"DataSource","permalink":"http://www.yukonga.cn/tags/DataSource/"}]},{"title":"【SpringBoot2.0系列05】SpringBoot之整合Mybatis","slug":"【SpringBoot2-0系列05】SpringBoot之整合Mybatis","date":"2018-08-18T05:59:46.000Z","updated":"2019-05-07T06:19:50.239Z","comments":true,"path":"2018/08/18/【SpringBoot2-0系列05】SpringBoot之整合Mybatis/","link":"","permalink":"http://www.yukonga.cn/2018/08/18/【SpringBoot2-0系列05】SpringBoot之整合Mybatis/","excerpt":"上一篇博客中，我们完成了springboot 使用spring data jpa但是在我们实际工作中，可能大部分的同学还是使用mybatis比较多，所以今天我们在这里实现一下springboot使用mybatis实现对user表的增删改查并且进行单元测试","text":"上一篇博客中，我们完成了springboot 使用spring data jpa但是在我们实际工作中，可能大部分的同学还是使用mybatis比较多，所以今天我们在这里实现一下springboot使用mybatis实现对user表的增删改查并且进行单元测试 实现 1、添加mybaits依赖 12345678910111213141516171819202122&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 并且在yml中配置一下数据源跟mybatis的配置。 1234567891011server: port: 8989mybatis: mapper-locations: classpath:/mybaits/mapper/*.xml config-location: classpath:/mybatis/config/mybatis-config.xmlspring: datasource: username: root password: root url: jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&amp;characterEncoding=utf8 driver-class-name: com.mysql.jdbc.Driver 在上面的配置中 123mybatis: mapper-locations: classpath:/mybaits/mapper/*.xml config-location: classpath:/mybatis/config/mybatis-config.xml mapper-locations 是配置我们mapper.xml文件的位置，我们把它配置在/src/main/resource/mybatis/mapper目录下。 config-locations 是配置mybatis-confg.xml文件的位置。我们把它配置在/src/main/resource/mybatis/config目录下。 接下来我们在resource目录下新建mybatis/mapper目录跟mybatis/config目录，并且在config目录下新建mybatis-config.xml 具体代码如下 123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;settings&gt; &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/&gt; &lt;/settings&gt; &lt;typeAliases&gt; &lt;package name=\"com.yukong.chapter4.entity\"/&gt; &lt;/typeAliases&gt;&lt;/configuration&gt; 主要是配置了一下开启mybatis的驼峰命名转换跟entity的别名。 接下来就是建表写实体类。 1、 建表 如果有读过上一篇【SpringBoot系列04】SpringBoot之使用JPA完成简单的rest api并且实际操作过的同学就不用建表了，可以跳过建表这一步，没有的同学需要新建一个test数据库并且新建user表 12345678create table test.user( id bigint not null AUTO_INCREMENT comment &apos;主键&apos; primary key, age int null comment &apos;年龄&apos;, password varchar(32) null comment &apos;密码&apos;, sex int null comment &apos;性别&apos;, username varchar(32) null comment &apos;用户名&apos;); 新建entity包 并且编写对应的实体类 User.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class User &#123; private Long id; /** * 用户名 */ private String username; /** * 密码 */ private String password; /** * 年龄 */ private Integer age; /** * 性别 1=男 2=女 其他=保密 */ private Integer sex; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public Integer getSex() &#123; return sex; &#125; public void setSex(Integer sex) &#123; this.sex = sex; &#125; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125;&#125; 3、编写mapper接口 接下里我们新建repository包 新建UserMapper.java接口 并且定义增删改查的方法声明 123456789101112131415161718192021222324252627282930313233343536public interface UserMapper &#123; /** * 新增用户 * @param user * @return */ int save (User user); /** * 更新用户信息 * @param user * @return */ int update (User user); /** * 根据id删除 * @param id * @return */ int deleteById (int id); /** * 根据id查询 * @param id * @return */ User selectById (int id); /** * 查询所有用户信息 * @return */ List&lt;User&gt; selectAll ();&#125; 跟我们之前定义的mapper.xml文件的位置，我们在resource/mybatis/mapper目录下 新建与之对应的UserMapper.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.yukong.chapter4.repository.UserMapper\"&gt; &lt;resultMap id=\"SysUserResultMap\" type=\"User\"&gt; &lt;id property=\"id\" column=\"id\" javaType=\"java.lang.Long\" jdbcType=\"BIGINT\"/&gt; &lt;result property=\"username\" column=\"USERNAME\" javaType=\"java.lang.String\" jdbcType=\"VARCHAR\"/&gt; &lt;result property=\"password\" column=\"PASSWORD\" javaType=\"java.lang.String\" jdbcType=\"VARCHAR\"/&gt; &lt;result property=\"sex\" column=\"SEX\" javaType=\"java.lang.Integer\" jdbcType=\"INTEGER\"/&gt; &lt;result property=\"age\" column=\"AGE\" javaType=\"java.lang.Integer\" jdbcType=\"INTEGER\"/&gt; &lt;/resultMap&gt; &lt;delete id=\"deleteById\"&gt; delete from user where id=#&#123;id&#125; &lt;/delete&gt; &lt;select id=\"selectAll\" resultMap=\"SysUserResultMap\"&gt; select * from user &lt;/select&gt; &lt;insert id=\"save\" parameterType=\"User\" &gt; insert into user &lt;trim prefix=\"(\" suffix=\")\" suffixOverrides=\",\" &gt; &lt;if test=\"id != null\" &gt; id, &lt;/if&gt; &lt;if test=\"username != null\" &gt; username, &lt;/if&gt; &lt;if test=\"password != null\" &gt; password, &lt;/if&gt; &lt;if test=\"sex != null\" &gt; sex, &lt;/if&gt; &lt;if test=\"age != null\" &gt; age, &lt;/if&gt; &lt;/trim&gt; &lt;trim prefix=\"values (\" suffix=\")\" suffixOverrides=\",\" &gt; &lt;if test=\"id != null\" &gt; #&#123;id,jdbcType=BIGINT&#125;, &lt;/if&gt; &lt;if test=\"username != null\" &gt; #&#123;username,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test=\"password != null\" &gt; #&#123;password,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test=\"sex != null\" &gt; #&#123;sex,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test=\"age != null\" &gt; #&#123;age,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;/trim&gt; &lt;/insert&gt; &lt;update id=\"update\" parameterType=\"User\" &gt; update user &lt;set &gt; &lt;if test=\"username != null\" &gt; username = #&#123;username,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test=\"password != null\" &gt; password = #&#123;password,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test=\"sex != null\" &gt; sex = #&#123;sex,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test=\"age != null\" &gt; sex = #&#123;age,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;/set&gt; where id = #&#123;id,jdbcType=BIGINT&#125; &lt;/update&gt; &lt;select id=\"selectById\" resultMap=\"SysUserResultMap\"&gt; select * from user where id = #&#123;id,jdbcType=BIGINT&#125; &lt;/select&gt;&lt;/mapper&gt; 这时候mybatis的配置还不算成功，我们需要把mapper的路径暴露给spring 让它来扫描管理，所以我们需要在Chapter4Application.java文件上加上注解@MapperScan(&quot;com.yukong.chapter4.repository&quot;) 扫描mapper的所在位置 至此。我们mybaits的接口算是编写完毕，接下来我们来测试一下把。 4、测试 这次我们用spring boot的单元测试来测试我们的接口。 在idea中 使用快捷键新建测试类ctrl+shift+t 勾选需要测试的方法，并且点击ok 这时候会在src/test/java目录下对应的包路径新建对应的测试文件 代码如下 12345678910111213141516171819202122232425262728293031323334353637@SpringBootTest@RunWith(SpringJUnit4ClassRunner.class)public class UserMapperTest &#123; @Autowired private UserMapper userMapper; @Test public void save() &#123; User user = new User(); user.setUsername(\"zzzz\"); user.setPassword(\"bbbb\"); user.setSex(1); user.setAge(18); // 返回插入的记录数 ，期望是1条 如果实际不是一条则抛出异常 Assert.assertEquals(1,userMapper.save(user)); &#125; @Test public void update() &#123; User user = new User(); user.setId(1L); user.setPassword(\"newpassword\"); // 返回更新的记录数 ，期望是1条 如果实际不是一条则抛出异常 Assert.assertEquals(1,userMapper.update(user)); &#125; @Test public void selectById() &#123; Assert.assertNotNull(userMapper.selectById(1L)); &#125; @Test public void deleteById() &#123; Assert.assertEquals(1,userMapper.deleteById(1L)); &#125;&#125; 使用spring boot测试需要在测试类上解释注解 @SpringBootTest @RunWith(SpringJUnit4ClassRunner.class) 另外我们这里使用Assert断言来判断实际结果跟预期结果是否一致，如果不一致则抛出异常。 右键类旁边的运行按钮，一次测试所有的方法 结果如下 所有的方法通过测试，springboot于mybatis整合成功。 最后配套教程的代码全部在这里 github https://github.com/YuKongEr/SpringBoot-Study。麻烦点个star或者fork吧。 欢迎大家关注一下我的个人公众号。一起交流一起学习，有问必答。","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://www.yukonga.cn/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://www.yukonga.cn/tags/SpringBoot/"},{"name":"Mybatis","slug":"Mybatis","permalink":"http://www.yukonga.cn/tags/Mybatis/"}]},{"title":"【SpringBoot2.0系列04】SpringBoot之使用JPA完成简单的restapi","slug":"【SpringBoot2-0系列04】SpringBoot之使用JPA完成简单的restapi","date":"2018-08-17T03:59:28.000Z","updated":"2019-05-07T06:22:33.916Z","comments":true,"path":"2018/08/17/【SpringBoot2-0系列04】SpringBoot之使用JPA完成简单的restapi/","link":"","permalink":"http://www.yukonga.cn/2018/08/17/【SpringBoot2-0系列04】SpringBoot之使用JPA完成简单的restapi/","excerpt":"在前面我们已经知道在springboot中如何使用freemark与thymeleaf之类的视图模板引擎去渲染我们的视图页面，但是没涉及跟数据库交互的东西，所以今天在这里我们将介绍了一下如何在springboot中通过spring data jpa操作mysql数据库，并且构建一套简单的rest api接口。","text":"在前面我们已经知道在springboot中如何使用freemark与thymeleaf之类的视图模板引擎去渲染我们的视图页面，但是没涉及跟数据库交互的东西，所以今天在这里我们将介绍了一下如何在springboot中通过spring data jpa操作mysql数据库，并且构建一套简单的rest api接口。 一、前言 1.1、Spring Data Jpa 介绍 Spring Data JPA是Spring基于Hibernate开发的一个JPA框架。如果用过Hibernate或者MyBatis的话，就会知道对象关系映射（ORM）框架有多么方便。但是Spring Data JPA框架功能更进一步，为我们做了 一个数据持久层框架几乎能做的任何事情。并且提供了基础的增删改查方法，具体api请看官网。 2.2 REST是所有Web应用都应该遵守的架构设计指导原则。 Representational State Transfer，翻译是”表现层状态转化”。 面向资源是REST最明显的特征，对于同一个资源的一组不同的操作。资源是服务器上一个可命名的抽象概念，资源是以名词为核心来组织的，首先关注的是名词。REST要求，必须通过统一的接口来对资源执行各种操作。对于每个资源只能执行一组有限的操作。（7个HTTP方法：GET/POST/PUT/DELETE/PATCH/HEAD/OPTIONS） 关于rest api如何涉及我也是从阮一峰老师那里学习的。 二、目标 首先我们有一个user表，我们希望能通过构建出对应的rest api对表中的数据完成增删改查操作。 jpa的依赖如下 1234567891011121314151617181920 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 接下来那么第一步就是创表了 1、创表 由于我们使用的spring data jpa 而jpa的底层实现是hibernate，用过hibernate的同学知道 hibernate可以通过实体类逆向创建表，只需要配置一下ddl-auto 就可以 所以我们需要在application.yml配置一下 123456789101112server: port: 8989spring: datasource: username: root password: root url: jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&amp;characterEncoding=utf8 driver-class-name: com.mysql.jdbc.Driver jpa: hibernate: ddl-auto: update show-sql: true 在上面的配置文件中 我们配置了一个数据源跟tomcat端口还有jpa的配置。其中 show-sql: true 代表会在日志中打印我们操作的sql、 而另外 ddl-auto有四个值可选，分别是 create 启动时删数据库中的表，然后创建，退出时不删除数据表 create-drop 启动时删数据库中的表，然后创建，退出时删除数据表 如果表不存在报错 update 最常用的属性，第一次加载hibernate时根据model类会自动建立起表的结构（前提是先建立好数据库），以后加载hibernate时根据 model类自动更新表结构，即使表结构改变了但表中的行仍然存在不会删除以前的行。要注意的是当部署到服务器后，表结构是不会被马上建立起来的，是要等 应用第一次运行起来后才会。 validate 项目启动表结构进行校验 如果不一致则报错 所以这里我们希望当表创建成功后 下次启动数据还在我们就选择了update模式，其次我们需要在本地的mysql数据库新建一个test数据库。 接下来我们需要编写的我们实体类User.java了 hibernate将会通过实体类的结构在test数据库中创建一个对应的user表 新建包entity 创建User.java代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273@JsonIgnoreProperties(value=&#123;\"hibernateLazyInitializer\",\"handler\",\"fieldHandler\"&#125;) @Entitypublic class User &#123; @Id @GeneratedValue private Long id; /** * 用户名 */ @Column(name = \"username\", nullable = true, length = 32) private String username; /** * 密码 */ @Column(name = \"password\", nullable = true, length = 32) private String password; /** * 年龄 */ @Column(name = \"age\", nullable = true, length = 11) private Integer age; /** * 性别 1=男 2=女 其他=保密 */ @Column(name = \"sex\", nullable = true, length = 11) private Integer sex; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public Integer getSex() &#123; return sex; &#125; public void setSex(Integer sex) &#123; this.sex = sex; &#125; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125;&#125; 至此，我们的user表也算是创建好了，当我们的程序第一个启动的时候jpa会自动在test数据库中创建与之对应的表。 2、构建rest api 这里我们需要构建如下的rest api url method 介绍 /user/ get 获取所有的用户信息 /user/id/{id} get 根据id获取用户信息 /user/username/{username} get 根据username获取用户信息 /user post 新增用户信息 /user put 更新用户信息 /user/id/{id} delete 根据id删除用户信息 那么这就是我们需要构建的rest api，那么对应的由mvc模式可知我们的rest api是controller层的，所以我们的service跟repository层(备注在使用 jpa的时候我们喜欢把dao层命名为repository)需要提供对应的接口。 首先我们首先需要编写UserRepository接口，并且让它基础JpaRepository接口 新建包repository 创建UserRepository.java代码如下： 12345678910public interface UserRepository extends JpaRepository&lt;User, Long&gt; &#123; /** * 根据用户名查找用户信息 * @param username * @return */ User findUserByUsername(String username);&#125; 解释一下上面的代码，为什么只有一个方法，而前面我们是五个接口，因为是在JpaRepository中提供较为基础的增删改查方法，我们无需编写就看使用。如果大家不信按住ctrl点击JpaRepository看源码就知道了。 从上面就可以看出JpaRespository提供了哪些基础方法了。怎么样 是不是觉得很方便。那么接下来的第二点就Jpa可以根据你的命名规则来推断你这个方法作用，简单的来说findUserByUsername 根据这个方法名，jpa可以知道这个方法是通过用户名去查找用户。 具体的规则大家可以看文档 如果大家用的idea的话，那么它会用智能提示功能，如图 所以我们只需要编写方法名就可以轻轻松松的实现我们的查询方法，怎么样jpa是不是特别简单，但是需要注意的是方法名一定要命名规范，不要嫌太长了。 接下来就是编写我们的service层了， 新建service包创建UserService.java代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041public interface UserService &#123; /** * 添加用户信息 * @param user * @return */ User saveUser(User user); /** * 更新用户信息 * @param user */ User updateUser(User user); /** * 根据id获取用户 * @param id * @return */ User getById(Long id); /** * 根据名称获取用户 * @param username * @return */ User getByUserName(String username); /** * 查询所有用户 * @return */ List&lt;User&gt; queryAll(); /** * 根据id删除用户信息 * @param id */ void deleteById(Long id);&#125; 接下里就下service的实现类，带service包下新建impl包并且创建实现类UserServiceImpl.java 代码如下 123456789101112131415161718192021222324252627282930313233343536@Servicepublic class UserServiceImpl implements UserService &#123; @Autowired private UserRepository userRepository; @Override public User saveUser(User user) &#123; return userRepository.save(user); &#125; @Override public User updateUser(User user) &#123; return userRepository.save(user); &#125; @Override public User getById(Long id) &#123; return userRepository.getOne(id); &#125; @Override public User getByUserName(String username) &#123; return userRepository.findUserByUsername(username); &#125; @Override public List&lt;User&gt; queryAll() &#123; return userRepository.findAll(); &#125; @Override public void deleteById(Long id) &#123; userRepository.deleteById(id); &#125;&#125; 那么紧接着就是控制层的代码了,新建controller包，并且创建UserController.java 1234567891011121314151617181920212223242526272829303132333435363738@RestController@RequestMapping(value = \"/user\")public class UserController &#123; @Autowired private UserService userService; @PostMapping public User save(@RequestBody User user) &#123; return userService.saveUser(user); &#125; @PutMapping public User update(@RequestBody User user) &#123; return userService.saveUser(user); &#125; @DeleteMapping(value = \"/id/&#123;id&#125;\") public String delete(@PathVariable Long id) &#123; userService.deleteById(id); return \"删除成功\"; &#125; @GetMapping(value = \"/id/&#123;id&#125;\") public User findById (@PathVariable Long id) &#123; return userService.getById(id); &#125; @GetMapping(value = \"/username/&#123;username&#125;\") public User findByUsername (@PathVariable String username) &#123; return userService.getByUserName(username); &#125; @GetMapping(value = \"/\") public List&lt;User&gt; findAll () &#123; return userService.queryAll(); &#125;&#125; 这样我们就完成了一个简单的rest api了啊。 接下来我们来测试一下把。 3、测试 由于我们这里测试的是rest api普通的浏览器是没法支持 post delet put方式的访问的，所以这里我们就用postman来测试。 1、首先我们看到test数据库中现在是一张表都没有的 启动程序，注意观察日志。 我们看到了日志打印了创建表的ddl那么我们再看看数据库中有没有表 此时我们看到了有两张表，一张是我们user表，而另一张就是主键生成序列表。 接下来就开始我们的rest api测试了。 首先测试新增用户 打开postman 选择post模式，输入访问的url，然后选择body中的raw，因为我们使用的@RequestBody注解，所以我们选择raw中的Json，如图 因为我们的id是自增的，所以我们不要输入，直接点击send访问，如果返回的数据有id那么就是代表新增成功。如下图就是新增成功。 打开数据库中的user表，看看数据有没有保存成功。 由图可知，保存成功。 接下来我们就多添加几条数据。 那么我们测试一下查询所有数据的方法。操作如图 我们刚刚一共添加三条数据，全部都查询出来了。 我们继续测试一下修改方法把。我们把id为2的数据密码修改为跟用户名一样，具体操作如图， 点击send操作成功，我们用根据id查询的方法来查询一下刚刚id为2的数据有没有修改成功，那么我们查询一下id为2的数据，操作如图。 由图中可以看到我们的修改是成功的，用户名跟密码已经一样的，那么代表我们的根据id查询方法也是没问题的。那么另外几个方法我们不测试了，留给大家测试。 三、总结 这里我们通过这次选择对于jpa的使用有了一个初步的了解，并且对于rest api的规范也有了个了解。 最后配套教程的代码全部在这里 github https://github.com/YuKongEr/SpringBoot-Study。麻烦点个star或者fork吧。 欢迎大家关注一下我的个人公众号。一起交流一起学习，有问必答。","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://www.yukonga.cn/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://www.yukonga.cn/tags/SpringBoot/"},{"name":"SpringDataJpa","slug":"SpringDataJpa","permalink":"http://www.yukonga.cn/tags/SpringDataJpa/"},{"name":"Rest","slug":"Rest","permalink":"http://www.yukonga.cn/tags/Rest/"}]},{"title":"【SpringBoot2.0系列03】SpringBoot之使用freemark视图模板","slug":"【SpringBoot2-0系列03】SpringBoot之使用freemark视图模板","date":"2018-08-16T05:50:50.000Z","updated":"2019-05-07T05:59:23.534Z","comments":true,"path":"2018/08/16/【SpringBoot2-0系列03】SpringBoot之使用freemark视图模板/","link":"","permalink":"http://www.yukonga.cn/2018/08/16/【SpringBoot2-0系列03】SpringBoot之使用freemark视图模板/","excerpt":"freemarker介绍； FreeMarker是一款模板引擎： 即一种基于模板和要改变的数据， 并用来生成输出文本（HTML网页、电子邮件、配置文件、源代码等）的通用工具。 它不是面向最终用户的，而是一个Java类库，是一款程序员可以嵌入他们所开发产品的组件。 前面我介绍了如何整合thymeleaf，那么现在我们再来了解一下SpringBoot中如何使用freemark","text":"freemarker介绍； FreeMarker是一款模板引擎： 即一种基于模板和要改变的数据， 并用来生成输出文本（HTML网页、电子邮件、配置文件、源代码等）的通用工具。 它不是面向最终用户的，而是一个Java类库，是一款程序员可以嵌入他们所开发产品的组件。 前面我介绍了如何整合thymeleaf，那么现在我们再来了解一下SpringBoot中如何使用freemark 一、目标 使用freemark视图模板，并且于SpringBoot进行整合。 使用freemark显示用户（user）的信息 二、实现 首先创建一个SpringBoot项目，添加如下依赖 1234567891011121314151617181920&lt;dependencies&gt; &lt;!-- freemark --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- test --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 添加完依赖以后，就需要编写对应的Controller跟view和User.java了 在src/main/java/com/yukong/chapter22目录下新建User 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.yukong.chapter22;import java.util.Date;/** * @Auther: xiongping22369 * @Date: 2018/8/13 17:53 * @Description: user类 */public class User &#123; /** * 用户名 */ private String username; /** * 密码 */ private String password; /** * 年龄 */ private Integer age; /** * 性别 1=男 2=女 其他=保密 */ private Integer sex; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public Integer getSex() &#123; return sex; &#125; public void setSex(Integer sex) &#123; this.sex = sex; &#125;&#125; 编写IndexController 实现将User信息传递给前台ftl页面。 123456789101112131415@Controllerpublic class IndexController &#123; @GetMapping(\"/aboutMe\") public String index(Model model) throws ParseException &#123; User user = new User(); user.setUsername(\"yukong\"); user.setPassword(\"abc123\"); user.setAge(18); user.setSex(1); model.addAttribute(\"user\", user); return \"index\"; &#125;&#125; 注意这里使用的是@Controller 在resource目录下新建templates文件夹并且在该目录下新建文件index.ftl 记住是ftl freemark文件的后缀名是ftl index.ftl代码 123456789101112131415161718192021222324&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;freemark&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt; 你好 $&#123;user.username&#125;&lt;/p&gt; &lt;p&gt; 密码 $&#123;user.password&#125;&lt;/p&gt; &lt;p&gt; 性别： &lt;#if user.sex==1&gt; 男 &lt;#elseif user.sex==2&gt; 女 &lt;#else&gt; 保密 &lt;/#if&gt; &lt;/p&gt; &lt;p&gt; 年龄 $&#123;user.age&#125;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 然后在src/resource/application.yml配置一下thymeleaf相关配置 1234567891011121314server: port: 8989spring: freemarker: request-context-attribute: req #req访问request suffix: .ftl #后缀名 content-type: text/html enabled: true cache: false #缓存配置 template-loader-path: classpath:/templates/ #模板加载路径 按需配置 charset: UTF-8 #编码格式 settings: number_format: '0.##' #数字格式化，无小数点 启动Chapter22Application.java并且访问http://localhost:8989/aboutMe 结果如图 由上图可知，freemark成功接受到了后台传递的数据。并且渲染到页面显示。 三、总结 此致我们SpringBoot整合freemark就完毕了。 最后配套教程的代码全部在这里 github https://github.com/YuKongEr/SpringBoot-Study。麻烦点个star或者fork吧。 欢迎大家关注一下我的个人公众号。一起交流一起学习，有问必答。","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://www.yukonga.cn/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://www.yukonga.cn/tags/SpringBoot/"},{"name":"FreeMark","slug":"FreeMark","permalink":"http://www.yukonga.cn/tags/FreeMark/"}]},{"title":"【SpringBoot2.0系列02】SpringBoot之使用Thymeleaf视图模板","slug":"【SpringBoot2-0系列02】SpringBoot之使用Thymeleaf视图模板","date":"2018-08-15T02:20:51.000Z","updated":"2019-05-07T05:59:20.546Z","comments":true,"path":"2018/08/15/【SpringBoot2-0系列02】SpringBoot之使用Thymeleaf视图模板/","link":"","permalink":"http://www.yukonga.cn/2018/08/15/【SpringBoot2-0系列02】SpringBoot之使用Thymeleaf视图模板/","excerpt":"Thymeleaf 是Java服务端的模板引擎，与传统的JSP不同，前者可以使用浏览器直接打开，因为可以忽略掉拓展属性，相当于打开原生页面，给前端人员也带来一定的便利。如果你已经厌倦了JSP+JSTL的组合，Thymeleaf或许是个不错的选择！","text":"Thymeleaf 是Java服务端的模板引擎，与传统的JSP不同，前者可以使用浏览器直接打开，因为可以忽略掉拓展属性，相当于打开原生页面，给前端人员也带来一定的便利。如果你已经厌倦了JSP+JSTL的组合，Thymeleaf或许是个不错的选择！ 一、目标 使用thymeleaf视图模板，并且于SpringBoot进行整合。 二、实现 首先创建一个SpringBoot项目，添加如下依赖 12345678910111213141516171819202122&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- springboot web 依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- thymeleaf 依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 添加完依赖以后，就需要编写对应的Controller跟view了 在resource目录下新建templates文件夹并且在该目录下新建文件index.html 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;你好&lt;/h1&gt; &lt;h1 th:text=\"$&#123;name&#125;\"&gt; &lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 在src/main/java/com/yukong/chapter目录下新建IndexController 12345678910@Controllerpublic class IndexController &#123; @GetMapping(\"/hello\") public String hello(@RequestParam(defaultValue = \"world\", required = false) String name, Model model) &#123; model.addAttribute(\"name\", name); return \"index\"; &#125;&#125; 注意这里使用的是@Controller 然后在src/resource/application.yml配置一下thymeleaf相关配置 123456789101112server: port: 8989spring: thymeleaf: # 配置视图路径前缀 prefix: classpath:/templates/ # 配置视图路径后缀 suffix: .html mode: html # 关闭缓存 修改视图 刷新浏览器就显示 开发阶段务必关闭缓存 (=false) cache: false 启动Chapter21Application.java并且访问http://localhost:8989/hello 结果如图： 再次访问http://localhost:8989/hello?name=yukong 结果如图 三、总结 最后配套教程的代码全部在这里 github https://github.com/YuKongEr/SpringBoot-Study。麻烦点个star或者fork吧。 欢迎大家关注一下我的个人公众号。一起交流一起学习，有问必答。","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://www.yukonga.cn/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://www.yukonga.cn/tags/SpringBoot/"},{"name":"Thymeleaf","slug":"Thymeleaf","permalink":"http://www.yukonga.cn/tags/Thymeleaf/"}]},{"title":"【SpringBoot2.0系列01】初识SpringBoot","slug":"【SpringBoot2-0系列01】初识SpringBoot","date":"2018-08-13T16:10:06.000Z","updated":"2019-07-22T08:49:43.867Z","comments":true,"path":"2018/08/14/【SpringBoot2-0系列01】初识SpringBoot/","link":"","permalink":"http://www.yukonga.cn/2018/08/14/【SpringBoot2-0系列01】初识SpringBoot/","excerpt":"想必大家都一定用过spring框架，每次整合spring框架的时候总是会有无穷无尽的xml配置文件，第一次写配置文件的时候，大家还会抱着学习的心态认真读每一个配置，但是当我们每次在构建项目都要写同样的配置文件大家应该会觉得厌烦，尽管只是复制粘贴。那么现在你就不用担心了，使用springboot让你更简单的构建spring应用。","text":"想必大家都一定用过spring框架，每次整合spring框架的时候总是会有无穷无尽的xml配置文件，第一次写配置文件的时候，大家还会抱着学习的心态认真读每一个配置，但是当我们每次在构建项目都要写同样的配置文件大家应该会觉得厌烦，尽管只是复制粘贴。那么现在你就不用担心了，使用springboot让你更简单的构建spring应用。 一、介绍 springboot让我们更加简单快速的构建spring应用，并且内置web容器（tomcat、jetty等）支持jar包的方式启动一个web应用。 SpringBoot主要优点： 为所有Spring开发者更快的入门 开箱即用，提供各种默认配置来简化项目配置 内嵌式容器简化Web项目 没有冗余代码生成和XML配置的要求 二、目标 本节主要目标是通过构建一个简单的SpringBoot项目，实现一个hello word接口。通过这样一个简单的例子让我们对springboot有一个了解。 三、实现 3.1、环境 java8 及以上 SpringBoot 2.0.4 3.2 构建项目 3.2.1 spring官网 SPRING INITIALIZR 1、访问 http://start.spring.io/ 2、选择maven构建、使用java语法、并且SpringBoot版本为2.0.4 具体如图： 3、点击Generate Project 下载构建成功的项目压缩包 解压完成之后我们就可以通过IntelliJ IDEA开发工具导入到工程， 菜单中选择File–&gt;New–&gt;Project from Existing Sources… 选择解压后的项目文件夹，点击OK 点击Import project from external model并选择Maven，点击Next到底为止。 如果你的环境有多个版本的JDK，注意到选择Java SDK的时候请选择系统安装1.8版本 3.2.2 使用idea构建 1、打开idea选择new -&gt; project -&gt; SPRING INITIALIZR 2、在ProjectSDK选择jdk8 3、点击next 输入gourpId artifactId 然后继续next 一直到完成就可以 其实大家看的出来，两种方式都是一样的，只不过用idea省去了我们手动下载介绍并且导入的步骤，稍显方便。 3.2.3、项目结构 关键目录解释 1、/src/main/java/ 存放项目所有源代码目录 2、/src/main/resources/ 存放项目所有资源文件以及配置文件目录 3、/src/test/ 存放测试代码目录 其中生成的Chapter1Application和Chapter1ApplicationTests类都可以直接运行来启动当前创建的项目。 3.3、添加web模块 打开pom.xml 添加spring-boot-starter-web 即可 1234567891011121314151617&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 3.4、编写hello world服务 在src/main/java目录下的chapter1包下新建一个HelloWorldController.java文件 123456789@RestController@RequestMapping(\"/hello\")public class HelloWorldController &#123; @GetMapping public String hello() &#123; return \"hello world\"; &#125;&#125; 其中 @RequestController是一个复合注解 ，大家按住ctrl看源码会发现 @RequestController = @Controller +@ResponseBody 那么它的作用就不言而喻了，代表当前类是一个控制器并且返回所有的方法将会返回json数据 3.5 、启动 双击打开Chapter1Application文件启动。 从图中可以看出日志打印启动tomcat服务的端口是8080 ，代表启动成功。 打开浏览器访问http://localhost:8080/hello 那么有时候我们的8080端口被占用了，那么就会启动失败，提示端口被占用，如何改变springboot启动的默认端口呢？ 打开application.yml 这时候大家就会问了 不是application.properties吗 其实yml文件也是配置文件的一种，它的书写简洁，我比较喜欢。 yml写法 12server: port: 9090 properties写法 1server.port=9090 上面的代码就是设置web服务启动的端口了。 四、总结 通过这次学习，我们了解了springboot如何启动一个web服务，并且如何更改web服务启动的默认端口。 最后配套教程的代码全部在这里 github https://github.com/YuKongEr/SpringBoot-Study。麻烦点个star或者fork吧。 欢迎大家关注一下我的个人公众号。一起交流一起学习，有问必答。","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://www.yukonga.cn/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://www.yukonga.cn/tags/SpringBoot/"}]}]}