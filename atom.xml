<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yukong&#39;s blog</title>
  
  <subtitle>learning program</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.yukonga.cn/"/>
  <updated>2020-04-04T16:01:35.218Z</updated>
  <id>http://www.yukonga.cn/</id>
  
  <author>
    <name>yukong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>395. Longest Substring with At Least K Repeating Characters</title>
    <link href="http://www.yukonga.cn/2020/04/04/395.%20Longest%20Substring%20with%20At%20Least%20K%20Repeating%20Characters/"/>
    <id>http://www.yukonga.cn/2020/04/04/395. Longest Substring with At Least K Repeating Characters/</id>
    <published>2020-04-04T15:59:59.000Z</published>
    <updated>2020-04-04T16:01:35.218Z</updated>
    
    <content type="html"><![CDATA[<h2 id="395-longest-substring-with-at-least-k-repeating-characters"><a class="markdownIt-Anchor" href="#395-longest-substring-with-at-least-k-repeating-characters"></a> <a href="https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/" target="_blank" rel="noopener">395. Longest Substring with At Least K Repeating Characters</a></h2><blockquote><p>原题链接 <a href="https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/" target="_blank" rel="noopener">395. Longest Substring with At Least K Repeating Characters</a></p></blockquote><h2 id="解析思路"><a class="markdownIt-Anchor" href="#解析思路"></a> 解析思路</h2><p>我们来思考一下什么样的情况可能可以构成连续的子串，每个字符都出现了至少k次；什么情况下又构不成？<br>很显然如果字符串里有字符在整个串里都没出现k次，那么含有这个字符的子串一定是不可能成立的。所以我们可以通过这些小于k次的字符作为分隔符 把长字符串分成一个个子串, 采用分支算法求字符串中符合条件的长度 返回其中最长的。</p><a id="more"></a><h3 id="ac代码"><a class="markdownIt-Anchor" href="#ac代码"></a> AC代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestSubstring</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> longestSubstring(s, <span class="number">0</span>, s.length() - <span class="number">1</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestSubstring</span><span class="params">(String s, <span class="keyword">int</span> begin, <span class="keyword">int</span> end, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (end - begin + <span class="number">1</span> &lt; k) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] chs = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="comment">// 计算出现次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i &lt;= end; i++) &#123;</span><br><span class="line">            chs[s.charAt(i) - <span class="string">'a'</span>] = chs[s.charAt(i) - <span class="string">'a'</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 跳过 次数小于k的</span></span><br><span class="line">        <span class="keyword">while</span> (begin &lt; end &amp;&amp; chs[s.charAt(begin) - <span class="string">'a'</span>] &lt; k) &#123;</span><br><span class="line">            begin++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (begin &lt; end &amp;&amp; chs[s.charAt(end) - <span class="string">'a'</span>] &lt; k) &#123;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (end - begin + <span class="number">1</span> &lt; k) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 分而治之</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i &lt;= end; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chs[s.charAt(i) - <span class="string">'a'</span>] &lt; k) &#123;</span><br><span class="line">                <span class="keyword">return</span> Math.max(longestSubstring(s, begin, i - <span class="number">1</span>, k), longestSubstring(s, i + <span class="number">1</span>, end, k));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> end - begin + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;395-longest-substring-with-at-least-k-repeating-characters&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#395-longest-substring-with-at-least-k-repeating-characters&quot;&gt;&lt;/a&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;395. Longest Substring with At Least K Repeating Characters&lt;/a&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;原题链接 &lt;a href=&quot;https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;395. Longest Substring with At Least K Repeating Characters&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;解析思路&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#解析思路&quot;&gt;&lt;/a&gt; 解析思路&lt;/h2&gt;
&lt;p&gt;我们来思考一下什么样的情况可能可以构成连续的子串，每个字符都出现了至少k次；什么情况下又构不成？&lt;br&gt;
很显然如果字符串里有字符在整个串里都没出现k次，那么含有这个字符的子串一定是不可能成立的。所以我们可以通过这些小于k次的字符作为分隔符 把长字符串分成一个个子串, 采用分支算法求字符串中符合条件的长度 返回其中最长的。&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://www.yukonga.cn/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://www.yukonga.cn/tags/leetcode/"/>
    
      <category term="分治算法" scheme="http://www.yukonga.cn/tags/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/"/>
    
      <category term="java" scheme="http://www.yukonga.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Seata-Server 启动流程源码分析</title>
    <link href="http://www.yukonga.cn/2020/04/02/Seata-Server-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://www.yukonga.cn/2020/04/02/Seata-Server-启动流程源码分析/</id>
    <published>2020-04-02T05:19:03.000Z</published>
    <updated>2020-04-02T05:50:09.404Z</updated>
    
    <content type="html"><![CDATA[<h2 id="认识seata"><a class="markdownIt-Anchor" href="#认识seata"></a> 认识Seata</h2><p>Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案。</p><a id="more"></a><h3 id="seata的txc模型"><a class="markdownIt-Anchor" href="#seata的txc模型"></a> Seata的TXC模型</h3><p><img src="http://images.yukonga.cn/20200402132010.png" alt="img"></p><p>根据上图可知整个TXC模型有三个重要的组件</p><ul><li>TC 事务协调器,维护全局和分支事务的状态，驱动全局事务提交或回滚。(单独部署)</li><li>TM  事务管理器 定义全局事务的范围：开始全局事务、提交或回滚全局事务。</li><li>RM 资源管理器 管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</li></ul><p>简单理解就是TM事务管理器通过RPC与TC通讯请求开启一个全局事务</p><p>简单理解过程就是: Business作为服务起始方(此时它是TM)发起全局事务并注册到TC。在调用协同服务时，协同服务的事务分支事务会先完成阶段一的事务提交或回滚，并生成事务回滚的undo_log日志，同时注册当前服务到TC并上报其事务状态，归并到同一个业务的全局事务中。此时若没有问题继续下一个服务的调用，期间任何服务的分支事务回滚，都会通知到TC，TC在通知全局事务包含的所有已完成一阶段提交的分支事务回滚。如果所有分支事务都正常，最后回到全局事务发起方时，也会通知到TC，TC在通知全局事务包含的所有分支删除回滚日志。在这个过程中为了解决写隔离和度隔离的问题会涉及到TC管理的全局锁。</p><p>那么全局事务是如何在服务中传递的呢？实际在TM向TC请求开启一个全局事务的时候，TC会响应一个全局事务XID，只需要TM在调用其他协同服务时把XID传递给协同服务，这样就可以实现全局事务在分布式服务中传播，以及分支事务属于哪个全局事务。</p><p>Seata目前已经支持许多框架中的XID的自动传递了</p><ul><li><p>dubbo</p></li><li><p>spring cloud</p></li><li><p>sofa-rpc</p></li></ul><p>用户在使用Seata的时候对于XID的传递完全是无感知。</p><p>上文提到Seata中三个重要的组件<code>TC TM RM</code>.</p><p>其中TC作为事务协调者, 它负责驱动全局事务的提交与回滚。根据它的职责可知。它的重要性不言而喻。</p><p>那么作为一个优秀的协调者它需要具备哪些功能呢？</p><ul><li>高可用</li><li>高性能</li><li>支持扩展</li></ul><p>那么我们根据我们的猜测来看看TC的实现模块Server是怎么来实现这写功能的。</p><h2 id="server模块介绍"><a class="markdownIt-Anchor" href="#server模块介绍"></a> Server模块介绍</h2><p><img src="http://images.yukonga.cn/20200402132019.png" alt="image-20200331221613306"></p><p>整个Server模块可以分成7个主要模块</p><ul><li>RPC模块 负责与TM RM交互</li><li>Coordinator Core模块 TC实现事务协调的核心模块</li><li>Lock模块 资源全局锁的实现</li><li>Config模块 支持配置TC的配置模块</li><li>Store模块 TC运行时全局事务以及分支事务的相关信息需要通过Store模块持久化</li><li>Discover模块 Seata TC服务注册发现模块</li><li>HA-Cluste模块 TC Server实现高可用的模块</li></ul><p>就一个Server端而言, 它就有7个模块。那么我们改从何看起呢。</p><p>我们可以用Server启动的main函数来理解清楚整个TC的运行流程</p><h2 id="server启动流程"><a class="markdownIt-Anchor" href="#server启动流程"></a> Server启动流程</h2><p>本文所有源码基于<code>Seata1.1.0</code> 个人能力有限,如有不对欢迎指出。</p><p>整个Server端是一个<code>java</code>应用,它是通过<code>java -jar</code>启动的,所以主入口是一个main函数。</p><p>入口地址是<code>io.seata.server.Server#main()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1、 参数解析</span></span><br><span class="line">        ParameterParser parameterParser = <span class="keyword">new</span> ParameterParser(args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、 监控初始化</span></span><br><span class="line">        MetricsManager.get().init();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、将存储模式放到系统环境变量÷</span></span><br><span class="line">        System.setProperty(ConfigurationKeys.STORE_MODE, parameterParser.getStoreMode());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、创建与RM TM通讯的rpc服务器</span></span><br><span class="line">        RpcServer rpcServer = <span class="keyword">new</span> RpcServer(WORKING_THREADS);</span><br><span class="line">        <span class="comment">//server port</span></span><br><span class="line">        rpcServer.setListenPort(parameterParser.getPort());</span><br><span class="line">        UUIDGenerator.init(parameterParser.getServerNode());</span><br><span class="line">        <span class="comment">//log store mode : file, db</span></span><br><span class="line">        <span class="comment">// 5、设置资源存储模式</span></span><br><span class="line">        SessionHolder.init(parameterParser.getStoreMode());</span><br><span class="line">        <span class="comment">// 6、核心事务协调器创建</span></span><br><span class="line">        DefaultCoordinator coordinator = <span class="keyword">new</span> DefaultCoordinator(rpcServer);</span><br><span class="line">        coordinator.init();</span><br><span class="line">        <span class="comment">// 7、把协调器作为一个回调 传给netty rpc模块</span></span><br><span class="line">        rpcServer.setHandler(coordinator);</span><br><span class="line">        <span class="comment">// 8、注册JVM关闭构造函数 </span></span><br><span class="line">        ShutdownHook.getInstance().addDisposable(coordinator);</span><br><span class="line">        ShutdownHook.getInstance().addDisposable(rpcServer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//127.0.0.1 and 0.0.0.0 are not valid here.</span></span><br><span class="line">        <span class="keyword">if</span> (NetUtil.isValidIp(parameterParser.getHost(), <span class="keyword">false</span>)) &#123;</span><br><span class="line">            XID.setIpAddress(parameterParser.getHost());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            XID.setIpAddress(NetUtil.getLocalIp());</span><br><span class="line">        &#125;</span><br><span class="line">        XID.setPort(rpcServer.getListenPort());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 9、启动RPC模块 监听TM RM的请求</span></span><br><span class="line">            rpcServer.init();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">"rpcServer init error:&#123;&#125;"</span>, e.getMessage(), e);</span><br><span class="line">            System.exit(-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>首先看看参数解析,其实参数解析很简单主要是通过<code>JCommander</code>解析main函数中的args数组,不过在需要注意的是,由于Seata Server已经支持容器部署, 所以在容器环境启动参数的创建跟正常启动的参数是不同的。容器部署的启动参数需要通过<code>System.getenv</code>获取</p><p><code>io.seata.server.ParameterParser#init()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 判断启动环境是否是容器</span></span><br><span class="line">            <span class="keyword">boolean</span> inContainer = <span class="keyword">this</span>.isRunningInContainer();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果是容器启动 则从系统环境变量读取参数配置</span></span><br><span class="line">            <span class="keyword">if</span> (inContainer) &#123;</span><br><span class="line">                <span class="keyword">if</span> (LOGGER.isInfoEnabled()) &#123;</span><br><span class="line">                    LOGGER.info(<span class="string">"The server is running in container."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">this</span>.seataEnv = StringUtils.trimToNull(System.getenv(ENV_SYSTEM_KEY));</span><br><span class="line">                <span class="keyword">this</span>.host = StringUtils.trimToNull(System.getenv(ENV_SEATA_IP_KEY));</span><br><span class="line">                <span class="keyword">this</span>.serverNode = NumberUtils.toInt(System.getenv(ENV_SERVER_NODE_KEY), SERVER_DEFAULT_NODE);</span><br><span class="line">                <span class="keyword">this</span>.port = NumberUtils.toInt(System.getenv(ENV_SEATA_PORT_KEY), SERVER_DEFAULT_PORT);</span><br><span class="line">                <span class="keyword">this</span>.storeMode = StringUtils.trimToNull(System.getenv(ENV_STORE_MODE_KEY));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 否则使用JCommander 解析启动参数</span></span><br><span class="line">                JCommander jCommander = JCommander.newBuilder().addObject(<span class="keyword">this</span>).build();</span><br><span class="line">                jCommander.parse(args);</span><br><span class="line">                <span class="keyword">if</span> (help) &#123;</span><br><span class="line">                    jCommander.setProgramName(PROGRAM_NAME);</span><br><span class="line">                    jCommander.usage();</span><br><span class="line">                    System.exit(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isNotBlank(seataEnv)) &#123;</span><br><span class="line">                System.setProperty(ENV_PROPERTY_KEY, seataEnv);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isBlank(storeMode)) &#123;</span><br><span class="line">                storeMode = ConfigurationFactory.getInstance().getConfig(ConfigurationKeys.STORE_MODE,</span><br><span class="line">                    SERVER_DEFAULT_STORE_MODE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParameterException e) &#123;</span><br><span class="line">            printError(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>拿到启动参数后我们就要根据启动参数依次 启动监控、设置存储模型，创建协调核心对象、启动Rpc服务器。</p><p>为什么Rpc服务器要在最后一个启动呢？ 下篇文章会解答。</p><p>由于监控对Seata的核心功能暂无影响所以本文已经后续文章暂不对监控进行分析。</p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>本文简单的介绍了一下<code>Seata Server</code>模块启动流程的一个分析，了解Seata的启动流程,但是都是比较简单没有深入，后续会陆续深入分析Rpc模块与核心协调模块。</p><p><img src="http://images.yukonga.cn/20200402134548.png" alt="扫码_搜索联合传播样式-标准色版"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;认识seata&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#认识seata&quot;&gt;&lt;/a&gt; 认识Seata&lt;/h2&gt;
&lt;p&gt;Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案。&lt;/p&gt;
    
    </summary>
    
      <category term="seata" scheme="http://www.yukonga.cn/categories/seata/"/>
    
    
      <category term="java" scheme="http://www.yukonga.cn/tags/java/"/>
    
      <category term="分布式事务" scheme="http://www.yukonga.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
      <category term="seata" scheme="http://www.yukonga.cn/tags/seata/"/>
    
  </entry>
  
  <entry>
    <title>230. Kth Smallest Element in a BST</title>
    <link href="http://www.yukonga.cn/2020/03/30/230-Kth-Smallest-Element-in-a-BST/"/>
    <id>http://www.yukonga.cn/2020/03/30/230-Kth-Smallest-Element-in-a-BST/</id>
    <published>2020-03-30T03:44:20.000Z</published>
    <updated>2020-04-02T05:29:25.309Z</updated>
    
    <content type="html"><![CDATA[<h2 id="230-kth-smallest-element-in-a-bst"><a class="markdownIt-Anchor" href="#230-kth-smallest-element-in-a-bst"></a> 230. Kth Smallest Element in a BST</h2><blockquote><p>原题地址 <a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/" target="_blank" rel="noopener">230. Kth Smallest Element in a BST</a></p></blockquote><h2 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h2><p>由于给的二叉搜索树，总所周知二叉搜索树的中序遍历是有序的。所以这题可以变相的理解的为有序数组的中的第k个数</p><p>二叉树的中路遍历有两种方法, 递归、非递归(借助 栈).</p><p>我们先看递归</p><a id="more"></a><h3 id="递归解法-1"><a class="markdownIt-Anchor" href="#递归解法-1"></a> 递归解法-1</h3><p>我们通过中序遍历,把遍历的值存在<code>List&lt;Integer&gt; res</code> 中, 然后返回<code>res.get(k -1)</code> 即,.很容易写出如下代码.</p><h4 id="ac代码"><a class="markdownIt-Anchor" href="#ac代码"></a> AC代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    inorder(root, res);</span><br><span class="line">    <span class="keyword">return</span> res.get(k - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ArrayList&lt;Integer&gt; <span class="title">inorder</span><span class="params">(TreeNode root, ArrayList&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    inorder(root.left, res);</span><br><span class="line">    res.add(root.val);</span><br><span class="line">    inorder(root.right, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显时间复杂是O(n),空间复杂度是O(n).</p><h3 id="递归解法-2"><a class="markdownIt-Anchor" href="#递归解法-2"></a> 递归解法-2</h3><p>其实我们没用必要记录每个节点的值, 我们只需要遍历到第k个节点, 并且记录它的值即可,虽然这样不能避免递归的次数,但是可以空间复杂度到O(1).</p><h4 id="ac代码-2"><a class="markdownIt-Anchor" href="#ac代码-2"></a> AC代码</h4><p>很容易写出如下代码.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    inorder(root, k);</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 减枝</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span> || count &gt;= k) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    inorder(root.left, k);</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">if</span> (k == count) &#123;</span><br><span class="line">        num = root.val;</span><br><span class="line">    &#125;</span><br><span class="line">    inorder(root.right, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂是O(n),空间复杂度是O(1).</p><h3 id="非递归解法栈"><a class="markdownIt-Anchor" href="#非递归解法栈"></a> 非递归解法(栈)</h3><p>总所周知通过栈我们能实现二叉树的中序遍历, 非递归的遍历的好处就是我们能提前结束,而不需等到整个二叉树遍历完.</p><p>同时在遍历的时候取第k个数的值即可.</p><h4 id="ac代码-3"><a class="markdownIt-Anchor" href="#ac代码-3"></a> AC代码</h4><p>代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(root);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        root = stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (--k == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        root = root.right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;230-kth-smallest-element-in-a-bst&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#230-kth-smallest-element-in-a-bst&quot;&gt;&lt;/a&gt; 230. Kth Smallest Element in a BST&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;原题地址 &lt;a href=&quot;https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;230. Kth Smallest Element in a BST&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;解题思路&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#解题思路&quot;&gt;&lt;/a&gt; 解题思路&lt;/h2&gt;
&lt;p&gt;由于给的二叉搜索树，总所周知二叉搜索树的中序遍历是有序的。所以这题可以变相的理解的为有序数组的中的第k个数&lt;/p&gt;
&lt;p&gt;二叉树的中路遍历有两种方法, 递归、非递归(借助 栈).&lt;/p&gt;
&lt;p&gt;我们先看递归&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://www.yukonga.cn/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://www.yukonga.cn/tags/leetcode/"/>
    
      <category term="java" scheme="http://www.yukonga.cn/tags/java/"/>
    
      <category term="BST" scheme="http://www.yukonga.cn/tags/BST/"/>
    
      <category term="算法" scheme="http://www.yukonga.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-951. Flip Equivalent Binary Trees</title>
    <link href="http://www.yukonga.cn/2019/05/28/LeetCode-951-Flip-Equivalent-Binary-Trees/"/>
    <id>http://www.yukonga.cn/2019/05/28/LeetCode-951-Flip-Equivalent-Binary-Trees/</id>
    <published>2019-05-28T06:19:41.000Z</published>
    <updated>2019-05-28T06:29:32.503Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/flip-equivalent-binary-trees/" target="_blank" rel="noopener">原题链接</a></p><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>我们可以为二叉树 T 定义一个翻转操作，如下所示：选择任意节点，然后交换它的左子树和右子树。</p><p>只要经过一定次数的翻转操作后，能使 X 等于 Y，我们就称二叉树 X <em>翻转等价</em>于二叉树 Y。</p><p>编写一个判断两个二叉树是否是<em>翻转等价</em>的函数。这些树由根节点 <code>root1</code> 和 <code>root2</code> 给出。</p> <a id="more"></a><p><strong>示例：</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">7</span>,<span class="number">8</span>], root2 = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="literal">null</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">8</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：We flipped at nodes with values <span class="number">1</span>, <span class="number">3</span>, <span class="keyword">and</span> <span class="number">5.</span></span><br></pre></td></tr></table></figure><h2 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h2><p>从跟节点开始 递归判断 两种情况 不需要反转(或者说是反转两次)  或者是需要反转一次</p><p>对应的情况：</p><p>需要反转 那就是左子树等于左子树 ， 右子树等于右子树</p><p>不需要反转 那就是左子树等于右子树 ， 右子树等于左子树</p><h2 id="ac代码"><a class="markdownIt-Anchor" href="#ac代码"></a> AC代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">flipEquiv</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(root1==<span class="keyword">null</span>&amp;&amp;root2==<span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span>( (root1 == <span class="keyword">null</span> &amp;&amp; root2 != <span class="keyword">null</span>)</span><br><span class="line">               || (root1 != <span class="keyword">null</span> &amp;&amp; root2 == <span class="keyword">null</span>))&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(root1.val!=root2.val)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span>((flipEquiv(root1.left,root2.left) &amp;&amp; flipEquiv(root1.right,root2.right)) ||</span><br><span class="line">               (flipEquiv(root1.left,root2.right) &amp;&amp; flipEquiv(root1.right,root2.left)))&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/flip-equivalent-binary-trees/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原题链接&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#题目描述&quot;&gt;&lt;/a&gt; 题目描述&lt;/h2&gt;
&lt;p&gt;我们可以为二叉树 T 定义一个翻转操作，如下所示：选择任意节点，然后交换它的左子树和右子树。&lt;/p&gt;
&lt;p&gt;只要经过一定次数的翻转操作后，能使 X 等于 Y，我们就称二叉树 X &lt;em&gt;翻转等价&lt;/em&gt;于二叉树 Y。&lt;/p&gt;
&lt;p&gt;编写一个判断两个二叉树是否是&lt;em&gt;翻转等价&lt;/em&gt;的函数。这些树由根节点 &lt;code&gt;root1&lt;/code&gt; 和 &lt;code&gt;root2&lt;/code&gt; 给出。&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://www.yukonga.cn/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://www.yukonga.cn/tags/leetcode/"/>
    
      <category term="java" scheme="http://www.yukonga.cn/tags/java/"/>
    
      <category term="算法" scheme="http://www.yukonga.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="递归" scheme="http://www.yukonga.cn/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-338 Counting Bits</title>
    <link href="http://www.yukonga.cn/2019/05/27/LeetCode-338-Counting-Bits/"/>
    <id>http://www.yukonga.cn/2019/05/27/LeetCode-338-Counting-Bits/</id>
    <published>2019-05-27T07:27:15.000Z</published>
    <updated>2019-05-27T07:42:16.867Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/counting-bits/submissions/" target="_blank" rel="noopener">原题链接</a></p><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>给定一个非负整数 <strong>num</strong>。对于 <strong>0 ≤ i ≤ num</strong> 范围中的每个数字 <strong>i</strong> ，计算其二进制数中的 1 的数目并将它们作为数组返回。</p><p><strong>示例 1:</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">2</span></span><br><span class="line">输出: [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">5</span></span><br><span class="line">输出: [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p><strong>进阶:</strong></p><ul><li>给出时间复杂度为**O(n*sizeof(integer))<strong>的解答非常容易。但你可以在线性时间</strong>O(n)**内用一趟扫描做到吗？</li><li>要求算法的空间复杂度为<strong>O(n)</strong>。</li><li>你能进一步完善解法吗？要求在C<ins>或任何其他语言中不使用任何内置函数（如 C</ins> 中的 <strong>__builtin_popcount</strong>）来执行此操作。</li></ul><h2 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h2><p><code>i &amp; (i - 1)</code>去掉<code>i</code>最右边的一个1；因<code>i &amp; (i - 1）&lt; i</code>，故<code>result[i &amp; (i - 1)]</code>已计算，所以<code>i</code>中1的个数为<code>result[i &amp; (i - 1)] + 1</code></p><h2 id="ac代码"><a class="markdownIt-Anchor" href="#ac代码"></a> AC代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] countBits(<span class="keyword">int</span> num) &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[num + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num ; i++) &#123;</span><br><span class="line">        res[i] = res[i &amp; (i - <span class="number">1</span>)] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/counting-bits/submissions/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原题链接&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a class=
      
    
    </summary>
    
      <category term="leetcode" scheme="http://www.yukonga.cn/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://www.yukonga.cn/tags/leetcode/"/>
    
      <category term="java" scheme="http://www.yukonga.cn/tags/java/"/>
    
      <category term="算法" scheme="http://www.yukonga.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【SpringSecurity系列02】SpringSecurity UsernamePasswordAuthenticationFilter认证逻辑源码解读</title>
    <link href="http://www.yukonga.cn/2019/04/12/%E3%80%90SpringSecurity%E7%B3%BB%E5%88%9702%E3%80%91SpringSecurity%20UsernamePasswordAuthenticationFilter%E8%AE%A4%E8%AF%81%E9%80%BB%E8%BE%91%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    <id>http://www.yukonga.cn/2019/04/12/【SpringSecurity系列02】SpringSecurity UsernamePasswordAuthenticationFilter认证逻辑源码解读/</id>
    <published>2019-04-12T07:58:25.000Z</published>
    <updated>2019-07-27T06:07:47.719Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概要"><a class="markdownIt-Anchor" href="#概要"></a> 概要</h2><p>前面一节，通过简单配置即可实现SpringSecurity表单认证功能，而今天这一节将通过阅读源码的形式来学习SpringSecurity是如何实现这些功能, 前方高能预警，<strong><code>本篇分析源码篇幅较长</code></strong>。</p><a id="more"></a><h2 id="过滤器链"><a class="markdownIt-Anchor" href="#过滤器链"></a> 过滤器链</h2><p>前面我说过SpringSecurity是基于过滤器链的形式，那么我解析将会介绍一下具体有哪些过滤器。</p><table><thead><tr><th style="text-align:center">Filter Class</th><th style="text-align:center">介绍</th></tr></thead><tbody><tr><td style="text-align:center">SecurityContextPersistenceFilter</td><td style="text-align:center">判断当前用户是否登录</td></tr><tr><td style="text-align:center">CrsfFilter</td><td style="text-align:center">用于防止csrf攻击</td></tr><tr><td style="text-align:center">LogoutFilter</td><td style="text-align:center">处理注销请求</td></tr><tr><td style="text-align:center">UsernamePasswordAuthenticationFilter</td><td style="text-align:center">处理表单登录的请求(也是我们今天的主角)</td></tr><tr><td style="text-align:center">BasicAuthenticationFilter</td><td style="text-align:center">处理http basic认证的请求</td></tr></tbody></table><p>由于过滤器链中的过滤器实在太多，我没有一一列举，调了几个比较重要的介绍一下。</p><p>通过上面我们知道SpringSecurity对于表单登录的认证请求是交给了UsernamePasswordAuthenticationFilter处理的，那么具体的认证流程如下：</p><p><img src="https://i.loli.net/2019/05/24/5ce7b959b91be68275.png" alt="">从上图可知，<code>UsernamePasswordAuthenticationFilter</code>继承于抽象类<code>AbstractAuthenticationProcessingFilter</code>。</p><p>具体认证是：</p><ol><li>进入doFilter方法，判断是否要认证，如果需要认证则进入attemptAuthentication方法，如果不需要直接结束</li><li>attemptAuthentication方法中根据username跟password构造一个UsernamePasswordAuthenticationToken对象(此时的token是未认证的)，并且将它交给ProviderManger来完成认证。</li><li>ProviderManger中维护这一个AuthenticationProvider对象列表，通过遍历判断并且最后选择DaoAuthenticationProvider对象来完成最后的认证。</li><li>DaoAuthenticationProvider根据ProviderManger传来的token取出username，并且调用我们写的UserDetailsService的loadUserByUsername方法从数据库中读取用户信息，然后对比用户密码，如果认证通过，则返回用户信息也是就是UserDetails对象，在重新构造UsernamePasswordAuthenticationToken(此时的token是 已经认证通过了的)。</li></ol><p>接下来我们将通过源码来分析具体的整个认证流程。</p><h2 id="abstractauthenticationprocessingfilter"><a class="markdownIt-Anchor" href="#abstractauthenticationprocessingfilter"></a> AbstractAuthenticationProcessingFilter</h2><p>AbstractAuthenticationProcessingFilter 是一个抽象类。所有的认证认证请求的过滤器都会继承于它，它主要将一些公共的功能实现，而具体的验证逻辑交给子类实现，有点类似于父类设置好认证流程，子类负责具体的认证逻辑，这样跟设计模式的<strong>模板方法模式</strong>有点相似。</p><p>现在我们分析一下 它里面比较重要的方法</p><h3 id="1-dofilter"><a class="markdownIt-Anchor" href="#1-dofilter"></a> 1、doFilter</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest req, ServletResponse res, FilterChain chain)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"><span class="comment">// 省略不相干代码。。。</span></span><br><span class="line">    <span class="comment">// 1、判断当前请求是否要认证</span></span><br><span class="line"><span class="keyword">if</span> (!requiresAuthentication(request, response)) &#123;</span><br><span class="line">      <span class="comment">// 不需要直接走下一个过滤器</span></span><br><span class="line">chain.doFilter(request, response);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 2、开始请求认证，attemptAuthentication具体实现给子类，如果认证成功返回一个认证通过的Authenticaion对象</span></span><br><span class="line">authResult = attemptAuthentication(request, response);</span><br><span class="line"><span class="keyword">if</span> (authResult == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">      <span class="comment">// 3、登录成功 将认证成功的用户信息放入session SessionAuthenticationStrategy接口，用于扩展</span></span><br><span class="line">sessionStrategy.onAuthentication(authResult, request, response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (InternalAuthenticationServiceException failed) &#123;</span><br><span class="line">      <span class="comment">//2.1、发生异常，登录失败，进入登录失败handler回调</span></span><br><span class="line">unsuccessfulAuthentication(request, response, failed);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (AuthenticationException failed) &#123;</span><br><span class="line">      <span class="comment">//2.1、发生异常，登录失败，进入登录失败处理器</span></span><br><span class="line">unsuccessfulAuthentication(request, response, failed);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3.1、登录成功，进入登录成功处理器。</span></span><br><span class="line">successfulAuthentication(request, response, chain, authResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-successfulauthentication"><a class="markdownIt-Anchor" href="#2-successfulauthentication"></a> 2、successfulAuthentication</h3><p>登录成功处理器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">successfulAuthentication</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">HttpServletResponse response, FilterChain chain, Authentication authResult)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">    <span class="comment">//1、登录成功 将认证成功的Authentication对象存入SecurityContextHolder中</span></span><br><span class="line">    <span class="comment">//  SecurityContextHolder本质是一个ThreadLocal</span></span><br><span class="line">SecurityContextHolder.getContext().setAuthentication(authResult);</span><br><span class="line">    <span class="comment">//2、如果开启了记住我功能，将调用rememberMeServices的loginSuccess 将生成一个token</span></span><br><span class="line">  <span class="comment">//   将token放入cookie中这样 下次就不用登录就可以认证。具体关于记住我rememberMeServices的相关分析我们下面几篇文章会深入分析的。</span></span><br><span class="line">rememberMeServices.loginSuccess(request, response, authResult);</span><br><span class="line"><span class="comment">// Fire event</span></span><br><span class="line">    <span class="comment">//3、发布一个登录事件。</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.eventPublisher != <span class="keyword">null</span>) &#123;</span><br><span class="line">eventPublisher.publishEvent(<span class="keyword">new</span> InteractiveAuthenticationSuccessEvent(</span><br><span class="line">authResult, <span class="keyword">this</span>.getClass()));</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//4、调用我们自己定义的登录成功处理器，这样也是我们扩展得知登录成功的一个扩展点。</span></span><br><span class="line">successHandler.onAuthenticationSuccess(request, response, authResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-unsuccessfulauthentication"><a class="markdownIt-Anchor" href="#3-unsuccessfulauthentication"></a> 3、unsuccessfulAuthentication</h3><p>登录失败处理器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">unsuccessfulAuthentication</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">HttpServletResponse response, AuthenticationException failed)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">    <span class="comment">//1、登录失败，将SecurityContextHolder中的信息清空</span></span><br><span class="line">SecurityContextHolder.clearContext();</span><br><span class="line">    <span class="comment">//2、关于记住我功能的登录失败处理</span></span><br><span class="line">rememberMeServices.loginFail(request, response);</span><br><span class="line">    <span class="comment">//3、调用我们自己定义的登录失败处理器，这里可以扩展记录登录失败的日志。</span></span><br><span class="line">failureHandler.onAuthenticationFailure(request, response, failed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于AbstractAuthenticationProcessingFilter主要分析就到这。我们可以从源码中知道，当请求进入该过滤器中具体的流程是</p><ol><li>判断该请求是否要被认证</li><li>调用<code>attemptAuthentication</code>方法开始认证，由于是抽象方法具体认证逻辑给子类</li><li>如果登录成功，则将认证结果<code>Authentication</code>对象根据session策略写入session中，将认证结果写入到<code>SecurityContextHolder</code>,如果开启了记住我功能，则根据记住我功能，生成token并且写入cookie中，最后调用一个<code>successHandler</code>对象的方法，这个对象可以是我们配置注入的，用于处理我们的自定义登录成功的一些逻辑（比如记录登录成功日志等等）。</li><li>如果登录失败，则清空<code>SecurityContextHolder</code>中的信息，并且调用我们自己注入的<code>failureHandler</code>对象，处理我们自己的登录失败逻辑。</li></ol><h2 id="usernamepasswordauthenticationfilter"><a class="markdownIt-Anchor" href="#usernamepasswordauthenticationfilter"></a> UsernamePasswordAuthenticationFilter</h2><p>从上面分析我们可以知道，<code>UsernamePasswordAuthenticationFilter</code>是继承于<code>AbstractAuthenticationProcessingFilter</code>，并且实现它的<code>attemptAuthentication</code>方法，来实现认证具体的逻辑实现。接下来，我们通过阅读<code>UsernamePasswordAuthenticationFilter</code>的源码来解读，它是如何完成认证的。 由于这里会涉及<code>UsernamePasswordAuthenticationToken</code>对象构造，所以我们先看看<code>UsernamePasswordAuthenticationToken</code>的源码</p><h3 id="1-usernamepasswordauthenticationtoken"><a class="markdownIt-Anchor" href="#1-usernamepasswordauthenticationtoken"></a> 1、UsernamePasswordAuthenticationToken</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承至AbstractAuthenticationToken </span></span><br><span class="line"><span class="comment">// AbstractAuthenticationToken主要定义一下在SpringSecurity中toke需要存在一些必须信息</span></span><br><span class="line"><span class="comment">// 例如权限集合  Collection&lt;GrantedAuthority&gt; authorities; 是否认证通过boolean authenticated = false;认证通过的用户信息Object details;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsernamePasswordAuthenticationToken</span> <span class="keyword">extends</span> <span class="title">AbstractAuthenticationToken</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 未登录情况下 存的是用户名 登录成功情况下存的是UserDetails对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object principal;</span><br><span class="line">  <span class="comment">// 密码</span></span><br><span class="line"><span class="keyword">private</span> Object credentials;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 构造函数，用户没有登录的情况下，此时的authenticated是false，代表尚未认证</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UsernamePasswordAuthenticationToken</span><span class="params">(Object principal, Object credentials)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(<span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">this</span>.principal = principal;</span><br><span class="line"><span class="keyword">this</span>.credentials = credentials;</span><br><span class="line">setAuthenticated(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 构造函数，用户登录成功的情况下，多了一个参数 是用户的权限集合，此时的authenticated是true，代表认证成功</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UsernamePasswordAuthenticationToken</span><span class="params">(Object principal, Object credentials,</span></span></span><br><span class="line"><span class="function"><span class="params">Collection&lt;? extends GrantedAuthority&gt; authorities)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(authorities);</span><br><span class="line"><span class="keyword">this</span>.principal = principal;</span><br><span class="line"><span class="keyword">this</span>.credentials = credentials;</span><br><span class="line"><span class="keyword">super</span>.setAuthenticated(<span class="keyword">true</span>); <span class="comment">// must use super, as we override</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们就可以分析attemptAuthentication方法了。</p><h3 id="2-attemptauthentication"><a class="markdownIt-Anchor" href="#2-attemptauthentication"></a> 2、attemptAuthentication</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Authentication <span class="title">attemptAuthentication</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">HttpServletResponse response)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">     <span class="comment">// 1、判断是不是post请求，如果不是则抛出AuthenticationServiceException异常，注意这里抛出的异常都在AbstractAuthenticationProcessingFilter#doFilter方法中捕获，捕获之后会进入登录失败的逻辑。</span></span><br><span class="line"><span class="keyword">if</span> (postOnly &amp;&amp; !request.getMethod().equals(<span class="string">"POST"</span>)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> AuthenticationServiceException(</span><br><span class="line"><span class="string">"Authentication method not supported: "</span> + request.getMethod());</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 2、从request中拿用户名跟密码</span></span><br><span class="line">String username = obtainUsername(request);</span><br><span class="line">String password = obtainPassword(request);</span><br><span class="line"><span class="comment">// 3、非空处理，防止NPE异常</span></span><br><span class="line"><span class="keyword">if</span> (username == <span class="keyword">null</span>) &#123;</span><br><span class="line">username = <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (password == <span class="keyword">null</span>) &#123;</span><br><span class="line">password = <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 4、除去空格</span></span><br><span class="line">username = username.trim();</span><br><span class="line">    <span class="comment">// 5、根据username跟password构造出一个UsernamePasswordAuthenticationToken对象 从上文分析可知道，此时的token是未认证的。</span></span><br><span class="line">UsernamePasswordAuthenticationToken authRequest = <span class="keyword">new</span> UsernamePasswordAuthenticationToken(</span><br><span class="line">username, password);</span><br><span class="line">    <span class="comment">// 6、配置一下其他信息 ip 等等</span></span><br><span class="line">setDetails(request, authRequest);</span><br><span class="line">   <span class="comment">//  7、调用ProviderManger的authenticate的方法进行具体认证逻辑</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.getAuthenticationManager().authenticate(authRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="providermanager"><a class="markdownIt-Anchor" href="#providermanager"></a> ProviderManager</h2><p>维护一个AuthenticationProvider列表，进行认证逻辑验证</p><h3 id="1-authenticate"><a class="markdownIt-Anchor" href="#1-authenticate"></a> 1、authenticate</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Authentication <span class="title">authenticate</span><span class="params">(Authentication authentication)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">    <span class="comment">// 1、拿到token的类型。</span></span><br><span class="line">Class&lt;? extends Authentication&gt; toTest = authentication.getClass();</span><br><span class="line">AuthenticationException lastException = <span class="keyword">null</span>;</span><br><span class="line">Authentication result = <span class="keyword">null</span>;</span><br><span class="line">   <span class="comment">// 2、遍历AuthenticationProvider列表</span></span><br><span class="line"><span class="keyword">for</span> (AuthenticationProvider provider : getProviders()) &#123;</span><br><span class="line">      <span class="comment">// 3、AuthenticationProvider不支持当前token类型，则直接跳过</span></span><br><span class="line"><span class="keyword">if</span> (!provider.supports(toTest)) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 4、如果Provider支持当前token，则交给Provider完成认证。</span></span><br><span class="line">result = provider.authenticate(authentication);</span><br><span class="line">     </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (AccountStatusException e) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (InternalAuthenticationServiceException e) &#123;</span><br><span class="line"><span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (AuthenticationException e) &#123;</span><br><span class="line">lastException = e;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 5、登录成功 返回登录成功的token</span></span><br><span class="line"><span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">eventPublisher.publishAuthenticationSuccess(result);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="abstractuserdetailsauthenticationprovider"><a class="markdownIt-Anchor" href="#abstractuserdetailsauthenticationprovider"></a> AbstractUserDetailsAuthenticationProvider</h2><h3 id="1-authenticate-2"><a class="markdownIt-Anchor" href="#1-authenticate-2"></a> 1、authenticate</h3><p><code>AbstractUserDetailsAuthenticationProvider</code>实现了<code>AuthenticationProvider</code>接口，并且实现了部分方法，<code>DaoAuthenticationProvider</code>继承于<code>AbstractUserDetailsAuthenticationProvider</code>类，所以我们先来看看<code>AbstractUserDetailsAuthenticationProvider</code>的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractUserDetailsAuthenticationProvider</span> <span class="keyword">implements</span></span></span><br><span class="line"><span class="class"><span class="title">AuthenticationProvider</span>, <span class="title">InitializingBean</span>, <span class="title">MessageSourceAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 国际化处理</span></span><br><span class="line"><span class="keyword">protected</span> MessageSourceAccessor messages = SpringSecurityMessageSource.getAccessor();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对token一些检查，具体检查逻辑交给子类实现，抽象方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">additionalAuthenticationChecks</span><span class="params">(UserDetails userDetails,</span></span></span><br><span class="line"><span class="function"><span class="params">UsernamePasswordAuthenticationToken authentication)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> AuthenticationException</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 认证逻辑的实现，调用抽象方法retrieveUser根据username获取UserDetails对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Authentication <span class="title">authenticate</span><span class="params">(Authentication authentication)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1、获取usernmae</span></span><br><span class="line">String username = (authentication.getPrincipal() == <span class="keyword">null</span>) ? <span class="string">"NONE_PROVIDED"</span></span><br><span class="line">: authentication.getName();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、尝试去缓存中获取UserDetails对象</span></span><br><span class="line">UserDetails user = <span class="keyword">this</span>.userCache.getUserFromCache(username);</span><br><span class="line">    <span class="comment">// 3、如果为空，则代表当前对象没有缓存。</span></span><br><span class="line"><span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</span><br><span class="line">cacheWasUsed = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//4、调用retrieveUser去获取UserDetail对象，为什么这个方法是抽象方法大家很容易知道，如果UserDetail信息存在关系数据库 则可以重写该方法并且去关系数据库获取用户信息，如果UserDetail信息存在其他地方，可以重写该方法用其他的方法去获取用户信息，这样丝毫不影响整个认证流程，方便扩展。</span></span><br><span class="line">user = retrieveUser(username,</span><br><span class="line">(UsernamePasswordAuthenticationToken) authentication);</span><br><span class="line">&#125;</span><br><span class="line">      <span class="keyword">catch</span> (UsernameNotFoundException notFound) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 捕获异常 日志处理 并且往上抛出，登录失败。</span></span><br><span class="line"><span class="keyword">if</span> (hideUserNotFoundExceptions) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BadCredentialsException(messages.getMessage(</span><br><span class="line"><span class="string">"AbstractUserDetailsAuthenticationProvider.badCredentials"</span>,</span><br><span class="line"><span class="string">"Bad credentials"</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> notFound;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 5、前置检查  判断当前用户是否锁定，禁用等等</span></span><br><span class="line">preAuthenticationChecks.check(user);</span><br><span class="line">      <span class="comment">// 6、其他的检查，在DaoAuthenticationProvider是检查密码是否一致</span></span><br><span class="line">additionalAuthenticationChecks(user,</span><br><span class="line">(UsernamePasswordAuthenticationToken) authentication);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (AuthenticationException exception) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7、后置检查，判断密码是否过期</span></span><br><span class="line">postAuthenticationChecks.check(user);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 8、登录成功通过UserDetail对象重新构造一个认证通过的Token对象</span></span><br><span class="line"><span class="keyword">return</span> createSuccessAuthentication(principalToReturn, authentication, user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Authentication <span class="title">createSuccessAuthentication</span><span class="params">(Object principal,</span></span></span><br><span class="line"><span class="function"><span class="params">Authentication authentication, UserDetails user)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 调用第二个构造方法，构造一个认证通过的Token对象</span></span><br><span class="line">UsernamePasswordAuthenticationToken result = <span class="keyword">new</span> UsernamePasswordAuthenticationToken(</span><br><span class="line">principal, authentication.getCredentials(),</span><br><span class="line">authoritiesMapper.mapAuthorities(user.getAuthorities()));</span><br><span class="line">result.setDetails(authentication.getDetails());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们具体看看<code>retrieveUser</code>的实现，没看源码大家应该也可以知道，<code>retrieveUser</code>方法应该是调用<code>UserDetailsService</code>去数据库查询是否有该用户，以及用户的密码是否一致。</p><h2 id="daoauthenticationprovider"><a class="markdownIt-Anchor" href="#daoauthenticationprovider"></a> DaoAuthenticationProvider</h2><p>DaoAuthenticationProvider 主要是通过UserDetailService来获取UserDetail对象。</p><h3 id="1-retrieveuser"><a class="markdownIt-Anchor" href="#1-retrieveuser"></a> 1、retrieveUser</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> UserDetails <span class="title">retrieveUser</span><span class="params">(String username,</span></span></span><br><span class="line"><span class="function"><span class="params">UsernamePasswordAuthenticationToken authentication)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 1、调用UserDetailsService接口的loadUserByUsername方法获取UserDeail对象</span></span><br><span class="line">UserDetails loadedUser = <span class="keyword">this</span>.getUserDetailsService().loadUserByUsername(username);</span><br><span class="line">       <span class="comment">// 2、如果loadedUser为null 代表当前用户不存在，抛出异常 登录失败。</span></span><br><span class="line"><span class="keyword">if</span> (loadedUser == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> InternalAuthenticationServiceException(</span><br><span class="line"><span class="string">"UserDetailsService returned null, which is an interface contract violation"</span>);</span><br><span class="line">&#125;</span><br><span class="line">      <span class="comment">// 3、返回查询的结果</span></span><br><span class="line"><span class="keyword">return</span> loadedUser;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-additionalauthenticationchecks"><a class="markdownIt-Anchor" href="#2-additionalauthenticationchecks"></a> 2、additionalAuthenticationChecks</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">additionalAuthenticationChecks</span><span class="params">(UserDetails userDetails,</span></span></span><br><span class="line"><span class="function"><span class="params">UsernamePasswordAuthenticationToken authentication)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">    <span class="comment">// 1、如果密码为空，则抛出异常、</span></span><br><span class="line"><span class="keyword">if</span> (authentication.getCredentials() == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BadCredentialsException(messages.getMessage(</span><br><span class="line"><span class="string">"AbstractUserDetailsAuthenticationProvider.badCredentials"</span>,</span><br><span class="line"><span class="string">"Bad credentials"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、获取用户输入的密码</span></span><br><span class="line">String presentedPassword = authentication.getCredentials().toString();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、调用passwordEncoder的matche方法 判断密码是否一致</span></span><br><span class="line"><span class="keyword">if</span> (!passwordEncoder.matches(presentedPassword, userDetails.getPassword())) &#123;</span><br><span class="line">logger.debug(<span class="string">"Authentication failed: password does not match stored value"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 4、如果不一致 则抛出异常。</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BadCredentialsException(messages.getMessage(</span><br><span class="line"><span class="string">"AbstractUserDetailsAuthenticationProvider.badCredentials"</span>,</span><br><span class="line"><span class="string">"Bad credentials"</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>至此，整认证流程已经分析完毕，大家如果有什么不懂可以关注我的公众号一起讨论。</p><p>学习是一个漫长的过程，学习源码可能会很困难但是只要努力一定就会有获取，大家一致共勉。</p><p><img src="https://i.loli.net/2019/05/24/5ce7b959b91be68275.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概要&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#概要&quot;&gt;&lt;/a&gt; 概要&lt;/h2&gt;
&lt;p&gt;前面一节，通过简单配置即可实现SpringSecurity表单认证功能，而今天这一节将通过阅读源码的形式来学习SpringSecurity是如何实现这些功能, 前方高能预警，&lt;strong&gt;&lt;code&gt;本篇分析源码篇幅较长&lt;/code&gt;&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="SpringSecurity" scheme="http://www.yukonga.cn/categories/SpringSecurity/"/>
    
    
      <category term="SpringBoot" scheme="http://www.yukonga.cn/tags/SpringBoot/"/>
    
      <category term="SpringSecurity" scheme="http://www.yukonga.cn/tags/SpringSecurity/"/>
    
  </entry>
  
  <entry>
    <title>【SpringSecurity系列01】初识SpringSecurity</title>
    <link href="http://www.yukonga.cn/2019/04/11/%E3%80%90SpringSecurity%E7%B3%BB%E5%88%9701%E3%80%91%E5%88%9D%E8%AF%86SpringSecurity/"/>
    <id>http://www.yukonga.cn/2019/04/11/【SpringSecurity系列01】初识SpringSecurity/</id>
    <published>2019-04-11T08:20:09.000Z</published>
    <updated>2019-05-24T09:27:17.373Z</updated>
    
    <content type="html"><![CDATA[<p>​    什么是<code>SpringSecurity</code> ？</p><a id="more"></a><blockquote><p>​      Spring Security是一个能够为基于Spring的企业应用系统提供声明式的安全访问控制解决方案的安全框架。它提供了一组可以在Spring应用上下文中配置的Bean，充分利用了Spring IoC，DI（控制反转Inversion of Control ,DI:Dependency Injection 依赖注入）和AOP（面向切面编程）功能，为应用系统提供声明式的安全访问控制功能，减少了为企业系统安全控制编写大量重复代码的工作。</p></blockquote><p>以上来介绍来自<code>wiki</code>，比较官方。</p><p>​        用自己的话 简单介绍一下，<code>Spring Security</code>基于 Servlet 过滤器链的形式，为我们的web项目提供<code>认证</code>与<code>授权</code>服务。它来自于<code>Spring</code>，那么它与<code>SpringBoot</code>整合开发有着天然的优势，目前与<code>SpringSecurity</code>对应的开源框架还有<code>shiro</code>。接下来我将通过一个简单的例子带大家来认识<code>SpringSecurity</code>,然后通过分析它的源码带大家来认识一下<code>SpringSecurity</code>是如何工作，从一个简单例子入门，大家由浅入深的了解学习<code>SpringSecurity</code>。</p><p>通常大家在做一个后台管理的系统的时候，应该采用<code>session</code>判断用户是否登录。我记得我在没有接触学习SpringSecurity与shiro之前。对于用户登录功能实现通常是如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(User user, HttpSession session)</span></span>&#123;</span><br><span class="line">  <span class="comment">//1、根据用户名或者id从数据库读取数据库中用户</span></span><br><span class="line">  <span class="comment">//2、判断密码是否一致</span></span><br><span class="line">  <span class="comment">//3、如果密码一致</span></span><br><span class="line">  session.setAttribute(<span class="string">"user"</span>,user);</span><br><span class="line">  <span class="comment">//4、否则返回登录页面</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">对于之后那些需要登录之后才能访问的url，通过SpringMvc的拦截器中的#preHandle来判断session中是否有user对象</span><br><span class="line">如果没有 则返回登录页面</span><br><span class="line">如果有， 则允许访问这个页面。</span><br></pre></td></tr></table></figure><p>但是在<code>SpringSecurity</code>中，这一些逻辑已经被封装起来，我们只需要简单的配置一下就能使用。</p><p>接下来我通过一个简单例子大家认识一下<code>SpringSecurity</code></p><p>本文基于<code>SpringBoot</code>，如果大家对SpringBoot不熟悉的话可以看看我之前写的<a href="https://www.jianshu.com/p/5d0295fb375a" target="_blank" rel="noopener">SpringBoot入门系列</a></p><p>我使用的是：</p><ul><li>SpringBoot 2.1.4.RELEASE</li><li>SpringSecurity 5</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.yukong<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springboot-springsecurity<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>springboot-springsecurity<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>springboot-springsecurity study<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.security<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-security-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置一下数据库 以及<code>MyBatis</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  datasource:</span></span><br><span class="line"><span class="attr">    driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">    url:</span> <span class="attr">jdbc:mysql://127.0.0.1:3306/db_test?useUnicode=true&amp;characterEncoding=utf8</span></span><br><span class="line"><span class="attr">    password:</span> <span class="string">abc123</span></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line"><span class="attr">  mapper-locations:</span> <span class="attr">classpath:mapper/*.xml</span></span><br></pre></td></tr></table></figure><p>这里我用的<code>MySQL8.0</code> 大家注意一下 <code>MySQL8.0</code>的数据库驱动的类的包改名了</p><p>在前面我有讲过SpringBoot中如何整合Mybatis，在这里我就不累述，有需要的话看<a href="https://www.jianshu.com/p/c44dc639cb93" target="_blank" rel="noopener">这篇文章</a></p><p><code>user.sql</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`user`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'主键'</span>,</span><br><span class="line">  <span class="string">`username`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户名'</span>,</span><br><span class="line">  <span class="string">`svc_num`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户号码'</span>,</span><br><span class="line">  <span class="string">`password`</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'密码'</span>,</span><br><span class="line">  <span class="string">`cust_id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'客户id  1对1'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">2</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4 <span class="keyword">COLLATE</span>=utf8mb4_0900_ai_ci;</span><br></pre></td></tr></table></figure><p>对应的<code>UserMapper.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukong.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yukong.entity.User;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yukong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-04-11 16:50</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insertSelective</span><span class="params">(User record)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">User <span class="title">selectByUsername</span><span class="params">(String  username)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>UserMapper.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.yukong.mapper.UserMapper"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"BaseResultMap"</span> <span class="attr">type</span>=<span class="string">"com.yukong.entity.User"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">jdbcType</span>=<span class="string">"BIGINT"</span> <span class="attr">property</span>=<span class="string">"id"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"username"</span> <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span> <span class="attr">property</span>=<span class="string">"username"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"svc_num"</span> <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span> <span class="attr">property</span>=<span class="string">"svcNum"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"password"</span> <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span> <span class="attr">property</span>=<span class="string">"password"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"cust_id"</span> <span class="attr">jdbcType</span>=<span class="string">"BIGINT"</span> <span class="attr">property</span>=<span class="string">"custId"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">"Base_Column_List"</span>&gt;</span></span><br><span class="line">    id, username, svc_num, `password`, cust_id</span><br><span class="line">  <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectByUsername"</span> <span class="attr">parameterType</span>=<span class="string">"java.lang.String"</span> <span class="attr">resultMap</span>=<span class="string">"BaseResultMap"</span>&gt;</span></span><br><span class="line">    select</span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"Base_Column_List"</span> /&gt;</span></span><br><span class="line">    from user</span><br><span class="line">    where username = #&#123;username,jdbcType=VARCHAR&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertSelective"</span> <span class="attr">keyColumn</span>=<span class="string">"id"</span> <span class="attr">keyProperty</span>=<span class="string">"id"</span> <span class="attr">parameterType</span>=<span class="string">"com.yukong.entity.User"</span> <span class="attr">useGeneratedKeys</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    insert into user</span><br><span class="line">    <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">"("</span> <span class="attr">suffix</span>=<span class="string">")"</span> <span class="attr">suffixOverrides</span>=<span class="string">","</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"username != null"</span>&gt;</span></span><br><span class="line">        username,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"svcNum != null"</span>&gt;</span></span><br><span class="line">        svc_num,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"password != null"</span>&gt;</span></span><br><span class="line">        `password`,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"custId != null"</span>&gt;</span></span><br><span class="line">        cust_id,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">"values ("</span> <span class="attr">suffix</span>=<span class="string">")"</span> <span class="attr">suffixOverrides</span>=<span class="string">","</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"username != null"</span>&gt;</span></span><br><span class="line">        #&#123;username,jdbcType=VARCHAR&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"svcNum != null"</span>&gt;</span></span><br><span class="line">        #&#123;svcNum,jdbcType=VARCHAR&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"password != null"</span>&gt;</span></span><br><span class="line">        #&#123;password,jdbcType=VARCHAR&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"custId != null"</span>&gt;</span></span><br><span class="line">        #&#123;custId,jdbcType=BIGINT&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这里我们定义了两个方法。</p><p>国际惯例<code>ctrl+shift+t</code>创建mapper的测试方法，并且插入一条记录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukong.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yukong.SpringbootSpringsecurityApplicationTests;</span><br><span class="line"><span class="keyword">import</span> com.yukong.entity.User;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.password.PasswordEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yukong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-04-11 16:53</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserMapperTest</span> <span class="keyword">extends</span> <span class="title">SpringbootSpringsecurityApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setUsername(<span class="string">"yukong"</span>);</span><br><span class="line">        user.setPassword(<span class="string">"abc123"</span>);</span><br><span class="line">        userMapper.insertSelective(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行测试方法，并且成功插入一条记录。</p><p>创建<code>UserController.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukong.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yukong.entity.User;</span><br><span class="line"><span class="keyword">import</span> com.yukong.mapper.UserMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yukong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-04-11 15:22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/user/&#123;username&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">hello</span><span class="params">(@PathVariable String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userMapper.selectByUsername(username);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法就是根据用户名去数据库查找用户详细信息。</p><p>启动。因为我们之前插入过一条username=yukong的记录，所以我们查询一下,访问<code>127.0.0.1:8080/user/yukong</code></p><p><img src="http://cdn.yukonga.cn/2019-05-07-060558.jpg" alt=""></p><p>我们可以看到 我们被重定向到了一个登录界面，这也是我们之前引入的<code>spring-boot-security-starter</code>起作用了。</p><p>大家可能想问了，用户名跟密码是什么，用户名默认是<code>user</code>，密码在启动的时候已经通过日志打印在控制台了。</p><p><img src="http://cdn.yukonga.cn/2019-05-07-060617.jpg" alt=""></p><p>现在我们输入用户跟密码并且登录。就可以成功访问我们想要访问的接口。</p><p><img src="http://cdn.yukonga.cn/2019-05-07-060632.jpg" alt=""></p><p>从这里我们可以知道，我只需要引入了<code>Spring-Security</code>的依赖，它就开始生效，并且保护我们的接口了，但是现在有一个问题就是，它的用户名只能是user并且密码是通过日志打印在控制台，但是我们希望它能通过数据来访问我们的用户并且判断登录。</p><p>其实想实现这个功能也很简单。这里我们需要了解两个接口。</p><ul><li>UserDetails</li><li>UserDetailsService</li></ul><p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1g1yto9h70kj30z40u0dnt.jpg" alt="UserDetails"></p><p>所以，我们需要将我们的User.java实现这个接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukong.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.GrantedAuthority;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.authority.AuthorityUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yukong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-04-11 16:50</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">UserDetails</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 主键</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 用户名</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 用户号码</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> String svcNum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 密码</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 客户id  1对1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> Long custId;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAccountNonExpired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAccountNonLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCredentialsNonExpired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSvcNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> svcNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSvcNum</span><span class="params">(String svcNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.svcNum = svcNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123;</span><br><span class="line">        <span class="comment">// 这里我们没有用到权限，所以返回一个默认的admin权限</span></span><br><span class="line">        <span class="keyword">return</span> AuthorityUtils.commaSeparatedStringToAuthorityList(<span class="string">"admin"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getCustId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> custId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCustId</span><span class="params">(Long custId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.custId = custId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们再看看<code>UserDetailsService</code></p><p><img src="http://cdn.yukonga.cn/2019-05-07-060652.jpg" alt=""></p><p>它只有一个方法的声明，就是通过用户名去查找用户信息，从这里我们应该知道了，SpringSecurity回调UserDetails#loadUserByUsername去获取用户，但是它不知道用户信息存在哪里，所以定义成接口，让使用者去实现。在我们这个项目用 我们的用户是存在了数据库中，所以我们需要调用UserMapper的方法去访问数据库查询用户信息。这里我们新建一个类叫<code>MyUserDetailsServiceImpl</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukong.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yukong.mapper.UserMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UsernameNotFoundException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yukong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-04-11 17:35</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyUserDetailServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserDetailsService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userMapper.selectByUsername(username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后新建一个类去把我们的<code>UserDetailsService</code>配置进去</p><p>这里我们新建一个<code>SecurityConfig</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukong.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.builders.HttpSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.password.PasswordEncoder;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yukong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-04-11 15:08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDetailsService userDetailsService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PasswordEncoder <span class="title">passwordEncoder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureGlobal</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 配置UserDetailsService 跟 PasswordEncoder 加密器</span></span><br><span class="line">        auth.userDetailsService(userDetailsService).passwordEncoder(passwordEncoder());</span><br><span class="line">        auth.eraseCredentials(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里我们还配置了一个<code>PasswordEncoder</code>加密我们的密码，大家都知道密码明文存数据库是很不安全的。</p><p>接下里我们插入一条记录，需要注意的是 密码需要加密。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukong.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yukong.SpringbootSpringsecurityApplicationTests;</span><br><span class="line"><span class="keyword">import</span> com.yukong.entity.User;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.password.PasswordEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yukong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-04-11 16:53</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserMapperTest</span> <span class="keyword">extends</span> <span class="title">SpringbootSpringsecurityApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PasswordEncoder passwordEncoder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setUsername(<span class="string">"yukong"</span>);</span><br><span class="line">        user.setPassword(passwordEncoder.encode(<span class="string">"abc123"</span>));</span><br><span class="line">        userMapper.insertSelective(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来启动程序，并且登录，这次只需要输入插入到数据中的那条记录的用户名跟密码即可。</p><p>在这里一节中，我们了解到如何使用springsecurity 完成一个登录功能，接下我们将通过分析源码来了解为什么需要这个配置，以及SpringSecurity的工作原理是什么。</p><p><img src="http://cdn.yukonga.cn/2019-05-07-055539.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​    什么是&lt;code&gt;SpringSecurity&lt;/code&gt; ？&lt;/p&gt;
    
    </summary>
    
      <category term="SpringSecurity" scheme="http://www.yukonga.cn/categories/SpringSecurity/"/>
    
    
      <category term="SpringBoot" scheme="http://www.yukonga.cn/tags/SpringBoot/"/>
    
      <category term="SpringSecurity" scheme="http://www.yukonga.cn/tags/SpringSecurity/"/>
    
  </entry>
  
  <entry>
    <title>56. 合并区间(Merge Intervals)</title>
    <link href="http://www.yukonga.cn/2019/01/18/56-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4-Merge-Intervals/"/>
    <id>http://www.yukonga.cn/2019/01/18/56-合并区间-Merge-Intervals/</id>
    <published>2019-01-18T08:37:47.000Z</published>
    <updated>2019-01-18T08:41:21.097Z</updated>
    
    <content type="html"><![CDATA[<p>给出一个区间的集合，请合并所有重叠的区间。</p><p><strong>示例 1:</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">6</span>],[<span class="number">8</span>,<span class="number">10</span>],[<span class="number">15</span>,<span class="number">18</span>]]</span><br><span class="line">输出: [[<span class="number">1</span>,<span class="number">6</span>],[<span class="number">8</span>,<span class="number">10</span>],[<span class="number">15</span>,<span class="number">18</span>]]</span><br><span class="line">解释: 区间 [<span class="number">1</span>,<span class="number">3</span>] 和 [<span class="number">2</span>,<span class="number">6</span>] 重叠, 将它们合并为 [<span class="number">1</span>,<span class="number">6</span>].</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">4</span>,<span class="number">5</span>]]</span><br><span class="line">输出: [[<span class="number">1</span>,<span class="number">5</span>]]</span><br><span class="line">解释: 区间 [<span class="number">1</span>,<span class="number">4</span>] 和 [<span class="number">4</span>,<span class="number">5</span>] 可被视为重叠区间。</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">解题思路：</span><br><span class="line">*  根据对象的<span class="built_in">start</span> 升序排序</span><br><span class="line">*  遍历对象列表</span><br><span class="line">*  如果当前结果列表最后一个元素<span class="keyword">end</span>比下一个元素的<span class="built_in">start</span>小   则把下一个加入到结果列表</span><br><span class="line">*  否则 将当前结果列表中最后一个元素的<span class="keyword">end</span>赋值 = <span class="built_in">max</span>(res.<span class="built_in">get</span>(<span class="keyword">last</span>()).<span class="keyword">end</span>, current.<span class="keyword">end</span>)</span><br></pre></td></tr></table></figure><p><code>java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interval</span> </span>&#123;</span><br><span class="line">          <span class="keyword">int</span> start;</span><br><span class="line">          <span class="keyword">int</span> end;</span><br><span class="line">          Interval() &#123; start = <span class="number">0</span>; end = <span class="number">0</span>; &#125;</span><br><span class="line">          Interval(<span class="keyword">int</span> s, <span class="keyword">int</span> e) &#123; start = s; end = e; &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Definition for an interval.</span></span><br><span class="line"><span class="comment">     * public class Interval &#123;</span></span><br><span class="line"><span class="comment">     *     int start;</span></span><br><span class="line"><span class="comment">     *     int end;</span></span><br><span class="line"><span class="comment">     *     Interval() &#123; start = 0; end = 0; &#125;</span></span><br><span class="line"><span class="comment">     *     Interval(int s, int e) &#123; start = s; end = e; &#125;</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Interval&gt; <span class="title">merge</span><span class="params">(List&lt;Interval&gt; intervals)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据start排序</span></span><br><span class="line">        Collections.sort(intervals, (x,y) -&gt; (x.start - y.start));</span><br><span class="line">        LinkedList&lt;Interval&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Interval inerval: intervals</span><br><span class="line">             ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (res.isEmpty() || res.peekLast().end &lt; inerval.start) &#123;</span><br><span class="line">                res.addLast(inerval);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res.peekLast().end = Math.max(inerval.end, res.peekLast().end );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>python</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for an interval.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interval</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, s=<span class="number">0</span>, e=<span class="number">0</span>)</span>:</span></span><br><span class="line">        self.start = s</span><br><span class="line">        self.end = e</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, intervals)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type intervals: List[Interval]</span></span><br><span class="line"><span class="string">        :rtype: List[Interval]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        intervals.sort(key=<span class="keyword">lambda</span> x : x.start)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> interval <span class="keyword">in</span> intervals:</span><br><span class="line">            <span class="keyword">if</span> len(res) &lt;= <span class="number">0</span> <span class="keyword">or</span> res[len(res)<span class="number">-1</span>].end &lt; interval.start:</span><br><span class="line">                res.append(interval)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res[len(res)<span class="number">-1</span>].end  = max(res[len(res)<span class="number">-1</span>].end, interval.end)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给出一个区间的集合，请合并所有重叠的区间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;],[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;],[&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;],[&lt;span class=&quot;number&quot;&gt;15&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;18&lt;/span&gt;]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: [[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;],[&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;],[&lt;span class=&quot;number&quot;&gt;15&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;18&lt;/span&gt;]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 区间 [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;] 和 [&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;] 重叠, 将它们合并为 [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;].&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;],[&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: [[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 区间 [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;] 和 [&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;] 可被视为重叠区间。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://www.yukonga.cn/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://www.yukonga.cn/tags/leetcode/"/>
    
      <category term="java" scheme="http://www.yukonga.cn/tags/java/"/>
    
      <category term="算法" scheme="http://www.yukonga.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title> 780. 到达终点 (Reaching Points)</title>
    <link href="http://www.yukonga.cn/2019/01/17/780-%E5%88%B0%E8%BE%BE%E7%BB%88%E7%82%B9-Reaching-Points/"/>
    <id>http://www.yukonga.cn/2019/01/17/780-到达终点-Reaching-Points/</id>
    <published>2019-01-17T09:10:17.000Z</published>
    <updated>2019-01-18T08:38:55.566Z</updated>
    
    <content type="html"><![CDATA[<p>从点 <code>(x, y)</code> 可以<strong>转换</strong>到 <code>(x, x+y)</code>  或者 <code>(x+y, y)</code>。</p><p>给定一个起点 <code>(sx, sy)</code> 和一个终点 <code>(tx, ty)</code>，如果通过一系列的<strong>转换</strong>可以从起点到达终点，则返回 <code>True</code>，否则返回 <code>False</code>。</p><a id="more"></a><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line">输入: sx = <span class="number">1</span>, sy = <span class="number">1</span>, tx = <span class="number">3</span>, ty = <span class="number">5</span></span><br><span class="line">输出: True</span><br><span class="line">解释:</span><br><span class="line">可以通过以下一系列转换从起点转换到终点：</span><br><span class="line">(<span class="number">1</span>, <span class="number">1</span>) -&gt; (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>) -&gt; (<span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="number">2</span>) -&gt; (<span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">输入: sx = <span class="number">1</span>, sy = <span class="number">1</span>, tx = <span class="number">2</span>, ty = <span class="number">2</span></span><br><span class="line">输出: False</span><br><span class="line"></span><br><span class="line">输入: sx = <span class="number">1</span>, sy = <span class="number">1</span>, tx = <span class="number">1</span>, ty = <span class="number">1</span></span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ul><li><code>sx, sy, tx, ty</code> 是范围在 <code>[1, 10^9]</code> 的整数。</li></ul><p>由于本题按照题目给的思路正向一步一步走下去会存在多种情况，我们可以逆向推导。反推起点，因为这样只存在两种种情况。</p><ul><li><code>if : tx &gt; ty then : tx = tx % ty</code></li><li><code>if : ty &gt; tx then : ty = ty % tx</code></li></ul><p><code>java代码</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">reachingPoints</span><span class="params">(<span class="keyword">int</span> sx, <span class="keyword">int</span> sy, <span class="keyword">int</span> tx, <span class="keyword">int</span> ty)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(tx &gt; sx &amp;&amp; ty &gt; sy) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tx &gt; ty) &#123;</span><br><span class="line">                tx = tx % ty;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ty = ty % tx;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tx == sx) &#123;</span><br><span class="line">           <span class="keyword">return</span>  (ty - sy)   % tx == <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ty == sy) &#123;</span><br><span class="line">           <span class="keyword">return</span> (tx  - sx) % ty  == <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>python代码</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reachingPoints</span><span class="params">(self, sx, sy, tx, ty)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type sx: int</span></span><br><span class="line"><span class="string">        :type sy: int</span></span><br><span class="line"><span class="string">        :type tx: int</span></span><br><span class="line"><span class="string">        :type ty: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">while</span> tx &gt; sx <span class="keyword">and</span> ty &gt; sy:</span><br><span class="line">            <span class="keyword">if</span> tx &gt; ty:</span><br><span class="line">                tx = tx % ty</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ty = ty % tx</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> tx == sx:</span><br><span class="line">             <span class="keyword">return</span> (ty - sy) % sx == <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> ty == sy:</span><br><span class="line">             <span class="keyword">return</span> (tx - sx) % sy == <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从点 &lt;code&gt;(x, y)&lt;/code&gt; 可以&lt;strong&gt;转换&lt;/strong&gt;到 &lt;code&gt;(x, x+y)&lt;/code&gt;  或者 &lt;code&gt;(x+y, y)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;给定一个起点 &lt;code&gt;(sx, sy)&lt;/code&gt; 和一个终点 &lt;code&gt;(tx, ty)&lt;/code&gt;，如果通过一系列的&lt;strong&gt;转换&lt;/strong&gt;可以从起点到达终点，则返回 &lt;code&gt;True&lt;/code&gt;，否则返回 &lt;code&gt;False&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://www.yukonga.cn/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://www.yukonga.cn/tags/leetcode/"/>
    
      <category term="java" scheme="http://www.yukonga.cn/tags/java/"/>
    
      <category term="算法" scheme="http://www.yukonga.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>基于SpringCloud Finchley.SR1 、SpringBoot 2.x、 vue、element-ui 微服务基础脚手架</title>
    <link href="http://www.yukonga.cn/2018/11/29/%E5%9F%BA%E4%BA%8ESpringCloud-Finchley-SR1-%E3%80%81SpringBoot-2-x%E3%80%81-vue%E3%80%81element-ui-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%9F%BA%E7%A1%80%E8%84%9A%E6%89%8B%E6%9E%B6/"/>
    <id>http://www.yukonga.cn/2018/11/29/基于SpringCloud-Finchley-SR1-、SpringBoot-2-x、-vue、element-ui-微服务基础脚手架/</id>
    <published>2018-11-29T07:48:17.000Z</published>
    <updated>2019-05-07T06:29:20.276Z</updated>
    
    <content type="html"><![CDATA[<p>panda是基于SpringCloud Finchley.SR1 、SpringBoot 2.x、 vue、element-ui 微服务基础脚手架<br>对于日常开发而言提供基础权限控制，动态菜单，才用前后端分离架构，前台采用vue 后台使用springcloud提供rest接口。对于以后开发，只需要在1panda-service` 添加业务模块即可，大大减少工作量。</p><a id="more"></a><h2 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h2><p>github 地址  跪求大家star<br><a href="https://github.com/YuKongEr/panda-cloud" target="_blank" rel="noopener">panda微服务工程地址</a><br><a href="https://github.com/YuKongEr/panda-admin" target="_blank" rel="noopener">panda-admin前台工程地址</a><br>panda是基于SpringCloud Finchley.SR1 、SpringBoot 2.x、 vue、element-ui 微服务基础脚手架<br>对于日常开发而言提供基础权限控制，动态菜单，才用前后端分离架构，前台采用vue 后台使用springcloud提供rest接口。对于以后开发，只需要在1panda-service` 添加业务模块即可，大大减少工作量。</p><ul><li>panda-server 服务注册中心</li><li>panda-auth  oauth2 认证服务器 提供token</li><li>panda-common 公共模块集合</li><li>panda-config-server 配置中心服务器</li><li>panda-gateway 统一网关，提供动态路由 同时也是oauth2的资源服务器</li><li>panda-service 业务模块集合<ul><li>panda-user-service 统一用户管理模块</li><li>panda-gen-service 代码生成器模块</li></ul></li></ul><p>后续会陆续支持 zipkin服务链路监控  springboot-admin 服务健康监控等</p><h2 id="技术选型文档"><a class="markdownIt-Anchor" href="#技术选型文档"></a> 技术选型&amp;文档</h2><ul><li><p>Spring Boot（<a href="https://www.jianshu.com/p/0d400d30936b" target="_blank" rel="noopener">查看Spring Boot学习&amp;使用指南</a>）</p></li><li><p>Spring Cloud（<a href="https://springcloud.cc/spring-cloud-dalston.html" target="_blank" rel="noopener">查看官方中文文档</a>）</p></li><li><p>Spring Security Oauth2（<a href="http://projects.spring.io/spring-security-oauth/docs/oauth2.html" target="_blank" rel="noopener">查看官方中文文档</a>）</p></li><li><p>MyBatis（<a href="http://www.mybatis.org/mybatis-3/zh/index.html" target="_blank" rel="noopener">查看官方中文文档</a>）</p></li><li><p>MyBatis plus（<a href="http://mp.baomidou.com/" target="_blank" rel="noopener">查看官方中文文档</a>）</p></li><li><p>Vue.js（<a href="https://cn.vuejs.org/" target="_blank" rel="noopener">查看官方中文文档</a>）</p></li><li><p>ElementUI（<a href="http://element.eleme.io/#/" target="_blank" rel="noopener">查看官方中文文档</a>）</p></li><li><p>Redis</p></li><li><p>RabbitMq</p></li><li><p>OSS</p></li></ul><h2 id="进度"><a class="markdownIt-Anchor" href="#进度"></a> 进度</h2><p><img src="http://cdn.yukonga.cn/2019-05-07-060058.jpg" alt=""></p><p><img src="http://cdn.yukonga.cn/2019-05-07-060136.jpg" alt=""><img src="http://cdn.yukonga.cn/2019-05-07-060213.jpg" alt=""></p><p><img src="http://cdn.yukonga.cn/2019-05-07-060230.jpg" alt=""></p><p><img src="http://cdn.yukonga.cn/2019-05-07-060247.jpg" alt=""></p><p><img src="http://cdn.yukonga.cn/2019-05-07-060308.jpg" alt=""></p><p><img src="http://cdn.yukonga.cn/2019-05-07-060325.jpg" alt=""></p><p><img src="http://cdn.yukonga.cn/2019-05-07-060343.jpg" alt=""></p><p><img src="http://cdn.yukonga.cn/2019-05-07-060418.jpg" alt=""></p><p><img src="http://cdn.yukonga.cn/2019-05-07-060438.jpg" alt=""></p><p><img src="http://cdn.yukonga.cn/2019-05-07-060456.jpg" alt=""></p><ul><li>[x] 登录管理<ul><li>[x] 登录</li><li>[x] 登出</li></ul></li><li>[x] 系统管理<ul><li>[x] 资源管理<ul><li>[x] 查看资源</li><li>[x] 添加资源</li><li>[x] 修改资源</li><li>[x] 删除资源</li></ul></li><li>[x] 角色管理<ul><li>[x] 查看角色</li><li>[x] 添加角色</li><li>[x] 修改角色</li><li>[x] 分配资源</li></ul></li><li>[x] 用户管理<ul><li>[x] 查看用户</li><li>[x] 添加用户</li><li>[x] 修改用户</li><li>[x] 分配角色</li></ul></li><li>[ ] 字典管理</li><li>[ ] 终端管理</li><li>[ ] 令牌管理</li></ul></li><li>[x] 日志管理<ul><li>[x] 登录日志<ul><li>[x] 查询日志</li></ul></li><li>[x] 操作日志<ul><li>[x] 查询日志</li></ul></li><li>[x] 异常日志<ul><li>[x] 查询日志</li></ul></li></ul></li><li>[x] 研发管理<ul><li>[x] 代码生成<ul><li>[x] 查询表格</li><li>[x] 生成代码</li></ul></li><li>[x] 接口文档</li></ul></li><li>[ ] 个人中心<ul><li>[ ] 查看资料</li><li>[ ] 修改资料</li></ul></li></ul><h2 id="启动教程"><a class="markdownIt-Anchor" href="#启动教程"></a> 启动教程</h2><ul><li>根据<code>init.sql</code> 创建数据库</li><li>首先启动 <code>panda-server</code> 注册中心</li><li>然后启动<code>panda-config-server</code>配置注册中心</li><li>启动统一用户服务<code>panda-user-service</code></li><li>启动认证服务<code>panda-auth</code>  以为认证服务依赖于统一用户服务，所以 统一用户服务器启动在前</li><li>最后启动<code>panda-gateway</code> 网关</li><li>然后启动前台工程  <code>npm run dev / yarn run dev</code>就可以<br>目前完成 基础权限模块，接下来会完善动态路由界面可视化配置，与个人中心模块。</li></ul><p>github 地址  跪求大家star<br><a href="https://github.com/YuKongEr/panda" target="_blank" rel="noopener">panda微服务工程地址</a><br><a href="https://github.com/YuKongEr/panda-admin" target="_blank" rel="noopener">panda-admin前台工程地址</a><br>希望大家有兴趣一起完善的可以联系我<br>最后大家关注一下我的个人公众号把。关注我公众号即可获取源码<br><img src="http://cdn.yukonga.cn/2019-05-07-055539.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;panda是基于SpringCloud Finchley.SR1 、SpringBoot 2.x、 vue、element-ui 微服务基础脚手架&lt;br&gt;
对于日常开发而言提供基础权限控制，动态菜单，才用前后端分离架构，前台采用vue 后台使用springcloud提供rest接口。对于以后开发，只需要在1panda-service` 添加业务模块即可，大大减少工作量。&lt;/p&gt;
    
    </summary>
    
      <category term="SpringCloud" scheme="http://www.yukonga.cn/categories/SpringCloud/"/>
    
    
      <category term="SpringBoot" scheme="http://www.yukonga.cn/tags/SpringBoot/"/>
    
      <category term="SpringCloud" scheme="http://www.yukonga.cn/tags/SpringCloud/"/>
    
      <category term="Vue" scheme="http://www.yukonga.cn/tags/Vue/"/>
    
      <category term="ElementUI" scheme="http://www.yukonga.cn/tags/ElementUI/"/>
    
  </entry>
  
  <entry>
    <title>【java并发编程实战6】AQS之独占锁ReentrantLock实现</title>
    <link href="http://www.yukonga.cn/2018/09/10/%E3%80%90java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%986%E3%80%91AQS%E4%B9%8B%E7%8B%AC%E5%8D%A0%E9%94%81ReentrantLock%E5%AE%9E%E7%8E%B0/"/>
    <id>http://www.yukonga.cn/2018/09/10/【java并发编程实战6】AQS之独占锁ReentrantLock实现/</id>
    <published>2018-09-10T10:11:08.000Z</published>
    <updated>2019-05-07T05:59:11.868Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>自从JDK1.5后，jdk新增一个并发工具包<code>java.util.concurrent</code>，提供了一系列的并发工具类。而今天我们需要学习的是<code>java.util.concurrent.lock</code>也就是它下面的lock包，其中有一个最为常见类<code>ReentrantLock</code>，</p><p>我们知道<code>ReentrantLock</code>的功能是实现代码段的并发访问控制，也就是通常意义上所说的锁。之前我们也学习过一种锁的实现，也就是<code>synchronized</code>关键词，<code>synchronized</code>是在字节码层面，通过对象的监视器锁实现的。那么<code>ReentrantLock</code>又是怎么实现的呢？</p><a id="more"></a><p>如果不看源码，可能会以为它的实现是通过类似于<code>synchronized</code>，通过对象的监视器锁实现的。但事实上它仅仅是一个工具类！没有使用更“高级”的机器指令，不是关键字，也不依靠JDK编译时的特殊处理，仅仅作为一个普普通通的类就完成了代码块的并发访问控制，这就更让人疑问它怎么实现的代码块的并发访问控制的了。</p><p>我们查看源码发现，它是通过继承抽象类实现的<code>AbstractQueuedSynchronizer</code>，为了方便描述，接下来我将用AQS代替<code>AbstractQueuedSynchronizer</code>。</p><h1 id="关于aqs"><a class="markdownIt-Anchor" href="#关于aqs"></a> 关于AQS</h1><blockquote><p>AQS，它是用来构建锁或者其他同步组建的基础框架，我们见过许多同步工具类都是基于它构建的。包括<code>ReentrantLock、CountDownLatch等</code>。在深入了解AQS了解之前，我们需要知道锁跟AQS的区别。锁，它是面向使用者的，它定义了使用者与锁交互的接口，隐藏了实现的细节；而AQS面像的是锁的实现者，它简化了锁的实现。锁与AQS很好的隔离使用者与实现者所需要关注的领域。那么我们今天就作为一个锁的实现者，一步一步分析锁的实现。</p></blockquote><p>AQS又称同步器，它的内部有一个int成员变量state表示同步状态，还有一个内置的FIFO队列来实现资源获取线程的排队工作。通过它们我们就能实现锁。</p><p>在实现锁之前，我们需要考虑做为锁的使用者，锁会有哪几种？</p><p>通常来说，锁分为两种，一种是独占锁(排它锁,互斥锁),另一种就是共享锁了。根据这两类，其实AQS也给我们提供了两套API。而我们作为锁的实现者，通常都是要么全部实现它的独占api，要么实现它的共享api，而不会出现一起实现的。即使juc内置的<code>ReentrantReadWriteLock</code>也是通过两个子类分别来实现的。</p><h1 id="锁的实现"><a class="markdownIt-Anchor" href="#锁的实现"></a> 锁的实现</h1><h2 id="独占锁"><a class="markdownIt-Anchor" href="#独占锁"></a> 独占锁</h2><p>独占锁又名互斥锁，同一时间，只有一个线程能获取到锁，其余的线程都会被阻塞等待。其中我们常用的<code>ReentrantLock</code>就是一种独占锁，我们一起来分<code>ReentrantLock</code> 析分析<code>ReentrantLock</code>的同时看一看AQS的实现，再推理出AQS独特的设计思路和实现方式。最后，再看其共享控制功能的实现。</p><p>首先我们来看看获取锁的过程</p><h2 id="加锁"><a class="markdownIt-Anchor" href="#加锁"></a> 加锁</h2><p>我们查看<code>ReentrantLock</code>的源码。来分析它的lock方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      sync.lock();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>与我们之前分析的一样，锁的具体实现由内部的代理类完成，lock只是暴露给锁的使用者的一套api。使用过ReentrantLock的同学应该知道，ReentrantLock又分为公平锁和非公平锁，所以，ReentrantLock内部只有两个sync的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Sync object for non-fair locks</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span></span>&#123;..&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Sync object for fair locks</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span></span>&#123;..&#125;</span><br></pre></td></tr></table></figure><ul><li>公平锁 ：每个线程获取锁的顺序是按照调用lock方法的先后顺序来的。</li><li>非公平锁：每个线程获取锁的顺序是不会按照调用lock方法的先后顺序来的。完全看运气。</li></ul><p>所以我们完全可以猜测到，这个公平与不公平的区别就体现在锁的获取过程。我们以公平锁为例，来分析获取锁过程，最后对比非公平锁的过程，寻找差异。</p><h3 id="lock"><a class="markdownIt-Anchor" href="#lock"></a> lock</h3><p>查看FairSync的lock方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           acquire(<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>这里它调用到了父类AQS的acquire方法，所以我们继续查看acquire方法的代码</p><h3 id="acquire"><a class="markdownIt-Anchor" href="#acquire"></a> acquire</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires in exclusive mode, ignoring interrupts.  Implemented</span></span><br><span class="line"><span class="comment">     * by invoking at least once &#123;<span class="doctag">@link</span> #tryAcquire&#125;,</span></span><br><span class="line"><span class="comment">     * returning on success.  Otherwise the thread is queued, possibly</span></span><br><span class="line"><span class="comment">     * repeatedly blocking and unblocking, invoking &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * #tryAcquire&#125; until success.  This method can be used</span></span><br><span class="line"><span class="comment">     * to implement method &#123;<span class="doctag">@link</span> Lock#lock&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment">     *        &#123;<span class="doctag">@link</span> #tryAcquire&#125; but is otherwise uninterpreted and</span></span><br><span class="line"><span class="comment">     *        can represent anything you like.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) </span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>查看方法方法的注释我们可以知道这个方法的作用，这里我简单的翻译一下.</p><p>Acquires方法是一个独占锁模式的方法，它是不会响应中断的。它至少执行一次tryAcquire去获取锁，如果返回true，则代表获取锁成功，否则它将会被加入等待队列阻塞，直到重新尝试获取锁成功。所以我们需要看看尝试获取锁的方法tryAcquire的实现</p><h3 id="tryacruire"><a class="markdownIt-Anchor" href="#tryacruire"></a> tryAcruire</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>抛出一个异常，没有实现。所以我们需要查看它的子类，在我们这里就是FairSync的实现。</p><blockquote><p>这里也会大家会有疑惑，没有实现为什么不写成抽象方法呢，前面我们提到过，我们不会同时在一个类中实现独占锁跟共享锁的api，那么tryAcruire是属于独占锁，那么如果我想一个共享锁也要重新独占锁的方法吗？所以大师的设计是绝对没有问题的。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>目前为止，如果获取锁成功，则返回true，获取锁的过程结束，如果获取失败，则返回false</p><p>按照之前的逻辑，如果线程获取锁失败，则会被放入到队列中，但是在放入之前，需要给线程包装一下。</p><p>那么这个addWaiter就是包装线程并且放入到队列的过程实现的方法。</p><h3 id="addwaiter"><a class="markdownIt-Anchor" href="#addwaiter"></a> addWaiter</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Creates and enqueues node for current thread and given mode.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> the new node</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">     Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">     <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">     Node pred = tail;</span><br><span class="line">     <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">         node.prev = pred;</span><br><span class="line">         <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">             pred.next = node;</span><br><span class="line">             <span class="keyword">return</span> node;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     enq(node);</span><br><span class="line">     <span class="keyword">return</span> node;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>注释: 把当前线程作为一个节点添加到队列中，并且为这个节点设置模式</p><blockquote><p>模式： 也就是独占模式/共享模式,在这里模式是形参，所以我们看看起调方</p><p><code>acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</code> Node.EXCLUSIVE 就代表这是独占锁模式。</p></blockquote><p>创建好节点后，将节点加入到队列尾部，此处，在队列不为空的时候，先尝试通过cas方式修改尾节点为最新的节点，如果修改失败，意味着有并发，这个时候才会进入enq中死循环，“自旋”方式修改。</p><p>将线程的节点接入到队里中后，当然还需要做一件事:将当前线程挂起！这个事，由acquireQueued来做。</p><p>在解释acquireQueued之前，我们需要先看下AQS中队列的内存结构，我们知道，队列由Node类型的节点组成，其中至少有两个变量，一个封装线程，一个封装节点类型。</p><p>而实际上，它的内存结构是这样的（第一次节点插入时，第一个节点是一个空节点，代表有一个线程已经获取锁，事实上，队列的第一个节点就是代表持有锁的节点）：<br><img src="https://upload-images.jianshu.io/upload_images/5338436-332432b498a8401d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="0730009.png"></p><p>黄色节点为队列默认的头节点，每次有线程竞争失败，进入队列后其实都是插入到队列的尾节点（tail后面）后面。这个从enq方法可以看出来，上文中有提到enq方法为将节点插入队列的方法:</p><h3 id="enq"><a class="markdownIt-Anchor" href="#enq"></a> enq</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node t = tail;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">                <span class="comment">// 一个空的节点，通常代表获取锁的线程</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                    tail = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node.prev = t;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    t.next = node;</span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="acquirequeued"><a class="markdownIt-Anchor" href="#acquirequeued"></a> acquireQueued</h3><p>接着我们来看看当节点被放入到队列中，如何将线程挂起，也就是看看acquireQueued方法的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">// 获取当前节点前驱结点</span></span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="comment">// 如果前驱节点是head，那么它就是等待队列中的第一个线程</span></span><br><span class="line">                <span class="comment">// 因为我们知道head就是获取线程的节点，那么它就有机会再次获取锁</span></span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    <span class="comment">//成功后，将上图中的黄色节点移除，Node1变成头节点。 也证实了head就是获取锁的线程的节点。</span></span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 1、检查前一个节点的状态，判断是否要挂起</span></span><br><span class="line">                <span class="comment">// 2、如果需要挂起，则通过JUC下的LockSopport类的静态方法park挂起当前线程，直到被唤醒。</span></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 如果发生异常</span></span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                <span class="comment">// 取消请求，也就是将当前节点重队列中移除。</span></span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里我还需要解释的是：</p><p>1、Node节点除了存储当前线程之外，节点类型，前驱后驱指针之后，还存储一个叫waitStatus的变量，该变量用于描述节点的状态。共有四种状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** waitStatus value to indicate thread has cancelled */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/** waitStatus value to indicate successor's thread needs unparking */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">/** waitStatus value to indicate thread is waiting on condition */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * waitStatus value to indicate the next acquireShared should</span></span><br><span class="line"><span class="comment">     * unconditionally propagate</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>分别表示：</p><ul><li>1 = 取消状态，该节点将会被队列移除。</li><li>-1 = 等待状态，后驱节点处于等待状态。</li><li>-2 = 等待被通知，该节点将会阻塞至被该锁的condition的await方法唤醒。</li><li>-3 = 共享传播状态，代表该节点的状态会向后传播。</li></ul><p>到此为止，一个线程对于锁的一次竞争才告于段落，结果有两种，要么成功获取到锁（不用进入到AQS队列中），要么，获取失败，被挂起，等待下次唤醒后继续循环尝试获取锁，值得注意的是，AQS的队列为FIFO队列，所以，每次被CPU假唤醒，且当前线程不是出在头节点的位置，也是会被挂起的。AQS通过这样的方式，实现了竞争的排队策略。</p><h2 id="释放锁"><a class="markdownIt-Anchor" href="#释放锁"></a> 释放锁</h2><p>看完了加锁，再看释放锁。我们先不看代码也可以猜测到释放锁需要的步骤。</p><ul><li>队列的头节点是当前获取锁的线程，所以我们需要移除头节点</li><li>释放锁，唤醒头节点后驱节点来竞争锁</li></ul><p>接下来我们查看源码来验证我们的猜想是否在正确。</p><h3 id="unlock"><a class="markdownIt-Anchor" href="#unlock"></a> unlock</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>unlock方法调用AQS的release方法，因为我们的acquire的时候传入的是1，也就是同步状态量+1，那么对应的解锁就要-1。</p><h3 id="release"><a class="markdownIt-Anchor" href="#release"></a> release</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 尝试释放锁</span></span><br><span class="line">      <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">          <span class="comment">// 释放锁成功，获取当前队列的头节点</span></span><br><span class="line">          Node h = head;</span><br><span class="line">          <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">              <span class="comment">// 唤醒当前节点的下一个节点</span></span><br><span class="line">              unparkSuccessor(h);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="tryrelease"><a class="markdownIt-Anchor" href="#tryrelease"></a> tryRelease</h3><p>同样的它是交给子类实现的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">           <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">       <span class="comment">// 当前线程不是获取锁的线程 抛出异常</span></span><br><span class="line">           <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">           <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">       <span class="comment">// 因为是重入的关系，不是每次释放锁c都等于0，直到最后一次释放锁时，才通知AQS不需要再记录哪个线程正在获取锁。</span></span><br><span class="line">           <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">               free = <span class="keyword">true</span>;</span><br><span class="line">               setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           setState(c);</span><br><span class="line">           <span class="keyword">return</span> free;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="unparksuccessor"><a class="markdownIt-Anchor" href="#unparksuccessor"></a> unparkSuccessor</h3><p>释放锁成功之后，就唤醒头节点后驱节点来竞争锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">       <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">           compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">       Node s = node.next;</span><br><span class="line">       <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           s = <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">               <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                   s = t;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">           LockSupport.unpark(s.thread);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>值得注意的是，寻找的顺序是从队列尾部开始往前去找的最前面的一个waitStatus小于0的节点。因为大于0 就是1状态的节点是取消状态。</p><h2 id="公平锁与非公平锁"><a class="markdownIt-Anchor" href="#公平锁与非公平锁"></a> 公平锁与非公平锁</h2><p>到此我们锁获取跟锁的释放已经分析的差不多。那么公平锁跟非公平锁的区别在于加锁的过程。对比代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3000897897090466540L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7316153563782823691L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Performs lock.  Try immediate barge, backing up to normal</span></span><br><span class="line"><span class="comment">         * acquire on failure.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中也可以看出来，非公平在公平锁的加锁的逻辑之前先直接cas修改一次state变量（尝试获取锁），成功就返回，不成功再排队，从而达到不排队直接抢占的目的。</p><p>欢迎大家关注一下我的个人公众号。一起交流一起学习，有问必答。<br><img src="http://cdn.yukonga.cn/2019-05-07-055539.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;自从JDK1.5后，jdk新增一个并发工具包&lt;code&gt;java.util.concurrent&lt;/code&gt;，提供了一系列的并发工具类。而今天我们需要学习的是&lt;code&gt;java.util.concurrent.lock&lt;/code&gt;也就是它下面的lock包，其中有一个最为常见类&lt;code&gt;ReentrantLock&lt;/code&gt;，&lt;/p&gt;
&lt;p&gt;我们知道&lt;code&gt;ReentrantLock&lt;/code&gt;的功能是实现代码段的并发访问控制，也就是通常意义上所说的锁。之前我们也学习过一种锁的实现，也就是&lt;code&gt;synchronized&lt;/code&gt;关键词，&lt;code&gt;synchronized&lt;/code&gt;是在字节码层面，通过对象的监视器锁实现的。那么&lt;code&gt;ReentrantLock&lt;/code&gt;又是怎么实现的呢？&lt;/p&gt;
    
    </summary>
    
      <category term="java并发编程实战" scheme="http://www.yukonga.cn/categories/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="java" scheme="http://www.yukonga.cn/tags/java/"/>
    
      <category term="多线程" scheme="http://www.yukonga.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="独占锁" scheme="http://www.yukonga.cn/tags/%E7%8B%AC%E5%8D%A0%E9%94%81/"/>
    
      <category term="AQS" scheme="http://www.yukonga.cn/tags/AQS/"/>
    
  </entry>
  
  <entry>
    <title>【java并发编程实战5】线程与线程通信</title>
    <link href="http://www.yukonga.cn/2018/09/07/%E3%80%90java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%985%E3%80%91%E7%BA%BF%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    <id>http://www.yukonga.cn/2018/09/07/【java并发编程实战5】线程与线程通信/</id>
    <published>2018-09-07T09:36:13.000Z</published>
    <updated>2019-05-07T05:59:08.364Z</updated>
    
    <content type="html"><![CDATA[<p>现代操作系统在运行一个程序，会为其创建一个进程。然后它调度的最小单元是线程，线程也叫轻量级进程(Light Weight Process)，在一个进程中可以创建多个线程，这些线程都有各自的计算器，堆，栈和局部变量</p><a id="more"></a><h2 id="线程介绍"><a class="markdownIt-Anchor" href="#线程介绍"></a> 线程介绍</h2><h3 id="线程定义"><a class="markdownIt-Anchor" href="#线程定义"></a> 线程定义</h3><blockquote><p>现代操作系统在运行一个程序，会为其创建一个进程。然后它调度的最小单元是线程，线程也叫轻量级进程(Light Weight Process)，在一个进程中可以创建多个线程，这些线程都有各自的计算器，堆，栈和局部变量，并且都能访问共享的内存变量。处理器在这些线程上高速切换，让用户感觉这些线程在同时在执行。</p></blockquote><h3 id="线程优先级"><a class="markdownIt-Anchor" href="#线程优先级"></a> 线程优先级</h3><p>在计算机操作系统，操作系统采用的是时间片轮转法来调度线程的。操作系统会为每个线程分配时间片，当线程的时间片用了，就会发生线程调度，并且等待下次分配，线程分配到的时间片的多与少就决定线程能占用cpu的时间。</p><p>线程优先级就是决定线程能分配的时间片的多与少。在java线程中，可以通过<code>priority</code>来控制线程优先级，线程优先级的范围从<code>1~10</code>。默认值是<code>5</code>，优先级大的分配的时间片会大于优先级低，所以频繁阻塞线程可以设置高优先级，而占用cpu比较长的线程（计算线程）可以设置较低的优先级。但是在有的操作系统会无视对线程有限制。</p><h3 id="线程的状态"><a class="markdownIt-Anchor" href="#线程的状态"></a> 线程的状态</h3><table><thead><tr><th style="text-align:center">状态名称</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td style="text-align:center">NEW</td><td style="text-align:center">初始状态，线程被构建，但是还没执行start()方法</td></tr><tr><td style="text-align:center">RUNNABLE</td><td style="text-align:center">运行状态，Java中将就绪与运行统称为 ”运行中“</td></tr><tr><td style="text-align:center">BLOCKED</td><td style="text-align:center">阻塞状态，表示线程阻塞与获取锁的过程</td></tr><tr><td style="text-align:center">WAITING</td><td style="text-align:center">等待状态，表示线程进入等待状态，进入该状态需要等待其他线程做出一些特定的动作（通知或者中断）</td></tr><tr><td style="text-align:center">TIME_WAITING</td><td style="text-align:center">超时等待状态，该状态不同于WAITING，它是可以在指定时间能自行返回的</td></tr><tr><td style="text-align:center">TERMINATED</td><td style="text-align:center">终止状态，表示当前下才能已经执行完成</td></tr></tbody></table><p>下面就用代码演示各种方法时线程的状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadState</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> TimeWaiting(), <span class="string">"TimeWaitingThread"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Waiting(), <span class="string">"WaitingThread"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Blocked(), <span class="string">"BlockedThread - 1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Blocked(), <span class="string">"BlockedThread - 2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeWaitnging</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                  TimeUnit.SECONDS.sleep(<span class="number">1000L</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Waitnging</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span>(Waiting.class) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Waiting.class.wait()</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Blocked</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Blocked.class) &#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                          TimeUnit.SECONDS.sleep(<span class="number">1000L</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java中线程状态的变迁如下图</p><p><img src="https://upload-images.jianshu.io/upload_images/5338436-fb8fa816ef0dde42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1536140160461.png"></p><h2 id="线程通信"><a class="markdownIt-Anchor" href="#线程通信"></a> 线程通信</h2><h3 id="通知等待机制"><a class="markdownIt-Anchor" href="#通知等待机制"></a> 通知等待机制</h3><p>首先我们需要了解一下wait()与notify方法</p><ul><li>wait() 调用该方法的线程会进入WAITING状态，只有等待另外线程通知或者被中断才能返回，wait方法会释放对象锁</li><li>wait(long) 调用该方法的线程会进入TIME_WAITING状态， 超过等待一段时间，参数单位是毫秒，意味着等待n毫秒后，如果没有通知就返回</li><li>wait(long, int) 控制跟粒度更细，到纳秒</li><li>notify) 通知一个在此对象上等待的线程，从其从wait()方法返回，返回的前提是该线程获取到了对象的线程锁。</li><li>notifyAll() 通知在此对象上等待的所有线程。</li></ul><p>现在我们可以通过 <code>synchronized+wait+notify</code>来实现一个简单的<code>通知\等待模型</code></p><ul><li>等待方（消费者）</li></ul><p>1）获取对象锁</p><p>2）如果条件不满足，那么调用对象的wait()方法，被通知依旧要检查条件。</p><p>3）条件满足则执行对应的逻辑</p><p>伪代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(对象) &#123;</span><br><span class="line">    <span class="keyword">while</span> (条件不满足) &#123;</span><br><span class="line">        对象.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    处理对应逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通知方法 (生产者)</li></ul><p>1）获取对象锁</p><p>2）改变条件</p><p>3）通知所有等在在此对象上的线程</p><p>对应伪代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(对象) &#123;</span><br><span class="line">    改变条件</span><br><span class="line">    对象.notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据上面的通知等待机制，我们可以实现一个简单的线程池。</p><p>首先我们先定义一下线程池的接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yukong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/9/5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 线程池接口，抽象出来，定义规范</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ThreadPool</span>&lt;<span class="title">Job</span> <span class="keyword">extends</span> <span class="title">Runnable</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行任务，这个任务需要继承Runnable接口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> job 任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Job job)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加工作者数目</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num 要添加的数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addWorkers</span><span class="params">(<span class="keyword">int</span> num)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 减少工作者数目</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num 要减少的数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeWorks</span><span class="params">(<span class="keyword">int</span> num)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取正在等待执行的任务数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getJobCount</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后编写一个实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yukong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/9/5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultThreadPool</span>&lt;<span class="title">Job</span> <span class="keyword">extends</span> <span class="title">Runnable</span>&gt; <span class="keyword">implements</span> <span class="title">ThreadPool</span>&lt;<span class="title">Job</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池最大数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_WORKER_NUMBERS = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池默认数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_WORKER_NUMBERS = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池最小数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_WORKER_NUMBERS = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 任务队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LinkedList&lt;Job&gt;  jobs = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工作者列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Worker&gt; workers = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工作者线程数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> workerNum = DEFAULT_WORKER_NUMBERS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程编号生成</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger threadNum = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultThreadPool</span><span class="params">(<span class="keyword">int</span> workerNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.workerNum = workerNum &gt; MAX_WORKER_NUMBERS ? MAX_WORKER_NUMBERS</span><br><span class="line">                : workerNum &lt; MIN_WORKER_NUMBERS ? MIN_WORKER_NUMBERS</span><br><span class="line">                : workerNum;</span><br><span class="line">        initializeWorkers(<span class="keyword">this</span>.workerNum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initializeWorkers</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            Worker worker = <span class="keyword">new</span> Worker();</span><br><span class="line">            workers.add(worker);</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(worker, <span class="string">"ThreadPool-Worker-"</span> + threadNum.incrementAndGet());</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Job job)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (job != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (jobs) &#123;</span><br><span class="line">                jobs.addLast(job);</span><br><span class="line">                jobs.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Worker worker: workers) &#123;</span><br><span class="line">            worker.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addWorkers</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">synchronized</span> (jobs) &#123;</span><br><span class="line">           <span class="comment">// 限制新增的数目与已有的数目之和超过最大数</span></span><br><span class="line">           <span class="keyword">if</span> (num + <span class="keyword">this</span>.workerNum&gt; MAX_WORKER_NUMBERS) &#123;</span><br><span class="line">               num = MAX_WORKER_NUMBERS - <span class="keyword">this</span>.workerNum;</span><br><span class="line">           &#125;</span><br><span class="line">           initializeWorkers(num);</span><br><span class="line">           <span class="keyword">this</span>.workerNum += num;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeWorks</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (jobs) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &gt; <span class="keyword">this</span>.workerNum) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"beyond workNum"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (count &lt; num) &#123;</span><br><span class="line">                Worker worker = workers.get(count);</span><br><span class="line">                <span class="keyword">if</span> (workers.remove(worker)) &#123;</span><br><span class="line">                    worker.shutdown();</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.workerNum -= num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getJobCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jobs.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> Boolean running = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (running) &#123;</span><br><span class="line">                Job job = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">synchronized</span> (jobs) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (jobs.isEmpty()) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            jobs.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            <span class="comment">// 设置中断标记，让外界感知</span></span><br><span class="line">                            Thread.currentThread().interrupt();</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    job = jobs.removeFirst();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (job != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    job.run();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            running = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此我们就实现了一个简单的线程池了。</p><p>欢迎大家关注一下我的个人公众号。一起交流一起学习，有问必答。<br><img src="http://cdn.yukonga.cn/2019-05-07-055539.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现代操作系统在运行一个程序，会为其创建一个进程。然后它调度的最小单元是线程，线程也叫轻量级进程(Light Weight Process)，在一个进程中可以创建多个线程，这些线程都有各自的计算器，堆，栈和局部变量&lt;/p&gt;
    
    </summary>
    
      <category term="java并发编程实战" scheme="http://www.yukonga.cn/categories/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="java" scheme="http://www.yukonga.cn/tags/java/"/>
    
      <category term="多线程" scheme="http://www.yukonga.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="线程通信" scheme="http://www.yukonga.cn/tags/%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>【java并发编程实战4】偏向锁-轻量锁-重量锁的那点秘密synchronize实现原理</title>
    <link href="http://www.yukonga.cn/2018/09/07/%E3%80%90java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%984%E3%80%91%E5%81%8F%E5%90%91%E9%94%81-%E8%BD%BB%E9%87%8F%E9%94%81-%E9%87%8D%E9%87%8F%E9%94%81%E7%9A%84%E9%82%A3%E7%82%B9%E7%A7%98%E5%AF%86synchronize%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://www.yukonga.cn/2018/09/07/【java并发编程实战4】偏向锁-轻量锁-重量锁的那点秘密synchronize实现原理/</id>
    <published>2018-09-07T00:26:12.000Z</published>
    <updated>2019-05-07T06:24:00.818Z</updated>
    
    <content type="html"><![CDATA[<p>在多线程并发编程中，synchronized一直都是元老级别的角色，人们都通常称呼它为<strong>重量锁</strong>，但是在jdk1.6版本之后，jdk就对synchronized做了大量的优化，这时候我们就不能称呼它为重量锁了，有的时候它也是很<strong>轻</strong>的，那么接下来我们就调调，synchronized是怎么被优化的，它跟偏向锁、轻量锁、重量锁又有什么渊源。</p><a id="more"></a><h1 id="synchronized"><a class="markdownIt-Anchor" href="#synchronized"></a> synchronized</h1><p>回顾一下synchronized是怎么使用的呢。</p><h2 id="1-同步普通方法"><a class="markdownIt-Anchor" href="#1-同步普通方法"></a> 1、同步普通方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span>  <span class="title">sync1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do somethings</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该方法中，synchronized锁的是当前实例的对象</p><h2 id="2-同步静态方法"><a class="markdownIt-Anchor" href="#2-同步静态方法"></a> 2、同步静态方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sync2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do somethings</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于该方法是一个静态方法，那么它锁的当前类的class对象。</p><h2 id="3-同步方法快"><a class="markdownIt-Anchor" href="#3-同步方法快"></a> 3、同步方法快</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sync3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// do somethings</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sync4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(MyTest.css) &#123;</span><br><span class="line">        <span class="comment">// do somethings</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么同步方法快是需要根据方法中具体同步的对象来实现的。</p><p>在上面代码中其实<code>sync3()</code>跟同步普通方法一样，锁的是当前实例对象；那么<code>sync4</code>方法就与同步静态方法一样，锁的是当前类的class对象。</p><p>从上面代码可以看出来的，我们通过使用<code>synchronized</code>关键字可以很简单的解决并发问题，但是其实是jvm底层通过使用一种叫内置锁的手段，简化了开发人员实现并发的复杂度，在jdk1.6以前 synchronized是基于重量锁实现的，即每次遇到同步代码都要获取锁，然后释放锁，在jdk1.6之后对其优化，根据不同场景使用不同的策略，这也就是 偏向锁、轻量锁、重量锁的来由。在介绍他们之前我先介绍一下另一个锁-自旋锁。听到这么多锁，是不是头晕，当初我学习的时候也是这样的。但是当你慢慢学习深入，你就会很容易的理解每个锁的作用。</p><h1 id="自旋锁"><a class="markdownIt-Anchor" href="#自旋锁"></a> 自旋锁</h1><p>自旋锁顾名思义，就是自己旋转转圈等待，那么它有什么作用呢？</p><ul><li>当前线程尝试去竞争锁</li><li>竞争失败，准备阻塞自己</li><li>但是并没有阻塞自己，而是采用自旋锁，进入自旋状态</li><li>进入自旋状态，并且重新不断竞争锁</li><li>如果在自旋期间成功获取锁，那么结束自旋状态，否则进入阻塞状态</li></ul><blockquote><p>如果在自旋期间成功获取锁，那么就减少一次线程的切换。</p></blockquote><p>根据上面解释我们可以很容易的明白自旋锁的意义，因为cpu从内核态切换至用户态，线程的阻塞与恢复会浪费资源的，但是通过自旋而不是去阻塞当前线程，那么就会节省这个一个cpu状态切换。</p><p>所以自旋锁适合在** 持有锁的时间长，且竞争不激烈**的场景下使用。</p><blockquote><p>使用-XX:-UseSpinning参数关闭自旋锁优化；-XX:PreBlockSpin参数修改默认的自旋次数</p></blockquote><h1 id="偏向锁"><a class="markdownIt-Anchor" href="#偏向锁"></a> 偏向锁</h1><p>在实际场景中，如果一个同步方法，没有多线程竞争，并且总是由同一个线程多次获取锁，如果每次还有阻塞线程，唤醒cpu从用户态转核心态，那么对于cpu是一种资源的浪费，为了解决这类问题，旧引入了偏向锁的概念。</p><p>“偏向”的意思是，<em>偏向锁假定将来只有第一个申请锁的线程会使用锁</em>（不会有任何线程再来申请锁），因此，<em>只需要在Mark Word中CAS记录owner（本质上也是更新，但初始值为空），如果记录成功，则偏向锁获取成功</em>，记录锁状态为偏向锁，<em>以后当前线程等于owner就可以零成本的直接获得锁；否则，说明有其他线程竞争，膨胀为轻量级锁</em>。</p><p>具体的步骤如下</p><ul><li><p>访问同步代码块</p></li><li><p>检查对象头是否owner是否存储当前现成的id</p></li><li><p>如果没有，进行CAS尝试替换mark word中的owner  如果有执行同步代码（代表获取锁成功）</p></li><li><p>修改成功 （代表无竞争）owner修改为当前线程id,执行同步代码 修改失败(代表有竞争) 进入撤销偏向锁，暂停线程并将owner置空，进入轻量锁。</p></li></ul><p><img src="http://cdn.yukonga.cn/2019-05-07-062340.jpg" alt=""></p><p>偏向锁无法使用自旋锁优化，因为一旦有其他线程申请锁，就破坏了偏向锁的假定。</p><blockquote><p>如果你确定应用程序中所有的锁通常是在竞争状态，你可以通过JVM参数关闭偏向锁</p><p>UseBiasedLocking = false，那么程序会默认进入轻量锁状态。</p></blockquote><h1 id="轻量锁"><a class="markdownIt-Anchor" href="#轻量锁"></a> 轻量锁</h1><p>如果说偏向锁是为了解决同步代码在单线程下访问性能问题，那么轻量锁是为了解决<strong>减少无实际竞争情况下，使用重量级锁产生的性能消耗</strong></p><p>轻量锁，顾名思义，轻量是相对于重量的问题，使用轻量锁时，不需要申请互斥量(mutex)</p><p>,而是将mark word中的信息复制到当前线程的栈中，然后通过cas尝试修改mark word并替换成轻量锁，如果替换成功则执行同步代码。如果此时有线程2来竞争，并且他也尝试cas修改mark word但是失败了，那么线程2会进入自旋状态，如果在自旋状态也没有修改成功，那么轻量锁将膨胀成状态，mark word会被修改成重量锁标记(10) ,线程进入阻塞状态。</p><p>当然，由于轻量级锁天然瞄准不存在锁竞争的场景，如果存在锁竞争但不激烈，仍然可以用自旋锁优化，<em>自旋失败后再膨胀为重量级锁</em>。</p><h1 id="重量锁"><a class="markdownIt-Anchor" href="#重量锁"></a> 重量锁</h1><p>在jvm规范中，synchronized是基于监视器锁(monitor)来实现的，它会在同步代码之前添加一个<code>monitorenter</code>指令，获取到该对象的monitor，同时它会在同步代码结束处和异常处添加一个<code>monitorexit</code>指令去释放该对象的monitor,需要注意的是每一个对象都有一个monitor与之配对，当一个monitor被获取之后 也就是被<code>monitorenter</code>，它会处于一个锁定状态，其他尝试获取该对象的monitor的线程会获取失败，只有当获取该对象的monitor的线程执行了<code>monitorexit</code>指令后，其他线程才有可能获取该对象的monitor成功。</p><p>所以从上面描述可以得出，监视器锁就是<code>monitor</code>它是互斥的(mutex)。由于它是互斥的，那么它的操作成本就非常的高，包括系统调用引起的内核态与用户态切换、线程阻塞造成的线程切换等。因此，后来称这种锁为“重量级锁”。</p><h1 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h1><p>偏向锁、轻量级锁、重量级锁适用于不同的并发场景：</p><ul><li>偏向锁：无实际竞争，且将来只有第一个申请锁的线程会使用锁。</li><li>轻量级锁：无实际竞争，多个线程交替使用锁；允许短时间的锁竞争。</li><li>重量级锁：有实际竞争，且锁竞争时间长。</li></ul><p>另外，如果锁竞争时间短，可以使用自旋锁进一步优化轻量级锁、重量级锁的性能，减少线程切换。</p><p>如果锁竞争程度逐渐提高（缓慢），那么从偏向锁逐步膨胀到重量锁，能够提高系统的整体性能。<br>同时需要注意<strong>锁可以升级，但是不能降级</strong>。</p><p>另外通过这次学习，大家应该也知道自从jdk1.6以后 <code>synchronized</code>已经被优化了，性能不会比<code>Lock</code>差</p><p>所以jdk.16版本及其以后版本的同学可以放心大胆的使用了。</p><p>最后附一张从偏向锁膨胀至重量锁的完全的流程图</p><p><img src="http://cdn.yukonga.cn/2019-05-07-062353.jpg" alt=""></p><p>欢迎大家关注一下我的个人公众号。一起交流一起学习，有问必答。</p><p><img src="http://cdn.yukonga.cn/2019-05-07-055539.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在多线程并发编程中，synchronized一直都是元老级别的角色，人们都通常称呼它为&lt;strong&gt;重量锁&lt;/strong&gt;，但是在jdk1.6版本之后，jdk就对synchronized做了大量的优化，这时候我们就不能称呼它为重量锁了，有的时候它也是很&lt;strong&gt;轻&lt;/strong&gt;的，那么接下来我们就调调，synchronized是怎么被优化的，它跟偏向锁、轻量锁、重量锁又有什么渊源。&lt;/p&gt;
    
    </summary>
    
      <category term="java并发编程实战" scheme="http://www.yukonga.cn/categories/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="java" scheme="http://www.yukonga.cn/tags/java/"/>
    
      <category term="多线程" scheme="http://www.yukonga.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="synchronized" scheme="http://www.yukonga.cn/tags/synchronized/"/>
    
  </entry>
  
  <entry>
    <title>【SpringBoot2.0系列11】SpringBoot之@Elasticsearch完成CURD</title>
    <link href="http://www.yukonga.cn/2018/09/04/%E3%80%90SpringBoot2-0%E7%B3%BB%E5%88%9711%E3%80%91SpringBoot%E4%B9%8B-Elasticsearch%E5%AE%8C%E6%88%90CURD/"/>
    <id>http://www.yukonga.cn/2018/09/04/【SpringBoot2-0系列11】SpringBoot之-Elasticsearch完成CURD/</id>
    <published>2018-09-04T10:37:47.000Z</published>
    <updated>2019-05-07T06:07:34.476Z</updated>
    
    <content type="html"><![CDATA[<p>ElasticSearch是一个基于Lucene的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。Elasticsearch是用Java开发的，并作为Apache许可条款下的开放源码发布，是当前流行的企业级搜索引擎。设计用于<a href="https://baike.baidu.com/item/%E4%BA%91%E8%AE%A1%E7%AE%97/9969353" target="_blank" rel="noopener">云计算</a>中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。</p><a id="more"></a><p>如果在springboot使用Easticsearch呢。在这里我们使用spring-boot-starter-data-elasticsearch。<br>它提供一系列简单的api给我们使用，让我们有种操作关系数据库的感觉。<br>好了话不多说，先说一下环境。</p><ul><li>spring boot2.x</li><li>jdk8</li><li>elasticsearch5.x(6.x也可以)</li></ul><h2 id="依赖"><a class="markdownIt-Anchor" href="#依赖"></a> 依赖</h2><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">&lt;!-- lombok --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.16.22<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- elasticsearch --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-elasticsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这里我们分别引入elasticsearch跟lombok的依赖，关于lombok的介绍大家可以看看<a href="https://blog.csdn.net/motui/article/details/79012846" target="_blank" rel="noopener">这篇文章</a> 讲的很详细。我这简单的介绍一下在项目中使用Lombok可以减少很多重复代码的书写。比如说getter/setter/toString等方法的编写。</p><h2 id="配置es地址"><a class="markdownIt-Anchor" href="#配置es地址"></a> 配置es地址</h2><p>在下文中我将用es代替elasticsearch。我们打开application.yml文件 配置如下</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line"><span class="attr">  elasticsearch:</span></span><br><span class="line">    <span class="comment"># 集群的名字</span></span><br><span class="line"><span class="attr">    cluster-name:</span> <span class="string">wali</span></span><br><span class="line">    <span class="comment"># 节点的ip与端口 注意端口是9300不是9200</span></span><br><span class="line"><span class="attr">    cluster-nodes:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9300</span></span><br></pre></td></tr></table></figure><h2 id="构建文档对象"><a class="markdownIt-Anchor" href="#构建文档对象"></a> 构建文档对象</h2><p>假设这是一个商品索引goods，他有一个类型是电脑computer。<br>分别有四个字段</p><ul><li>id  唯一标识</li><li>name 商品名称</li><li>number 商品数量</li><li>desc 商品具体描述<br>我们根据上面的描述，编写出对应的实体类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@Accessors</span>(chain = <span class="keyword">true</span>)</span><br><span class="line"><span class="meta">@Document</span>(indexName = <span class="string">"goods"</span>, type = <span class="string">"computer"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Good</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 主键,注意这个搜索是id类型是string，与我们常用的不同</span></span><br><span class="line"><span class="comment">     * Id注解加上后，在Elasticsearch里相应于该列就是主键了，在查询时就可以直接用主键查询</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer number;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>@Data @ToString @Accessors(chain = true)</code> 是属于lombok注解。</p><ul><li>@Data 会自动上传get/set方法</li><li>@ToString 会生成tostring方法</li><li>@Accessors(chain = true) 会让我们set方法可以链式调用<br>@Document注解</li></ul><p><code>@Document</code>注解里面的几个属性，类比mysql的话是这样：<br>indexName –&gt; 索引库的名称，建议以项目的名称命名，就相当于数据库DB<br>type –&gt; 类型，建议以实体的名称命名Table ，就相当于数据库中的表table<br>Document –&gt; row 就相当于某一个具体对象</p><h2 id="jpa构建文档库"><a class="markdownIt-Anchor" href="#jpa构建文档库"></a> jpa构建文档库</h2><p>接着，我们可以通过jpa构建文档库，来操作我们的goods对应的文档。<br>因为我们引入的是spring data的elasticsearch所以它遵循spring data的接口，也就是说操作elasticSearch与操作spring data jpa的方法是完全一样的，我们只将文档库继承ElasticsearchRepository即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GoodRepository</span> <span class="keyword">extends</span> <span class="title">ElasticsearchRepository</span>&lt;<span class="title">Good</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据商品名称查询 分页</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pageable</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Page&lt;Good&gt; <span class="title">findByName</span><span class="params">(String name, Pageable pageable)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后创建对应的测试类。前面说过快捷键<code>ctrl+shift+t</code><br>并且编写测试方法，我们分别需要测试添加 删除 修改  查询 分页查询方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@FixMethodOrder</span>(MethodSorters.NAME_ASCENDING)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoodRepositoryTest</span> <span class="keyword">extends</span> <span class="title">Chapter10ApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> GoodRepository goodRepository;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findByName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码我们是通过基础<code>主测试类</code>然后使用<code>@Component</code>注解就可以，这样就不需要每个测试都要<code>@SpringTest注解与@RunWith注解了</code><br>另外<code>@FixMethodOrder(MethodSorters.NAME_ASCENDING)</code>这个注解是表示按照方法名的顺序来排序，不然它不会按照我们方法书写的顺序执行，那么就有可能导致，还没save就select，这样就会失败了。<br>接下来继续编写方法体。<code>goodRepository</code>跟我们直接<code>data-jpa</code>的<code>respository</code>用法基本一致。都有继承<code>save,delete,find</code>方法的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Good good = <span class="keyword">new</span> Good();</span><br><span class="line">        good.setId(<span class="string">"100"</span>)</span><br><span class="line">                .setName(<span class="string">"联想e541"</span>)</span><br><span class="line">                .setDesc(<span class="string">"联想e系列"</span>)</span><br><span class="line">                .setNumber(<span class="number">10</span>);</span><br><span class="line">        Good result = goodRepository.save(good);</span><br><span class="line">        Assert.assertNotNull(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 需要注意find方法返回的死Optional对象 需要调用get方法返回具体的实体类对象</span></span><br><span class="line">        Good result = goodRepository.findById(<span class="string">"100"</span>).get();</span><br><span class="line">        Assert.assertNotNull(result);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Good result = goodRepository.findById(<span class="string">"100"</span>).get();</span><br><span class="line">        result.setNumber(<span class="number">300</span>);</span><br><span class="line">        <span class="comment">// 更新也是调用save方法</span></span><br><span class="line">        Good good = goodRepository.save(result);</span><br><span class="line">        Assert.assertNotNull(good);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span></span>&#123;</span><br><span class="line">        goodRepository.deleteById(<span class="string">"100"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们首先测试增删改查方法。并且通过Assert断言来判断。</p><p><img src="https://upload-images.jianshu.io/upload_images/5338436-7cfb53c208dcaab7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>测试通过，<br>接下来我测试一下分页查询方法，首页我们看一下es中、goods索引computer类别下有哪些文档。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET  <span class="string">'http://127.0.0.1:9200/goods/computer/_search?pretty'</span></span><br></pre></td></tr></table></figure><p>结果如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"took"</span> : <span class="number">21</span>,</span><br><span class="line">  <span class="attr">"timed_out"</span> : <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"_shards"</span> : &#123;</span><br><span class="line">    <span class="attr">"total"</span> : <span class="number">5</span>,</span><br><span class="line">    <span class="attr">"successful"</span> : <span class="number">5</span>,</span><br><span class="line">    <span class="attr">"skipped"</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"failed"</span> : <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"hits"</span> : &#123;</span><br><span class="line">    <span class="attr">"total"</span> : <span class="number">3</span>,</span><br><span class="line">    <span class="attr">"max_score"</span> : <span class="number">1.0</span>,</span><br><span class="line">    <span class="attr">"hits"</span> : [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"_index"</span> : <span class="string">"goods"</span>,</span><br><span class="line">        <span class="attr">"_type"</span> : <span class="string">"computer"</span>,</span><br><span class="line">        <span class="attr">"_id"</span> : <span class="string">"_search"</span>,</span><br><span class="line">        <span class="attr">"_score"</span> : <span class="number">1.0</span>,</span><br><span class="line">        <span class="attr">"_source"</span> : &#123;</span><br><span class="line">          <span class="attr">"id"</span> : <span class="string">"_search"</span>,</span><br><span class="line">          <span class="attr">"name"</span> : <span class="string">"macbook"</span>,</span><br><span class="line">          <span class="attr">"number"</span> : <span class="number">20</span>,</span><br><span class="line">          <span class="attr">"desc"</span> : <span class="string">"macbook air"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"_index"</span> : <span class="string">"goods"</span>,</span><br><span class="line">        <span class="attr">"_type"</span> : <span class="string">"computer"</span>,</span><br><span class="line">        <span class="attr">"_id"</span> : <span class="string">"2"</span>,</span><br><span class="line">        <span class="attr">"_score"</span> : <span class="number">1.0</span>,</span><br><span class="line">        <span class="attr">"_source"</span> : &#123;</span><br><span class="line">          <span class="attr">"id"</span> : <span class="string">"2"</span>,</span><br><span class="line">          <span class="attr">"name"</span> : <span class="string">"think pad"</span>,</span><br><span class="line">          <span class="attr">"number"</span> : <span class="number">20</span>,</span><br><span class="line">          <span class="attr">"desc"</span> : <span class="string">"联想旗下thinkpad系列"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"_index"</span> : <span class="string">"goods"</span>,</span><br><span class="line">        <span class="attr">"_type"</span> : <span class="string">"computer"</span>,</span><br><span class="line">        <span class="attr">"_id"</span> : <span class="string">"1"</span>,</span><br><span class="line">        <span class="attr">"_score"</span> : <span class="number">1.0</span>,</span><br><span class="line">        <span class="attr">"_source"</span> : &#123;</span><br><span class="line">          <span class="attr">"id"</span> : <span class="string">"1"</span>,</span><br><span class="line">          <span class="attr">"name"</span> : <span class="string">"macbook"</span>,</span><br><span class="line">          <span class="attr">"number"</span> : <span class="number">20</span>,</span><br><span class="line">          <span class="attr">"desc"</span> : <span class="string">"macbook pro"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我看到在computer类别中存有三条文档，name分别是 <code>macbook</code> <code>think pad</code> <code>macbook</code>,所以我们查询一下name=macbook的文档，pageSize=1,pageNum=1.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findByName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String name = <span class="string">"macbook"</span>;</span><br><span class="line">        Pageable pageable = <span class="keyword">new</span> PageRequest(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        Page&lt;Good&gt; goods = goodRepository.findByName(name, pageable);</span><br><span class="line">        System.out.println(goods.getContent());</span><br><span class="line">        Assert.assertEquals(<span class="number">1</span>, goods.getSize());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们查询name为macbook的数据，并且限制每页一条，所以我们查询的结果总数应该是一条。结果如下。<br><img src="http://cdn.yukonga.cn/2019-05-07-060723.jpg" alt=""></p><p>在这节，我们了解了springboot与es的curd操作，都是比较简单的，那么下节我们会详细了解springboot对es如何进行复杂查询，与聚合查询。<br>最后本节的配套代码地址为<a href="https://github.com/YuKongEr/SpringBoot-Study/tree/master/chapter10" target="_blank" rel="noopener">https://github.com/YuKongEr/SpringBoot-Study/tree/master/chapter10</a></p><p>最后欢迎大家关注一下我的个人公众号。一起交流一起学习，有问必答。<br><img src="http://cdn.yukonga.cn/2019-05-07-055539.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ElasticSearch是一个基于Lucene的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。Elasticsearch是用Java开发的，并作为Apache许可条款下的开放源码发布，是当前流行的企业级搜索引擎。设计用于&lt;a href=&quot;https://baike.baidu.com/item/%E4%BA%91%E8%AE%A1%E7%AE%97/9969353&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;云计算&lt;/a&gt;中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。&lt;/p&gt;
    
    </summary>
    
      <category term="SpringBoot" scheme="http://www.yukonga.cn/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="http://www.yukonga.cn/tags/SpringBoot/"/>
    
      <category term="ElasticSearch" scheme="http://www.yukonga.cn/tags/ElasticSearch/"/>
    
  </entry>
  
  <entry>
    <title>【java并发编程实战3】解密volatile</title>
    <link href="http://www.yukonga.cn/2018/09/03/%E3%80%90java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%983%E3%80%91%E8%A7%A3%E5%AF%86volatile/"/>
    <id>http://www.yukonga.cn/2018/09/03/【java并发编程实战3】解密volatile/</id>
    <published>2018-09-03T11:19:22.000Z</published>
    <updated>2019-05-07T06:24:45.274Z</updated>
    
    <content type="html"><![CDATA[<p>自从jdk1.5以后，<code>volatile</code>可谓发生了翻天覆地的变化，从一个一直被吐槽的关键词，变成一个轻量级的线程通信代名词。</p><a id="more"></a><p>接下来我们将从以下几个方面来分析以下<code>volatile</code>。</p><ul><li><p>重排序与<code>as if serial</code>的关系</p></li><li><p><code>volatile</code>的特点</p></li><li><p><code>volatile</code>的内存语义</p></li><li><p><code>volatile</code>的使用场景</p></li></ul><h2 id="重排序与as-if-serial的关系"><a class="markdownIt-Anchor" href="#重排序与as-if-serial的关系"></a> 重排序与as if serial的关系</h2><p>重排序值得是编译器与处理器为了优化程序的性能，而对指令序列进行重新排序的。</p><p>但是并不是什么情况下都可以重排序的，</p><ul><li><p>数据依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span>;<span class="comment">// 1</span></span><br><span class="line">b = <span class="number">2</span>;<span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>在这种情况，1、2不存在数据依赖，是可以重排序的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span>;<span class="comment">// 1</span></span><br><span class="line">b = a;<span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>在这种情况，1、2存在数据依赖，是禁止重排序的。</p></li><li><p><code>as if serial</code></p><p>简单的理解就是。不管怎么重排序，在单线程情况下程序的执行结果是一致。</p></li></ul><p>根据 <code>as if serial</code>原则，它强调了单线程。那么多线程发生重排序又是怎么样的呢？</p><p>请看下面代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileExample1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 共享变量 name</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String name = <span class="string">"init"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 共享变量 flag</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread threadA = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            name = <span class="string">"yukong"</span>;<span class="comment">// 1</span></span><br><span class="line">            flag = <span class="keyword">true</span>;<span class="comment">// 2</span></span><br><span class="line">        &#125;);</span><br><span class="line">        Thread threadB = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;   <span class="comment">// 3</span></span><br><span class="line">                System.out.println(<span class="string">"flag = "</span> + flag + <span class="string">" name = "</span> +name);  <span class="comment">// 4</span></span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，name输出一定是<code>yukong</code>吗，答案是不一定，根据<code>happen-before</code>原则与<code>as if serial</code></p><p>原则，由于 1、2不存在依赖关系，可以重排序，操作3、操作4也不存在数据依赖，也可以重排序。</p><p>那么就有可能发生下面的情况</p><p><img src="http://cdn.yukonga.cn/2019-05-07-062415.jpg" alt=""></p><p>上图中，操作1与操作2发生了重排序，程序运行的时候，线程A先将flag更改成true，然后线程B读取flag变量并且判断，由于此时flag已经是true，线程B将继续读取name的值，由于此时线程name的值还没有被线程A写入，那么线程此时输出的name就是初始值，因为在多线程的情况下，重排序存在线程安全问题。</p><h2 id="volatile的特点"><a class="markdownIt-Anchor" href="#volatile的特点"></a> volatile的特点</h2><p><code>volatile</code>变量具有以下的特点。</p><ul><li>可见性。对于一个<code>volatile</code>变量的读，总是能看到任意线程对这个变量的最后的修改。</li><li>有序性。对于存在指令重排序的情况，<code>volatile</code>会禁止部分指令重排序。</li></ul><p>这里我先介绍一下<code>volatile</code>关键词的特点，接下来我们将会从它的内存语义来解释，为什么它会具有以上的特点，以及它使用的场景。</p><h2 id="volatile的内存语义"><a class="markdownIt-Anchor" href="#volatile的内存语义"></a> volatile的内存语义</h2><ul><li>当写一个<code>volatile</code>变量时，JMM会<strong>立即</strong>将本地变量中对应的共享变量值刷新到主内存中。</li><li>当读一个<code>volatile</code>变量时，JMM会将线程本地变量存储的值，置为无效值，线程接下来将从主内存中读取共享变量。</li></ul><p>如果一个场景存在对<code>volatile</code>变量的读写场景，在读线程B读一个<code>volatile</code>变量后，，写线程A在写这个<code>volatile</code>变量前所有的所见的共享变量的值都将会立即变得对读线程B可见。</p><p>那么这种内存语义是怎么实现的呢？</p><p>其实编译器生产字节码的时候，会在指令序列中插入内存屏障来禁止指令排序。下面就是JMM内存屏障插入的策略。</p><ul><li>在每一个volatile写操作前插入一个StoreStore屏障</li><li>在每一个volatile写操作后插入一个StoreLoad屏障</li><li>在每一个volatile写操作后插入一个LoadLoad屏障</li><li>在每一个volatile读操作后插入一个LoadStore屏障</li></ul><p>那么这些策略中，插入这些屏障有什么作用呢？我们逐条逐条分析一下。</p><ul><li>在每一个volatile写操作前插入一个StoreStore屏障，这条策略保证了volatile写变量与之前的普通变量写不会重排序，即是只有当volatile变量之前的普通变量写完，volatile变量才会写。 这样就保证volatile变量写不会跟它之前的普通变量写重排序</li><li>在每一个volatile写操作后插入一个StoreLoad屏障，这条策略保证了volatile写变量与之后的volatile写/读不会重排序，即是只有当volatile变量写完之后，你后面的volatile读写才能操作。 这样就保证volatile变量写不会跟它之后的普通变量读重排序</li><li>在每一个volatile读操作后插入一个LoadLoad屏障，这条策略保证了volatile读变量与之后的普通读不会重排序，即只有当前volatile变量读完，之后的普通读才能读。 这样就保证volatile变量读不会跟它之后的普通变量读重排序</li><li>在每一个volatile读操作后插入一个LoadStore屏障，这条策略保证了volatile读变量与之后的普通写不会重排序，即只有当前volatile变量读完，之后的普通写才能写。样就保证volatile变量读不会跟它之后的普通变量写重排序</li></ul><p>根据这些策略，volatile变量禁止了部分的重排序，这样也是为什么我们会说volatile具有一定的有序的原因。</p><p>根据以上分析的<code>volatile</code>的内存语义，大家也就知道了为什么前面我们提到的<code>happen-before</code>原则会有一条</p><ul><li>volatile的写happen-before与volaile的读。</li></ul><p>那么根据<code>volatile</code>的内存语义，我们只需要更改之前的部分代码，只能让它正确的执行。</p><p>即把flag定义成一个<code>volatile</code>变量即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileExample1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 共享变量 name</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String name = <span class="string">"init"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 共享变量 flag</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread threadA = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            name = <span class="string">"yukong"</span>;<span class="comment">// 1</span></span><br><span class="line">            flag = <span class="keyword">true</span>;<span class="comment">// 2</span></span><br><span class="line">        &#125;);</span><br><span class="line">        Thread threadB = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;   <span class="comment">// 3</span></span><br><span class="line">                System.out.println(<span class="string">"flag = "</span> + flag + <span class="string">" name = "</span> +name);  <span class="comment">// 4</span></span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来分析一下</p><ul><li><p>由于 flag是volatile变量 那么在volatile写之前插入一个storestore内存屏障，所以1,2不会发生重排序,即1happen before 2</p></li><li><p>由于 flag是volatile变量 那么在volatile读之后插入一个loadload内存屏障，所以3,4不会发生重排序,即3happen before 4</p></li><li><p>根据happen-before原则，volatile写happen before volatile读，即是 2happen before 3。</p></li><li><p>根据happen-before的传递性，所以1 happen before4。</p></li></ul><p><img src="http://cdn.yukonga.cn/2019-05-07-062426.jpg" alt=""></p><h1 id="volatile的使用场景"><a class="markdownIt-Anchor" href="#volatile的使用场景"></a> volatile的使用场景</h1><ul><li>标记变量，也就是上面的flag使用</li><li>double check 单例模式中</li></ul><p>下面我们看看double check的使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="keyword">null</span>)</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于为何需要这么写请参考：</p><p>《Java 中的双重检查（Double-Check）》<a href="http://www.iteye.com/topic/652440" target="_blank" rel="noopener">http://www.iteye.com/topic/652440</a></p><p>最后大家希望关注一下我的个人公众号。<br>欢迎大家关注一下我的个人公众号。一起交流一起学习，有问必答。</p><p><img src="http://cdn.yukonga.cn/2019-05-07-055539.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自从jdk1.5以后，&lt;code&gt;volatile&lt;/code&gt;可谓发生了翻天覆地的变化，从一个一直被吐槽的关键词，变成一个轻量级的线程通信代名词。&lt;/p&gt;
    
    </summary>
    
      <category term="java并发编程实战" scheme="http://www.yukonga.cn/categories/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="java" scheme="http://www.yukonga.cn/tags/java/"/>
    
      <category term="多线程" scheme="http://www.yukonga.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="volatile" scheme="http://www.yukonga.cn/tags/volatile/"/>
    
  </entry>
  
  <entry>
    <title>【java并发编程实战2】无锁编程CAS与atomic包</title>
    <link href="http://www.yukonga.cn/2018/08/30/%E3%80%90java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%982%E3%80%91%E6%97%A0%E9%94%81%E7%BC%96%E7%A8%8BCAS%E4%B8%8Eatomic%E5%8C%85/"/>
    <id>http://www.yukonga.cn/2018/08/30/【java并发编程实战2】无锁编程CAS与atomic包/</id>
    <published>2018-08-30T06:35:34.000Z</published>
    <updated>2019-05-07T06:25:04.030Z</updated>
    
    <content type="html"><![CDATA[<p>无锁编程可能大家在面试的时候会被经常问道，那么何为无锁编程CAS，怎么实现无锁编程CAS？</p><a id="more"></a><h1 id="1-无锁编程cas"><a class="markdownIt-Anchor" href="#1-无锁编程cas"></a> 1、无锁编程CAS</h1><h2 id="11-cas"><a class="markdownIt-Anchor" href="#11-cas"></a> 1.1、CAS</h2><p>CAS的全称是Compare And Swap 即比较交换，其算法核心思想如下</p><blockquote><p>执行函数：CAS(V,E,N)</p></blockquote><p>其包含3个参数</p><ul><li>V表示要更新的变量</li><li>E表示预期值</li><li>N表示新值</li></ul><p>如果V值等于E值，则将V的值设为N。若V值和E值不同，则说明已经有其他线程做了更新，则当前线程什么都不做。通俗的理解就是CAS操作需要我们提供一个期望值，当期望值与当前线程的变量值相同时，说明还没线程修改该值，当前线程可以进行修改，也就是执行CAS操作，但如果期望值与当前线程不符，则说明该值已被其他线程修改，此时不执行更新操作，但可以选择重新读取该变量再尝试再次修改该变量，也可以放弃操作，原理图如下</p><p><img src="http://cdn.yukonga.cn/2019-05-07-062455.jpg" alt=""></p><p>由于CAS操作属于乐观派，它总认为自己可以成功完成操作，当多个线程同时使用CAS操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作，这点从图中也可以看出来。基于这样的原理，CAS操作即使没有锁，同样知道其他线程对共享资源操作影响，并执行相应的处理措施。同时从这点也可以看出，由于无锁操作中没有锁的存在，因此不可能出现死锁的情况，也就是说无锁操作天生免疫死锁。</p><h2 id="12-cpu指令对cas的支持"><a class="markdownIt-Anchor" href="#12-cpu指令对cas的支持"></a> 1.2、CPU指令对CAS的支持</h2><p>或许我们可能会有这样的疑问，假设存在多个线程执行CAS操作并且CAS的步骤很多，有没有可能在判断V和E相同后，正要赋值时，切换了线程，更改了值。造成了数据不一致呢？答案是否定的，因为CAS是一种系统原语，原语属于操作系统用语范畴，是由若干条指令组成的，用于完成某个功能的一个过程，并且原语的执行必须是连续的，在执行过程中不允许被中断，也就是说CAS是一条CPU的原子指令，不会造成所谓的数据不一致问题。</p><h1 id="2-atomic族类"><a class="markdownIt-Anchor" href="#2-atomic族类"></a> 2、 atomic族类</h1><p>在atomic包下共有AtomicBoolean、AtomicInteger、AtomicIntegerArray、AtmoicReference、AtomicReferenceFieldUpdater、LongAdder等类。</p><p>在上面线程不安全的例子中，我们用1000个线程调用整型变量的i的自增，然后输出i最后的大小，在多线程情况下，这明显是线程不安全的，因为<code>i++</code>不是原子操作，这里我们可以使用AtomicInteger代替Integer。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 并发线程数目</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> threadNum = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 闭锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch countDownLatch  = <span class="keyword">new</span> CountDownLatch(threadNum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger i = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; threadNum; j++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                add();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用闭锁保证当所有统计线程完成后，主线程输出统计结果。 其实这里也可以使用Thread.sleep() 让主线程阻塞等待一会儿实现</span></span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(i.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">        i.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码就是线程安全的，运行输出 i=1000,这是为什么呢。我们来看看<code>getAndIncrement()</code>方法的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Atomically increments by one the current value.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the previous value</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>我们看到方法是由一个unsafe对象的getAndAddInt方法实现。我们继续点进去看看getAndAddInt方法的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//</span></span><br><span class="line">       <span class="keyword">int</span> var5;</span><br><span class="line">       <span class="keyword">do</span> &#123;</span><br><span class="line">           var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">       &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> var5;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面就是<code>getAndAddInt</code>方法的实现,具体流程如下，</p><p>1、首先根据当前的传过来的对象指针，获取期望的值  var5,</p><p>2、然后while判断调用compareAndSwapInt方法 ，这是一个native本地方法，它有四个参数，</p><p>第一个参数，当前的对象，第二个参数实际的值，第三个参数期望的值，第四个参数想要更新的值。</p><p>只有实际的值等于期望的值的时候，才会把值更新成第四个参数，也就是想要的更新的值，否则一直循环尝试。</p><p>这也就是无锁编程，CAS。</p><p>在高并发的场景，这种循环尝试的次数会比较高，成功率会比较低，这样性能会比较差。但是在JDK8中推出了一个新的类名为<code>LongAdder</code></p><p>我们看看它的用法。我们也继续上面的求和的例子，只需要把<code>AtomicInteger</code>改成<code>LongAddr</code>然后更改对应调用的方法即可。具体代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongAdderExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 并发线程数目</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> threadNum = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 闭锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch countDownLatch  = <span class="keyword">new</span> CountDownLatch(threadNum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LongAdder i = <span class="keyword">new</span> LongAdder();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; threadNum; j++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                add();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用闭锁保证当所有统计线程完成后，主线程输出统计结果。 其实这里也可以使用Thread.sleep() 让主线程阻塞等待一会儿实现</span></span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">        i.increment();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序，发现结果与预期的一样i=1000，是线程安全的。那么我们看看它又是如何。保证线程安全的呢。</p><p>由于篇幅原因我不跟入源码讲解了，大致思想与ConcurrentHashMapy大致一致，采用的是热点分离法，</p><p>把value分成base+cells数组，避免所有的写操作都是在value上面，这样就保证提高性能，但是在多线程情况下，统计会有误差。</p><p>接着我们讲解CAS中常常会遇到的ABA问题。</p><p>比如说一个线程one从内存位置V中取出A，这时候另一个线程two也从内存中取出A，并且two进行了一些操作变成了B，然后two又将V位置的数据变成A，这时候线程one进行CAS操作发现内存中仍然是A，然后one操作成功。尽管线程one的CAS操作成功，但是不代表这个过程就是没有问题的。如果链表的头在变化了两次后恢复了原值，但是不代表链表就没有变化。</p><p>这里我们可以借助乐观锁的一个概念，使用version版本号来判断是否一致，每次操作后版本号加1如果两次对比版本号一致才交换，这样就避免了ABA问题，在atomic包下面也提供了对应的类<code>AtomicStampedReference</code>。</p><p><code>AtomicStampedReference</code>每次操作前判断更新的时间戳与预期的时间戳是否一致，这样就巧妙的避免了ABA问题。</p><p>最后大家希望关注一下我的个人公众号。<br>欢迎大家关注一下我的个人公众号。一起交流一起学习，有问必答。</p><p><img src="http://cdn.yukonga.cn/2019-05-07-055539.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;无锁编程可能大家在面试的时候会被经常问道，那么何为无锁编程CAS，怎么实现无锁编程CAS？&lt;/p&gt;
    
    </summary>
    
      <category term="java并发编程实战" scheme="http://www.yukonga.cn/categories/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="java" scheme="http://www.yukonga.cn/tags/java/"/>
    
      <category term="多线程" scheme="http://www.yukonga.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="CAS" scheme="http://www.yukonga.cn/tags/CAS/"/>
    
      <category term="atomic" scheme="http://www.yukonga.cn/tags/atomic/"/>
    
  </entry>
  
  <entry>
    <title>【java并发编程实战1】何为线程安全性</title>
    <link href="http://www.yukonga.cn/2018/08/29/%E3%80%90java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%981%E3%80%91%E4%BD%95%E4%B8%BA%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7/"/>
    <id>http://www.yukonga.cn/2018/08/29/【java并发编程实战1】何为线程安全性/</id>
    <published>2018-08-29T11:17:02.000Z</published>
    <updated>2019-05-07T06:25:27.596Z</updated>
    
    <content type="html"><![CDATA[<p>多线程问题，一直是我们老生常谈的一个问题，在面试中也会被经常问到，如何去学习理解多线程，何为线程安全性，那么大家跟我的脚步一起来学习一下。</p><a id="more"></a><h1 id="线程安全性"><a class="markdownIt-Anchor" href="#线程安全性"></a> 线程安全性</h1><p>定义：</p><blockquote><p>当多个线程访问某个类时，不管运行时环境采用<strong>何种调度方式</strong> 或者这些线程如何交替执行，并且在主调代码中<strong>不需要任何额外的同步或者协同</strong>，这个类都能表现<strong>正确的行为</strong>,那么称这个类时线程安全的。</p></blockquote><p>线程的安全性主要体现在三个方法</p><ul><li>原子性：即不可分割，提供互斥访问，同一时刻只能有一个线程对它进行操作</li><li>可见性：一个线程对共享变量的修改，可以及时被其他线程观察到</li><li>有序性：序在执行的时候，程序的代码执行顺序和语句的顺序是一致的。</li></ul><h2 id="1-原子性"><a class="markdownIt-Anchor" href="#1-原子性"></a> 1、原子性</h2><p>1、访问（读/写）某个共享变量的操作从其执行线程以外的线程来看，该操作要么已经执行结果，有么尚未执行，也就是说其他线程不会看到“该操作执行了部分的效果”。</p><p>2、访问同一组共享变量的原子操作 不能够被交错的。</p><p>在java中实现原子性的两种方式：</p><ul><li><p>使用CAS也是atomic包下的类。</p></li><li><p>使用锁</p></li></ul><blockquote><p>在java语言中，除long/double之外的任何类型的变量的写操作都是原子操作。</p><p>java语言中任何变量的读操作都是原子操作。</p><p>需要注意的是 原子操作 + 原子操作  != 原子操作</p><p>例如 i++ 先读后写  读跟写都是原子操作，但是 i++并不是原子操作</p></blockquote><p>下面用代码讲一下实现的两种方式</p><p>例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yukong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/8/29</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 线程不安全</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 并发线程数目</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> threadNum = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 闭锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch countDownLatch  = <span class="keyword">new</span> CountDownLatch(threadNum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer i = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; threadNum; j++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                add();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用闭锁保证当所有统计线程完成后，主线程输出统计结果。 其实这里也可以使用Thread.sleep() 让主线程阻塞等待一会儿实现</span></span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码很明显因为i++不是原子性操作，所以不是线程安全的。</p><p>那么根据上面讲的，我们可以使用锁，或者atomic包下的类实现。</p><h2 id="2-可见性"><a class="markdownIt-Anchor" href="#2-可见性"></a> 2、可见性</h2><p>一个线程对共享变量的修改能够及时被其他线程所观察。</p><p>这句话怎么理解呢？</p><p>在JMM（Java Memory Model）的定义中，所有的变量都需要存储在主体内存中，主内存是共享内存区域，所有的线程都能访问的，但是线程对变量的操作（读、写）必须在工作内存中完成。</p><p>1、首先将变量从主内存中拷贝到自己的工作内存。</p><p>2、对变量进行读写操作。</p><p>3、操作完成，将变量回写到主内存中。</p><p>从上面可以得知，线程不能直接操作主内存的变量，必须要在工作内存中操作。</p><p>简单了解一下JMM的规定，那么我们就可以很容易的理解可见性了。<img src="http://cdn.yukonga.cn/2019-05-07-062515.jpg" alt=""></p><p>由上图可知 ，在多线程情况下，线程对共享变量的的操作都是拷贝一份副本到自己的工作内存中操作的，然后才写回到主内存中，这就可能存在一个问题，线程1修改了共享变量X的值，但是还未写回主内存，另外一个线程2又对主内存中的同一个共享变量x进行操作，但此时线程1工作内存中的变量x对线程n并不可以，这种工作内存与主内存同步延迟的问题就造成了可见性问题，另外指令重排序也会导致可见性问题。</p><p>那么对于可见性问题，使用什么解决方法呢？</p><ul><li>synchronized关键字</li><li>volatile关键词</li></ul><p>为什么synchronized能保证可见性呢？根据JMM关于synchronized的规定</p><ul><li>线程解锁前，必须把共享变量的最新刷新到主内存。</li><li>线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要重新从主内存中读取最新值。</li></ul><p>那么volatile又是怎么实现可见性的呢？</p><p>其实volatile是通过加入<strong>内存屏障</strong>和禁止指令<strong>重排序</strong>优化来实现的。</p><ul><li>对volatile变量写操作时，会在写操作后加入一条store屏障指令，将工作内存中的共享变量值刷新到主内存中</li><li>对于volatile变量读操作时，会在读操作前加入一条load屏障指定，从主内存读取共享变量最新的值到工作内存中。</li></ul><p>那大家可能就会想问了，我把上面的代码的i变量用<code>volatile</code>修饰一下，是不是就保证线程安全，输出的结果就是1000呢，答案是否定的，volatile保证的是可见性，并不能保证原子性。但是利用volatile可见性这个特点，我们可以利用它完全一些线程中的通信</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>; </span><br><span class="line"><span class="comment">// thread a</span></span><br><span class="line">&#123;</span><br><span class="line">    flag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// do somethings</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// thread b</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">        <span class="comment">// do somethings</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就完全一个线程中通信的案例。</p><h2 id="3-有序性"><a class="markdownIt-Anchor" href="#3-有序性"></a> 3、有序性</h2><blockquote><p>在JMM（java 内存 模型）中，运行编译器和处理器对指令就行重排序，但是重排序过程不会影响到<strong>单线程</strong>程序的执行，却会影响多线程并发执行的正确性。</p></blockquote><p>在java中，可以通过<code>volatile</code>关键字来保证一定的有序性。另外也可以通过<code>synchronized</code>和<code>Lock</code>来保证有序性。很显然，synchronized跟lock保证每个时刻是只有一个线程执行同步代码，相当于让线程属性执行同步代码，自然保证了有序性。</p><p>另外java内存模型也具备一些先天的<code>有序性</code>,即不需要通过任何手段就能够保证的有序性，这个通常也称为<code>Happen-Before</code>原则。如果两个操作的资源无法从<code>Happen-Before</code>原则推导出来，那么他们就不能保证它的有序性，虚拟机就可以随机对他们进行重排序。</p><p>那么下面就详细介绍<code>Happen-Before</code>(先行发生原则)：</p><ol><li>线程次序规则： 在一个线程内，按照代码顺序，书写在前的代码先行发生于书写在后的代码操作。</li><li>锁定原则：一个unlock操作先行发生于后面的对同一个锁的lock操作。</li><li>volatile变量原则，对同一个变量的写操作先行发生于后面对这个变量的读操作。</li><li>传递原则：如果操作A先行发生于操作B,而且操作B又先行发生于操作C，则可以得出操作A先行发生于操作C。</li><li>线程启动原则：Thread对象的start()方法先行发生于此线程的每一个操作。</li><li>线程中断原则：Thread对象的interrupt()方法先行发生于被中断线程检测到中断事件的发生</li><li>线程终结原则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束，Thread.isAlive()的返回值手段检测线程是否已经终止。</li><li>线程终结原则：一个对象的初始化完成先行发生于他的finalize()方法的开始。</li></ol><h1 id="4-总结"><a class="markdownIt-Anchor" href="#4-总结"></a> 4、总结</h1><p>如果一个操作具有以上的三种特性，那么我们称它为线程安全的。</p><p>最后欢迎大家关注一下我的个人公众号 程序咖啡厅 每天一杯逐渐成长。<br>欢迎大家关注一下我的个人公众号。一起交流一起学习，有问必答。</p><p><img src="http://cdn.yukonga.cn/2019-05-07-055539.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;多线程问题，一直是我们老生常谈的一个问题，在面试中也会被经常问到，如何去学习理解多线程，何为线程安全性，那么大家跟我的脚步一起来学习一下。&lt;/p&gt;
    
    </summary>
    
      <category term="java并发编程实战" scheme="http://www.yukonga.cn/categories/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="java" scheme="http://www.yukonga.cn/tags/java/"/>
    
      <category term="多线程" scheme="http://www.yukonga.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="并发编程" scheme="http://www.yukonga.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>【SpringBoot2.0系列10】SpringBoot之@Scheduled任务调度</title>
    <link href="http://www.yukonga.cn/2018/08/27/%E3%80%90SpringBoot2-0%E7%B3%BB%E5%88%9710%E3%80%91SpringBoot%E4%B9%8B-Scheduled%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/"/>
    <id>http://www.yukonga.cn/2018/08/27/【SpringBoot2-0系列10】SpringBoot之-Scheduled任务调度/</id>
    <published>2018-08-27T12:24:29.000Z</published>
    <updated>2019-05-07T06:08:47.120Z</updated>
    
    <content type="html"><![CDATA[<p>相信大家在实际工作场景中会遇到这样的情况，系统之间存在数据交换，为了不影响正常服务器运，我们需要在每天的凌晨来进行数据交换，但是让程序每天凌晨自动执行呢，下面带大家来了解一下springboot定时任务调度。</p><a id="more"></a><h1 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h1><p>其实在springboot中实现定时任务调度十分的，下面我们将实现一个简单的定时任务调度调度。</p><h2 id="1-依赖"><a class="markdownIt-Anchor" href="#1-依赖"></a> 1、依赖</h2><p><code>scheduled</code> 依赖是<code>spring-context</code>这个jar包其中我们的<code>spring-boot-starter</code>已经依赖spring的一些核心jar，所以我们只需要添加<code>spring-boot-starter</code>即可</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-引入enablescheduling"><a class="markdownIt-Anchor" href="#2-引入enablescheduling"></a> 2、引入<code>@EnableScheduling</code></h2><p>我们需要在Spring Boot的主类中加入@EnableScheduling注解，开启定时任务的配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yukong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@data</span> 2018年8月27日19:00:21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chapter9Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Chapter9Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-实现定时任务"><a class="markdownIt-Anchor" href="#3-实现定时任务"></a> 3、实现定时任务</h2><p>我们创建一个名为<code>ScheduledTask</code>的任务类</p><h3 id="311-scheduledfixeddelay-5000"><a class="markdownIt-Anchor" href="#311-scheduledfixeddelay-5000"></a> 3.1.1 @Scheduled(fixedDelay= 5000)</h3><p>@Scheduled(fixedDelay= 5000) 指的是上一次开始执行时间点之后5秒再执行。可能大家不知道什么意思那么下面代码编写，运行一下就知道了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yukong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/8/27</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledTask</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Logger logger = LoggerFactory.getLogger(ScheduledTask.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从当前方法开始执行后5s再次执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Scheduled</span>(fixedDelay= <span class="number">5000</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduledTask2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"当前时间为：&#123;&#125;"</span>, simpleDateFormat.format(<span class="keyword">new</span> Date()));</span><br><span class="line">        Thread.sleep(<span class="number">3000L</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面需要注意的是我们通过<code>@Scheduled</code>注解表示这个一个定时调度的任务，具体的调度策略是根据注解中的属性决定，在当前代码中fixedDelay= 5000代表从当前方法开始执行<strong>完成</strong>后5s再次执行,注意加粗部分。另外需要注意的我们的类需要用<code>@Component</code>注解标识，不然spring是无法感知这些定时任务的。</p><h3 id="312测试-结论"><a class="markdownIt-Anchor" href="#312测试-结论"></a> 3.1.2测试、结论</h3><p>运行结果如下<br><img src="http://cdn.yukonga.cn/2019-05-07-060800.jpg" alt=""></p><p>图中是每隔8s执行一次，但是我们明明设置的5s的间隔，这是怎么回事呢。回头看看我刚刚说的<code>fixedDelay = 5000</code>的特点：代表从当前方法开始执行<strong>完成</strong>后5s再次执行。在看看定时调用的方法中<code>Thread.sleep(3000)</code>就瞬间明白了。原来<code>fixedDelay</code> = 代表从当前方法开始执行<strong>完成</strong>后间隔一定时间再次执行。那么不需要等待当前方法执行完成又是怎么写的呢？</p><h3 id="321-scheduledfixedrate-5000"><a class="markdownIt-Anchor" href="#321-scheduledfixedrate-5000"></a> 3.2.1 @Scheduled(fixedRate= 5000)</h3><p>其实很简单的，我们只需要将<code>fixedDelay = 5000</code>改成<code>fixedRate = 5000</code>即可。<br><code>fixedRate = 5000</code>代表 从当前方<strong>开始执后</strong>5s再次执行，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从当前方法开始执行后5s再次执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Scheduled</span>(fixedRate = <span class="number">5000</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduledTask1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    logger.info(<span class="string">"当前时间为：&#123;&#125;"</span>, simpleDateFormat.format(<span class="keyword">new</span> Date()));</span><br><span class="line">    Thread.sleep(<span class="number">3000L</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="322测试-结论"><a class="markdownIt-Anchor" href="#322测试-结论"></a> 3.2.2测试、结论</h3><p>执行结果如图，如预期的一样每隔5s秒执行一次。<br><img src="http://cdn.yukonga.cn/2019-05-07-060821.jpg" alt=""></p><h3 id="331-scheduledcron-0515"><a class="markdownIt-Anchor" href="#331-scheduledcron-0515"></a> 3.3.1      @Scheduled(cron = “0,5,15 * * * * ?”)</h3><p>如果你还需要更复杂的定时任务策略，那么你就可能需要用到<code>cron</code>表达式。<br>1.cron表达式格式：<br>{秒数} {分钟} {小时} {日期} {月份} {星期} {年份(可为空)}<br>2.cron表达式各占位符解释：<br>{秒数} ==&gt; 允许值范围: 0~59 ,不允许为空值，若值不合法，调度器将抛出SchedulerException异常<br>“*” 代表每隔1秒钟触发；<br>“,” 代表在指定的秒数触发，比如&quot;0,15,45&quot;代表0秒、15秒和45秒时触发任务<br>&quot;-&quot;代表在指定的范围内触发，比如&quot;25-45&quot;代表从25秒开始触发到45秒结束触发，每隔1秒触发1次<br>“/“代表触发步进(step)，”/“前面的值代表初始值(”*“等同&quot;0”)，后面的值代表偏移量，比如&quot;0/20&quot;或者”*/20&quot;代表从0秒钟开始，每隔20秒钟触发1次，即0秒触发1次，20秒触发1次，40秒触发1次；&quot;5/20&quot;代表5秒触发1次，25秒触发1次，45秒触发1次；&quot;10-45/20&quot;代表在[10,45]内步进20秒命中的时间点触发，即10秒触发1次，30秒触发1次<br>{分钟} ==&gt; 允许值范围: 0~59 ,不允许为空值，若值不合法，调度器将抛出SchedulerException异常<br>“*” 代表每隔1分钟触发；<br>&quot;,&quot;代表在指定的分钟触发，比如&quot;10,20,40&quot;代表10分钟、20分钟和40分钟时触发任务<br>“-” 代表在指定的范围内触发，比如&quot;5-30&quot;代表从5分钟开始触发到30分钟结束触 发，每隔1分钟触发<br>“/“代表触发步进(step)，”/“前面的值代表初始值(”*“等同&quot;0”)，后面的值代表偏移量，比如&quot;0/25&quot;或者”*/25&quot;代表从0分钟开始，每隔25分钟触发1次，即0分钟触发1次，第25分钟触发1次，第50分钟触发1次；&quot;5/25&quot;代表5分钟触发1次，30分钟触发1次，55分钟触发1次；&quot;10-45/20&quot;代表在[10,45]内步进20分钟命中的时间点触发，即10分钟触发1次，30分钟触发1次<br>{小时} ==&gt; 允许值范围: 0~23 ,不允许为空值，若值不合法，调度器将抛出SchedulerException异常<br>“*” 代表每隔1小时触发；<br>&quot;,&quot;代表在指定的时间点触发，比如&quot;10,20,23&quot;代表10点钟、20点钟和23点触发任务<br>&quot;-&quot;代表在指定的时间段内触发，比如&quot;20-23&quot;代表从20点开始触发到23点结束触发，每隔1小时触发<br>“/“代表触发步进(step)，”/“前面的值代表初始值(”*“等同&quot;0”)，后面的值代表偏移量，比如&quot;0/1&quot;或者”*/1&quot;代表从0点开始触发，每隔1小时触发1次；&quot;1/2&quot;代表从1点开始触发，以后每隔2小时触发一次；&quot;19-20/2&quot;表达式将只在19点触发<br>{日期} ==&gt; 允许值范围: 1~31 ,不允许为空值，若值不合法，调度器将抛出SchedulerException异常<br>“*” 代表每天触发；<br>&quot;?&quot;与{星期}互斥，即意味着若明确指定{星期}触发，则表示{日期}无意义，以免引起 冲突和混乱<br>“,” 代表在指定的日期触发，比如&quot;1,10,20&quot;代表1号、10号和20号这3天触发<br>&quot;-&quot;代表在指定的日期范围内触发，比如&quot;10-15&quot;代表从10号开始触发到15号结束触发，每隔1天触发<br>“/“代表触发步进(step)，”/“前面的值代表初始值(”*“等同&quot;1”)，后面的值代表偏移量，比如&quot;1/5&quot;或者”*/5&quot;代表从1号开始触发，每隔5天触发1次；&quot;10/5&quot;代表从10号开始触发，以后每隔5天触发一次；“1-10/2&quot;表达式意味着在[1,10]范围内，每隔2天触发，即1号，3号，5号，7号，9号触发<br>“L” 如果{日期}占位符如果是&quot;L”，即意味着当月的最后一天触发<br>&quot;W &quot;意味着在本月内离当天最近的工作日触发，所谓最近工作日，即当天到工作日的前后最短距离，如果当天即为工作日，则距离为0；所谓本月内的说法，就是不能跨月取到最近工作日，即使前/后月份的最后一天/第一天确实满足最近工作日；因此，&quot;LW&quot;则意味着本月的最后一个工作日触发，&quot;W&quot;强烈依赖{月份}<br>“C” 根据日历触发，由于使用较少，暂时不做解释<br>{月份} ==&gt; 允许值范围: 1~12 (JAN-DEC),不允许为空值，若值不合法，调度器将抛出SchedulerException异常<br>“*” 代表每个月都触发；<br>“,” 代表在指定的月份触发，比如&quot;1,6,12&quot;代表1月份、6月份和12月份触发任务<br>&quot;-&quot;代表在指定的月份范围内触发，比如&quot;1-6&quot;代表从1月份开始触发到6月份结束触发，每隔1个月触发<br>“/“代表触发步进(step)，”/“前面的值代表初始值(”*“等同&quot;1”)，后面的值代表偏移量，比如&quot;1/2&quot;或者”*/2&quot;代表从1月份开始触发，每隔2个月触发1次；&quot;6/6&quot;代表从6月份开始触发，以后每隔6个月触发一次；&quot;1-6/12&quot;表达式意味着每年1月份触发<br>{星期} ==&gt; 允许值范围: 1~7 (SUN-SAT),1代表星期天(一星期的第一天)，以此类推，7代表星期六(一星期的最后一天)，不允许为空值，若值不合法，调度器将抛出SchedulerException异常<br>“*” 代表每星期都触发；<br>&quot;?&quot;与{日期}互斥，即意味着若明确指定{日期}触发，则表示{星期}无意义，以免引起冲突和混乱<br>“,” 代表在指定的星期约定触发，比如&quot;1,3,5&quot;代表星期天、星期二和星期四触发<br>&quot;-&quot;代表在指定的星期范围内触发，比如&quot;2-4&quot;代表从星期一开始触发到星期三结束触发，每隔1天触发<br>“/“代表触发步进(step)，”/“前面的值代表初始值(”*“等同&quot;1”)，后面的值代表偏移量，比如&quot;1/3&quot;或者”*/3&quot;代表从星期天开始触发，每隔3天触发1次；&quot;1-5/2&quot;表达式意味着在[1,5]范围内，每隔2天触发，即星期天、星期二、星期四触发<br>“L&quot;如果{星期}占位符如果是&quot;L”，即意味着星期的的最后一天触发，即星期六触发，L= 7或者 L = SAT，因此，&quot;5L&quot;意味着一个月的最后一个星期四触发<br>&quot;#“用来指定具体的周数，”#“前面代表星期，”#&quot;后面代表本月第几周，比如&quot;2#2&quot;表示本月第二周的星期一，&quot;5#3&quot;表示本月第三周的星期四，因此，“5L&quot;这种形式只不过是”#&quot;的特殊形式而已<br>“C” 根据日历触发，由于使用较少，暂时不做解释<br>{年份} ==&gt; 允许值范围: 1970~2099 ,允许为空，若值不合法，调度器将抛出SchedulerException异常<br>&quot;*&quot;代表每年都触发；<br>&quot;,&quot;代表在指定的年份才触发，比如&quot;2011,2012,2013&quot;代表2011年、2012年和2013年触发任务<br>&quot;-“代表在指定的年份范围内触发，比如&quot;2011-2020&quot;代表从2011年开始触发到2020年结束触发，每隔1年触发<br>“/“代表触发步进(step)，”/“前面的值代表初始值(”*“等同&quot;1970”)，后面的值代表偏移量，比如&quot;2011/2&quot;或者”*/2&quot;代表从2011年开始触发，每隔2年触发1次<br>注意：除了{日期}和{星期}可以使用”?&quot;来实现互斥，表达无意义的信息之外，其他占位符都要具有具体的时间含义，且依赖关系为：年-&gt;月-&gt;日期(星期)-&gt;小时-&gt;分钟-&gt;秒数<br>具体cron你可以参考<a href="https://blog.csdn.net/li295214001/article/details/52065634" target="_blank" rel="noopener">cron详解</a></p><p>现在我们实现一个每分钟的第0,5,15秒执行一次，那么对应的cron表达式应为<code>0,5,15 * * * * ?</code><br>实现的代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled</span>(cron = <span class="string">"0,5,15 * * * * ?"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cronTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"当前时间为：&#123;&#125;"</span>, simpleDateFormat.format(<span class="keyword">new</span> Date()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="332运行"><a class="markdownIt-Anchor" href="#332运行"></a> 3.3.2运行</h3><p>启动，运行结果如下：<br><img src="http://cdn.yukonga.cn/2019-05-07-060840.jpg" alt=""><br>每分钟的第0,5,15秒都执行，如果你还需要其他的规则，只需要更改对应cron表达式，相信cron的强大能够满足所有的业务场景。</p><h1 id="结语"><a class="markdownIt-Anchor" href="#结语"></a> 结语</h1><p>相信通过本次学习，大家应该知道如何在springboot使用定时任务了。<br>最后配套教程的代码全部在这里<br><a href="https://github.com/YuKongEr/SpringBoot-Study" target="_blank" rel="noopener">github https://github.com/YuKongEr/SpringBoot-Study</a>。麻烦点个star或者fork吧。</p><p>最后欢迎大家关注一下我的个人公众号。一起交流一起学习，有问必答。<br><img src="http://cdn.yukonga.cn/2019-05-07-055539.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;相信大家在实际工作场景中会遇到这样的情况，系统之间存在数据交换，为了不影响正常服务器运，我们需要在每天的凌晨来进行数据交换，但是让程序每天凌晨自动执行呢，下面带大家来了解一下springboot定时任务调度。&lt;/p&gt;
    
    </summary>
    
      <category term="SpringBoot" scheme="http://www.yukonga.cn/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="http://www.yukonga.cn/tags/SpringBoot/"/>
    
      <category term="Scheduled" scheme="http://www.yukonga.cn/tags/Scheduled/"/>
    
  </entry>
  
  <entry>
    <title>解开BIO、NIO、AIO神秘的面纱</title>
    <link href="http://www.yukonga.cn/2018/08/25/%E8%A7%A3%E5%BC%80BIO%E3%80%81NIO%E3%80%81AIO%E7%A5%9E%E7%A7%98%E7%9A%84%E9%9D%A2%E7%BA%B1/"/>
    <id>http://www.yukonga.cn/2018/08/25/解开BIO、NIO、AIO神秘的面纱/</id>
    <published>2018-08-25T07:14:05.000Z</published>
    <updated>2019-06-13T01:25:24.130Z</updated>
    
    <content type="html"><![CDATA[<p>本文内容涉及同步与异步, 阻塞与非阻塞, BIO、NIO、AIO等概念, 这块内容本身比较复杂, 很难用三言两语说明白. 而书上的定义更不容易理解是什么意思. 下面跟着我一起解开它们神秘的面纱。</p><a id="more"></a><ul><li>BIO    传统的socket编程，属于同步阻塞模型</li><li>NIO 官方(new io) jdk1.4推出 俗称(non-block io) ，属于同步非阻塞模式</li><li>AIO  又称NIO2.0在jdk1.7推出，属于异步非阻塞模式<br>#解读同步异步，阻塞非阻塞。</li></ul><h3 id="阻塞和非阻塞"><a class="markdownIt-Anchor" href="#阻塞和非阻塞"></a> 阻塞和非阻塞</h3><p>从简单的开始，我们以经典的读取文件的模型举例。（对操作系统而言，所有的输入输出设备都被抽象成文件。）</p><p>在发起读取文件的请求时，应用层会调用系统内核的I/O接口。</p><p>如果应用层调用的是阻塞型I/O，那么在调用之后，应用层即刻被挂起，一直出于等待数据返回的状态，直到系统内核从磁盘读取完数据并返回给应用层，应用层才用获得的数据进行接下来的其他操作。</p><p>如果应用层调用的是非阻塞I/O，那么调用后，系统内核会立即返回（虽然还没有文件内容的数据），应用层并不会被挂起，它可以做其他任意它想做的操作。（至于文件内容数据如何返回给应用层，这已经超出了阻塞和非阻塞的辨别范畴。）</p><p>这便是（脱离同步和异步来说之后）阻塞和非阻塞的区别。总结来说，是否是阻塞还是非阻塞，关注的是接口调用（发出请求）后等待数据返回时的状态。被挂起无法执行其他操作的则是阻塞型的，可以被立即「抽离」去完成其他「任务」的则是非阻塞型的。<br><img src="http://cdn.yukonga.cn/2019-05-07-062547.jpg" alt=""></p><h3 id="同步和异步"><a class="markdownIt-Anchor" href="#同步和异步"></a> 同步和异步</h3><p>阻塞和非阻塞解决了应用层等待数据返回时的状态问题，那系统内核获取到的数据到底如何返回给应用层呢？这里不同类型的操作便体现的是同步和异步的区别。</p><p>对于同步型的调用，应用层需要自己去向系统内核问询，如果数据还未读取完毕，那此时读取文件的任务还未完成，应用层根据其阻塞和非阻塞的划分，或挂起或去做其他事情（所以同步和异步并不决定其等待数据返回时的状态）；如果数据已经读取完毕，那此时系统内核将数据返回给应用层，应用层即可以用取得的数据做其他相关的事情。</p><p>而对于异步型的调用，应用层无需主动向系统内核问询，在系统内核读取完文件数据之后，会主动通知应用层数据已经读取完毕，此时应用层即可以接收系统内核返回过来的数据，再做其他事情。</p><p>这便是（脱离阻塞和非阻塞来说之后）同步和异步的区别。也就是说，是否是同步还是异步，关注的是任务完成时消息通知的方式。由调用方盲目主动问询的方式是同步调用，由被调用方主动通知调用方任务已完成的方式是异步调用。</p><p><img src="/Users/yukong/Desktop/2019-05-07-062558.png" alt=""></p><p>假设小明需要在网上下载一个软件：</p><p>如果小明点击下载按钮之后，就一直干瞪着进度条不做其他任何事情直到软件下载完成，这是同步阻塞；<br>如果小明点击下载按钮之后，就一直干瞪着进度条不做其他任何事情直到软件下载完成，但是软件下载完成其实是会「叮」的一声通知的（但小明依然那样干等着），这是异步阻塞；（不常见）<br>如果小明点击下载按钮之后，就去做其他事情了，不过他总需要时不时瞄一眼屏幕看软件是不是下载完成了，这是同步非阻塞；<br>如果小明点击下载按钮之后，就去做其他事情了，软件下载完之后「叮」的一声通知小明，小明再回来继续处理下载完的软件，这是异步非阻塞。<br>相信看完以上这个案例之后，这几个概念已经能够分辨得很清楚了。</p><p>总的来说，<strong>同步和异步关注的是任务完成消息通知的机制，而阻塞和非阻塞关注的是等待任务完成时请求者的状态。</strong></p><h1 id="java网络编程"><a class="markdownIt-Anchor" href="#java网络编程"></a> java网络编程</h1><p>我们通过 客户端像服务端查询信息作为一个例子。分别通过三种模型来实现。</p><h2 id="11-传统的bio"><a class="markdownIt-Anchor" href="#11-传统的bio"></a> 1.1、传统的BIO</h2><p>在传统的网络编程中，服务端监听端口，客户端请求服务端的ip跟监听的端口，跟服务端通信，必须三次握手建立。如果连接成功，通过套接字（socket）进行通信。<br>在BIO通信模型：采用BIO通信模型的服务端，通常由一个独立的Acceptor线程负责监听客户端的连接，它接收到客户端连接请求之后为每个客户端创建一个新的线程进行链路处理没处理完成后，通过输出流返回应答给客户端，线程销毁。即典型的一请求一应答通信模型。<br><img src="/Users/yukong/Desktop/2019-05-07-062610.png" alt=""><br>从图中可以得知，该模型中每一个请求对应一个线程处理，在线程数量有限的情况下，请求数量多，那么服务器就会因为资源不足而挂掉。<br>服务端代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yukong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018年8月24日18:51:40</span></span><br><span class="line"><span class="comment"> * 服务端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认端口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer DEFAULT_PORT = <span class="number">6789</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        start(DEFAULT_PORT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">start</span><span class="params">(Integer port)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line">        System.out.println(<span class="string">"小yu机器人启动，监听端口为："</span> + port);</span><br><span class="line">        <span class="comment">//通过无线循环监听客户端连接</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 阻塞方法，直至有客户端连接成功</span></span><br><span class="line">            Socket socket = serverSocket.accept();</span><br><span class="line">            <span class="comment">// 多线程处理客户端请求</span></span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> ServerHandler(socket)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Server().start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端处理器代码</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author yukong</span></span><br><span class="line"><span class="comment"> * @date 2018年8月24日18:51:40</span></span><br><span class="line"><span class="comment"> *  服务端业务逻辑处理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ServerHandler</span> <span class="title">implements</span> <span class="title">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServerHandler</span>(<span class="params">Socket socket</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        BufferedReader <span class="keyword">in</span> = <span class="literal">null</span>;</span><br><span class="line">        PrintWriter <span class="keyword">out</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取socket的字符缓存输入流 也就是获取客户端给服务器的字符流</span></span><br><span class="line">            <span class="keyword">in</span> = <span class="keyword">new</span> BufferedReader( <span class="keyword">new</span> InputStreamReader(<span class="keyword">this</span>.socket.getInputStream()));</span><br><span class="line">            <span class="comment">// 获取socket的字符输出流 也就是发送的客户的字符流 第二个参数自动刷新</span></span><br><span class="line">            <span class="keyword">out</span> = <span class="keyword">new</span> PrintWriter( <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">this</span>.socket.getOutputStream()), <span class="literal">true</span>);</span><br><span class="line">            String request, response;</span><br><span class="line">            <span class="comment">// 读取输入流的消息 如果为空 则退出读取</span></span><br><span class="line">            <span class="keyword">while</span> ((request = <span class="keyword">in</span>.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="string">"["</span> + Thread.currentThread().getName()+ <span class="string">"]"</span> + <span class="string">"小yu机器人收到消息："</span> + request);</span><br><span class="line">                <span class="comment">// 具体业务逻辑处理 查询信息。</span></span><br><span class="line">                response = ResponseUtil.queryMessage(request);</span><br><span class="line">                <span class="keyword">out</span>.println(response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;  <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 资源释放</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">in</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">in</span>.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">in</span> = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">out</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">out</span>.close();</span><br><span class="line">                <span class="keyword">out</span> = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (socket != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                socket = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yukong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018年8月24日18:51:40</span></span><br><span class="line"><span class="comment"> * 客户端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认端口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer DEFAULT_PORT = <span class="number">6789</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认端口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_HOST = <span class="string">"localhost"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">send</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        send(DEFAULT_PORT,key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">send</span><span class="params">(<span class="keyword">int</span> port,String key)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"查询的key为："</span> + key);</span><br><span class="line">        Socket socket = <span class="keyword">null</span>;</span><br><span class="line">        BufferedReader in = <span class="keyword">null</span>;</span><br><span class="line">        PrintWriter out = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            socket = <span class="keyword">new</span> Socket(DEFAULT_HOST,port);</span><br><span class="line">            in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">            out = <span class="keyword">new</span> PrintWriter(socket.getOutputStream(),<span class="keyword">true</span>);</span><br><span class="line">            out.println(key);</span><br><span class="line">            System.out.println(<span class="string">"查询的结果为："</span> + in.readLine());</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(in != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    in.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                in = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(out != <span class="keyword">null</span>)&#123;</span><br><span class="line">                out.close();</span><br><span class="line">                out = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(socket != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                socket = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        Client client = <span class="keyword">new</span> Client();</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">            String key = scanner.next();</span><br><span class="line">            client.send(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中可以得知，我们每次请求都是new Thread去处理，意味着线程消耗巨大，可能会有朋友说道，那就用线程池，同样的如果使用线程池，当达到线程最大数量，也会达到瓶颈。该模式不适合高并发的访问。</p><h2 id="12-nio模型"><a class="markdownIt-Anchor" href="#12-nio模型"></a> 1.2 NIO模型</h2><p>NIO提供了与传统BIO模型中的Socket和ServerSocket相对应的SocketChannel和ServerSocketChannel两种不同的套接字通道实现。<br>  新增的着两种通道都支持阻塞和非阻塞两种模式。<br>阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。<br>对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用NIO的非阻塞模式来开发。<br>下面会先对基础知识进行介绍。</p><h3 id="121-缓冲区-buffer"><a class="markdownIt-Anchor" href="#121-缓冲区-buffer"></a> 1.2.1、缓冲区 Buffer</h3><p>Buffer是一个对象，包含一些要写入或者读出的数据。</p><p>在NIO库中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的；在写入数据时，也是写入到缓冲区中。任何时候访问NIO中的数据，都是通过缓冲区进行操作。<br>缓冲区实际上是一个数组，并提供了对数据结构化访问以及维护读写位置等信息。<br>   具体的缓存区有这些：ByteBuffe、CharBuffer、 ShortBuffer、IntBuffer、LongBuffer、FloatBuffer、DoubleBuffer。他们实现了相同的接口：Buffer。</p><h3 id="122-通道-channel"><a class="markdownIt-Anchor" href="#122-通道-channel"></a> 1.2.2、通道 Channel</h3><p>我们对数据的读取和写入要通过Channel，它就像水管一样，是一个通道。通道不同于流的地方就是通道是双向的，可以用于读、写和同时读写操作。<br>  底层的操作系统的通道一般都是全双工的，所以全双工的Channel比流能更好的映射底层操作系统的API。<br>Channel主要分两大类：</p><ul><li>SelectableChannel：用户网络读写</li><li>FileChannel：用于文件操作</li></ul><p>后面代码会涉及的ServerSocketChannel和SocketChannel都是SelectableChannel的子类。</p><h3 id="1-23-多路复用器-selector"><a class="markdownIt-Anchor" href="#1-23-多路复用器-selector"></a> 1. 2.3、多路复用器 Selector</h3><p>Selector是Java  NIO 编程的基础。<br>Selector提供选择已经就绪的任务的能力：Selector会不断轮询注册在其上的Channel，如果某个Channel上面发生读或者写事件，这个Channel就处于就绪状态，会被Selector轮询出来，然后通过SelectionKey可以获取就绪Channel的集合，进行后续的I/O操作。<br>一个Selector可以同时轮询多个Channel，因为JDK使用了epoll()代替传统的select实现，所以没有最大连接句柄1024/2048的限制。所以，只需要一个线程负责Selector的轮询，就可以接入成千上万的客户端。<br>服务端代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认端口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer DEFAULT_PORT = <span class="number">6780</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        start(DEFAULT_PORT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">start</span><span class="params">(Integer port)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 打开多路复用选择器</span></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        <span class="comment">//  打开服务端监听通道</span></span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        <span class="comment">// 设置为非阻塞模式</span></span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 绑定监听的端口</span></span><br><span class="line">        serverSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line">        <span class="comment">// 将选择器绑定到监听信道,只有非阻塞信道才可以注册选择器.并在注册过程中指出该信道可以进行Accept操作</span></span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        System.out.println(<span class="string">"小yu机器人启动，监听端口为："</span> + port);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> ServerHandler(selector)).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Server().start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端处理器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerHandler</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServerHandler</span><span class="params">(Selector selector)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.selector = selector;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 等待某信道就绪(或超时)</span></span><br><span class="line">            <span class="keyword">if</span>(selector.select(<span class="number">1000</span>)==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">//                System.out.print("独自等待.");</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 取得迭代器.selectedKeys()中包含了每个准备好某一I/O操作的信道的SelectionKey</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; keyIterator=selector.selectedKeys().iterator();</span><br><span class="line">           <span class="keyword">while</span> (keyIterator.hasNext())&#123;</span><br><span class="line">               SelectionKey sk = keyIterator.next();</span><br><span class="line">               <span class="comment">// 删除已选的key 以防重负处理</span></span><br><span class="line">               keyIterator.remove();</span><br><span class="line">               <span class="comment">// 处理key</span></span><br><span class="line">               handlerSelect(sk);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handlerSelect</span><span class="params">(SelectionKey sk)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 处理新接入的请求</span></span><br><span class="line">        <span class="keyword">if</span> (sk.isAcceptable()) &#123;</span><br><span class="line">            ServerSocketChannel ssc = (ServerSocketChannel) sk.channel();</span><br><span class="line">            <span class="comment">//通过ServerSocketChannel的accept创建SocketChannel实例</span></span><br><span class="line">            <span class="comment">//完成该操作意味着完成TCP三次握手，TCP物理链路正式建立</span></span><br><span class="line">            SocketChannel sc = ssc.accept();</span><br><span class="line">            <span class="comment">//设置为非阻塞的</span></span><br><span class="line">            sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">//注册为读</span></span><br><span class="line">            sc.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 读操作</span></span><br><span class="line">        <span class="keyword">if</span> (sk.isReadable()) &#123;</span><br><span class="line">            String request, response;</span><br><span class="line">            SocketChannel sc = (SocketChannel) sk.channel();</span><br><span class="line">            <span class="comment">// 创建一个ByteBuffer 并设置大小为1m</span></span><br><span class="line">            ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            <span class="comment">// 获取到读取的字节长度</span></span><br><span class="line">            <span class="keyword">int</span> readBytes = sc.read(byteBuffer);</span><br><span class="line">            <span class="comment">// 判断是否有数据</span></span><br><span class="line">            <span class="keyword">if</span> (readBytes &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//将缓冲区当前的limit设置为position=0，用于后续对缓冲区的读取操作</span></span><br><span class="line">                byteBuffer.flip();</span><br><span class="line">                <span class="comment">//根据缓冲区可读字节数创建字节数组</span></span><br><span class="line">                <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[byteBuffer.remaining()];</span><br><span class="line">                <span class="comment">// 复制至新的缓冲字节流</span></span><br><span class="line">                byteBuffer.get(bytes);</span><br><span class="line">                request = <span class="keyword">new</span> String(bytes, <span class="string">"UTF-8"</span>);</span><br><span class="line">                System.out.println(<span class="string">"["</span> + Thread.currentThread().getName()+ <span class="string">"]"</span> + <span class="string">"小yu机器人收到消息："</span> + request);</span><br><span class="line">                <span class="comment">// 具体业务逻辑处理 查询信息。</span></span><br><span class="line">                response = ResponseUtil.queryMessage(request);</span><br><span class="line">                <span class="comment">//将消息编码为字节数组</span></span><br><span class="line">                <span class="keyword">byte</span>[] responseBytes = response.getBytes();</span><br><span class="line">                <span class="comment">//根据数组容量创建ByteBuffer</span></span><br><span class="line">                ByteBuffer writeBuffer = ByteBuffer.allocate(responseBytes.length);</span><br><span class="line">                <span class="comment">//将字节数组复制到缓冲区</span></span><br><span class="line">                writeBuffer.put(responseBytes);</span><br><span class="line">                <span class="comment">//flip操作</span></span><br><span class="line">                writeBuffer.flip();</span><br><span class="line">                <span class="comment">//发送缓冲区的字节数组</span></span><br><span class="line">                sc.write(writeBuffer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通道选择器</span></span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 与服务器通信的通道</span></span><br><span class="line">    SocketChannel socketChannel;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认端口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer DEFAULT_PORT = <span class="number">6780</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认端口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_HOST = <span class="string">"127.0.0.1"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">send</span><span class="params">(String key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        send(DEFAULT_PORT, DEFAULT_HOST, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">send</span><span class="params">(<span class="keyword">int</span> port,String host, String key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        init(port, host);</span><br><span class="line">        System.out.println(<span class="string">"查询的key为："</span> + key);</span><br><span class="line">        <span class="comment">//将消息编码为字节数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = key.getBytes();</span><br><span class="line">        <span class="comment">//根据数组容量创建ByteBuffer</span></span><br><span class="line">        ByteBuffer writeBuffer = ByteBuffer.allocate(bytes.length);</span><br><span class="line">        <span class="comment">//将字节数组复制到缓冲区</span></span><br><span class="line">        writeBuffer.put(bytes);</span><br><span class="line">        <span class="comment">//flip操作</span></span><br><span class="line">        writeBuffer.flip();</span><br><span class="line">        <span class="comment">//发送缓冲区的字节数组</span></span><br><span class="line">        socketChannel.write(writeBuffer);</span><br><span class="line">        <span class="comment">//****此处不含处理“写半包”的代码</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> port,String host)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建选择器</span></span><br><span class="line">        selector = Selector.open();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置链接的服务端地址</span></span><br><span class="line">        InetSocketAddress socketAddress = <span class="keyword">new</span> InetSocketAddress(host, port);</span><br><span class="line">        <span class="comment">// 打开通道</span></span><br><span class="line">        socketChannel = SocketChannel.open(socketAddress);<span class="comment">// 非阻塞</span></span><br><span class="line">        socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> ClientHandler(selector)).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        Client client = <span class="keyword">new</span> Client();</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">            String key = scanner.next();</span><br><span class="line">            client.send(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端处理器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientHandler</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClientHandler</span><span class="params">(Selector selector)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.selector = selector;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(selector.select(<span class="number">1000</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                 <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">                Iterator&lt;SelectionKey&gt; selectionKeyIterator = keys.iterator();</span><br><span class="line">                <span class="keyword">while</span> (selectionKeyIterator.hasNext()) &#123;</span><br><span class="line">                    SelectionKey sc = selectionKeyIterator.next();</span><br><span class="line">                    selectionKeyIterator.remove();</span><br><span class="line">                    <span class="comment">//读消息</span></span><br><span class="line">                    <span class="keyword">if</span> (sc.isReadable()) &#123;</span><br><span class="line">                        SocketChannel socketChannel = (SocketChannel) sc.channel();</span><br><span class="line">                        <span class="comment">//创建ByteBuffer，并开辟一个1M的缓冲区</span></span><br><span class="line"></span><br><span class="line">                        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                        <span class="comment">//读取请求码流，返回读取到的字节数</span></span><br><span class="line">                        <span class="keyword">int</span> byteSize = socketChannel.read(byteBuffer);</span><br><span class="line">                        <span class="keyword">if</span> (byteSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">//将缓冲区当前的limit设置为position=0，用于后续对缓冲区的读取操作</span></span><br><span class="line">                            byteBuffer.flip();</span><br><span class="line">                            <span class="comment">//根据缓冲区可读字节数创建字节数组 总长度减去空余的</span></span><br><span class="line">                            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[byteBuffer.remaining()];</span><br><span class="line">                            <span class="comment">// 复制至新的缓冲字节流</span></span><br><span class="line">                            byteBuffer.get(bytes);</span><br><span class="line">                            String message = <span class="keyword">new</span> String(bytes, <span class="string">"UTF-8"</span>);</span><br><span class="line">                            System.out.println(message);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中 我们也能看出来，nio解决的是阻塞与非阻塞的，通过selector轮询上注册的channel的状态，来获取对应准备就绪channel的 那么请求者就不用一直去accpet阻塞，等待了。那为什么是同步呢，因为还是我们请求者不停的轮询selector是否有完全就绪的channel。</p><h1 id="3-aio编程"><a class="markdownIt-Anchor" href="#3-aio编程"></a> 3、AIO编程</h1><p>NIO 2.0引入了新的异步通道的概念，并提供了异步文件通道和异步套接字通道的实现。<br>异步的套接字通道时真正的异步非阻塞I/O，对应于UNIX网络编程中的事件驱动I/O（AIO）。他不需要过多的Selector对注册的通道进行轮询即可实现异步读写，从而简化了NIO的编程模型。<br>服务端代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  异步非阻塞服务端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sever</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认端口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer DEFAULT_PORT = <span class="number">6780</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AsynchronousServerSocketChannel serverChannel;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//作为handler接收客户端连接</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ServerCompletionHandler</span> <span class="keyword">implements</span> <span class="title">CompletionHandler</span>&lt;<span class="title">AsynchronousSocketChannel</span>, <span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> AsynchronousServerSocketChannel serverChannel;</span><br><span class="line">        <span class="keyword">private</span> ByteBuffer buffer = ByteBuffer.allocateDirect(<span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">private</span> CharBuffer charBuffer;</span><br><span class="line">        <span class="keyword">private</span> CharsetDecoder decoder = Charset.defaultCharset().newDecoder();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ServerCompletionHandler</span><span class="params">(AsynchronousServerSocketChannel serverChannel)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.serverChannel = serverChannel;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(AsynchronousSocketChannel result, Void attachment)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//立即接收下一个请求,不停顿</span></span><br><span class="line">            serverChannel.accept(<span class="keyword">null</span>, <span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (result.read(buffer).get() != -<span class="number">1</span>) &#123;</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    charBuffer = decoder.decode(buffer);</span><br><span class="line">                    String request = charBuffer.toString().trim();</span><br><span class="line">                    System.out.println(<span class="string">"["</span> + Thread.currentThread().getName()+ <span class="string">"]"</span> + <span class="string">"小yu机器人收到消息："</span> + request);</span><br><span class="line">                    <span class="comment">// 具体业务逻辑处理 查询信息。</span></span><br><span class="line">                    String response = ResponseUtil.queryMessage(request);</span><br><span class="line">                    <span class="comment">//将消息编码为字节数组</span></span><br><span class="line">                    <span class="keyword">byte</span>[] responseBytes = response.getBytes();</span><br><span class="line">                    <span class="comment">//根据数组容量创建ByteBuffer</span></span><br><span class="line">                    ByteBuffer outBuffer = ByteBuffer.allocate(responseBytes.length);</span><br><span class="line">                    <span class="comment">//将字节数组复制到缓冲区</span></span><br><span class="line">                    outBuffer.put(responseBytes);</span><br><span class="line">                    <span class="comment">//flip操作</span></span><br><span class="line">                    outBuffer.flip();</span><br><span class="line">                    <span class="comment">//发送缓冲区的字节数组</span></span><br><span class="line">                    result.write(outBuffer).get();</span><br><span class="line">                    <span class="keyword">if</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">                        buffer.compact();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        buffer.clear();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (CharacterCodingException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    result.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, Void attachment)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//立即接收下一个请求,不停顿</span></span><br><span class="line">            serverChannel.accept(<span class="keyword">null</span>, <span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"connection failed!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        init(DEFAULT_PORT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Integer port)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 打开异步通道</span></span><br><span class="line">        <span class="keyword">this</span>.serverChannel = AsynchronousServerSocketChannel.open();</span><br><span class="line">        <span class="comment">// 判断通道是否打开</span></span><br><span class="line">        <span class="keyword">if</span> (serverChannel.isOpen()) &#123;</span><br><span class="line">            serverChannel.setOption(StandardSocketOptions.SO_RCVBUF, <span class="number">4</span> * <span class="number">1024</span>);</span><br><span class="line">            serverChannel.setOption(StandardSocketOptions.SO_REUSEADDR, <span class="keyword">true</span>);</span><br><span class="line">            serverChannel.bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Channel not opened!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        start(port);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(Integer port)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"小yu机器人启动，监听端口为："</span> + port);</span><br><span class="line">        <span class="keyword">this</span>.serverChannel.accept(<span class="keyword">null</span>, <span class="keyword">new</span> ServerCompletionHandler(serverChannel));</span><br><span class="line">        <span class="comment">// 保证线程不会挂了</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        Sever server = <span class="keyword">new</span> Sever();</span><br><span class="line">        server.init();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ClientCompletionHandler</span> <span class="keyword">implements</span> <span class="title">CompletionHandler</span>&lt;<span class="title">Void</span>, <span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> AsynchronousSocketChannel channel;</span><br><span class="line">        <span class="keyword">private</span> CharBuffer charBufferr = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">private</span> CharsetDecoder decoder = Charset.defaultCharset().newDecoder();</span><br><span class="line">        <span class="keyword">private</span> BufferedReader clientInput = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ClientCompletionHandler</span><span class="params">(AsynchronousSocketChannel channel)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.channel = channel;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Void result, Void attachment)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"Input Client Reuest:"</span>);</span><br><span class="line">            String request;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                request = clientInput.readLine();</span><br><span class="line">                channel.write(ByteBuffer.wrap(request.getBytes()));</span><br><span class="line">                ByteBuffer buffer = ByteBuffer.allocateDirect(<span class="number">1024</span>);</span><br><span class="line">                <span class="keyword">while</span>(channel.read(buffer).get() != -<span class="number">1</span>)&#123;</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    charBufferr = decoder.decode(buffer);</span><br><span class="line">                    System.out.println(charBufferr.toString());</span><br><span class="line">                    <span class="keyword">if</span>(buffer.hasRemaining())&#123;</span><br><span class="line">                        buffer.compact();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        buffer.clear();</span><br><span class="line">                    &#125;</span><br><span class="line">                    request = clientInput.readLine();</span><br><span class="line">                    channel.write(ByteBuffer.wrap(request.getBytes())).get();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    channel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, Void attachment)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span>  <span class="keyword">new</span>  RuntimeException(<span class="string">"channel not opened!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException</span>&#123;</span><br><span class="line">        AsynchronousSocketChannel channel = AsynchronousSocketChannel.open();</span><br><span class="line">        <span class="keyword">if</span>(channel.isOpen())&#123;</span><br><span class="line">            channel.setOption(StandardSocketOptions.SO_RCVBUF, <span class="number">128</span>*<span class="number">1024</span>);</span><br><span class="line">            channel.setOption(StandardSocketOptions.SO_SNDBUF, <span class="number">128</span>*<span class="number">1024</span>);</span><br><span class="line">            channel.setOption(StandardSocketOptions.SO_KEEPALIVE,<span class="keyword">true</span>);</span><br><span class="line">            channel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>,<span class="number">6780</span>),<span class="keyword">null</span>,<span class="keyword">new</span> ClientCompletionHandler(channel));</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Channel not opened!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException</span>&#123;</span><br><span class="line">        Client client = <span class="keyword">new</span> Client();</span><br><span class="line">        client.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-各种io的对比"><a class="markdownIt-Anchor" href="#4-各种io的对比"></a> 4、各种I/O的对比</h1><p>先以一张表来直观的对比一下：<br><img src="/Users/yukong/Desktop/2019-05-07-055246.png" alt=""></p><h1 id="5"><a class="markdownIt-Anchor" href="#5"></a> 5</h1><p>References<br><a href="https://zhuanlan.zhihu.com/p/22707398" target="_blank" rel="noopener">完全理解同步/异步与阻塞/非阻塞</a><br><a href="https://blog.csdn.net/anxpp/article/details/51512200" target="_blank" rel="noopener">Java 网络IO编程总结</a><br>下面是配套的完整代码地址<br><a href="https://github.com/YuKongEr/io-study" target="_blank" rel="noopener">完整代码地址</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文内容涉及同步与异步, 阻塞与非阻塞, BIO、NIO、AIO等概念, 这块内容本身比较复杂, 很难用三言两语说明白. 而书上的定义更不容易理解是什么意思. 下面跟着我一起解开它们神秘的面纱。&lt;/p&gt;
    
    </summary>
    
      <category term="java网络编程" scheme="http://www.yukonga.cn/categories/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="NIO" scheme="http://www.yukonga.cn/tags/NIO/"/>
    
      <category term="AIO" scheme="http://www.yukonga.cn/tags/AIO/"/>
    
      <category term="BIO" scheme="http://www.yukonga.cn/tags/BIO/"/>
    
      <category term="Socket" scheme="http://www.yukonga.cn/tags/Socket/"/>
    
  </entry>
  
  <entry>
    <title>【SpringBoot2.0系列09】SpringBoot之rabbitmq使用</title>
    <link href="http://www.yukonga.cn/2018/08/22/%E3%80%90SpringBoot2-0%E7%B3%BB%E5%88%9709%E3%80%91SpringBoot%E4%B9%8Brabbitmq%E4%BD%BF%E7%94%A8/"/>
    <id>http://www.yukonga.cn/2018/08/22/【SpringBoot2-0系列09】SpringBoot之rabbitmq使用/</id>
    <published>2018-08-22T13:44:02.000Z</published>
    <updated>2019-05-07T06:14:09.987Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>消息队列中间件是分布式系统中重要的组件，主要解决应用耦合，异步消息，流量削锋等问题实现高性能，高可用，可伸缩和最终一致性<a href="http://lib.csdn.net/base/architecture" title="大型网站架构知识库" target="_blank" rel="noopener">架构</a><br>使用较多的消息队列有ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaMQ，RocketMQ。<br>今天我们将会了解到在<code>SpringBoot</code>中使用<code>rabbitmq</code></p><a id="more"></a></blockquote><h1 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h1><h2 id="11-rabbitmq简介"><a class="markdownIt-Anchor" href="#11-rabbitmq简介"></a> 1.1 rabbitmq简介</h2><p>RabbitMQ是由Erlang语言编写的实现了高级消息队列协议（AMQP）的开源消息代理软件（也可称为 面向消息的中间件）。支持Windows、Linux/Unix、MAC OS X操作系统和包括JAVA在内的多种编程语言。</p><p>AMQP，即Advanced Message Queuing Protocol，一个提供统一消息服务的应用层标准高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受 客户端/中间件 不同产品，不同的开发语言等条件的限制<br>使用<code>rabbitmq</code>主要三种分发模式</p><h3 id="111-工作队列模式work-queue"><a class="markdownIt-Anchor" href="#111-工作队列模式work-queue"></a> 1.1.1 工作队列模式(Work Queue)</h3><p>避免立即做一个资源密集型任务，必须等待它完成，而是把这个任务安排到稍后再做。我们将任务封装为消息并将其发送给队列。后台运行的工作进程将弹出任务并最终执行作业。当有多个worker同时运行时，任务将在它们之间共享。<br><img src="http://cdn.yukonga.cn/2019-05-07-060951.jpg" alt=""></p><h3 id="112-分发模式fanout-exchange"><a class="markdownIt-Anchor" href="#112-分发模式fanout-exchange"></a> 1.1.2 分发模式(Fanout Exchange)</h3><p>一个生产者，多个消费者，每一个消费者都有自己的一个队列，生产者没有将消息直接发送到队列，而是发送到了交换机，每个队列绑定交换机，生产者发送的消息经过交换机，到达队列，实现一个消息被多个消费者获取的目的。需要注意的是，如果将消息发送到一个没有队列绑定的exchange上面，那么该消息将会丢失，这是因为在rabbitMQ中exchange不具备存储消息的能力，只有队列具备存储消息的能力。<br><img src="http://cdn.yukonga.cn/2019-05-07-061001.jpg" alt=""><br><img src="http://cdn.yukonga.cn/2019-05-07-061011.jpg" alt=""></p><h3 id="113-通配符模式topic-exchange"><a class="markdownIt-Anchor" href="#113-通配符模式topic-exchange"></a> 1.1.3  通配符模式（Topic Exchange）</h3><p>这种模式添加了一个路由键，生产者发布消息的时候添加路由键，消费者绑定队列到交换机时添加键值，这样就可以接收到需要接收的消息。<br>符号“#”匹配一个或多个词，符号“*”匹配不多不少一个词<br><img src="http://cdn.yukonga.cn/2019-05-07-061021.jpg" alt=""></p><p><img src="http://cdn.yukonga.cn/2019-05-07-061029.jpg" alt=""></p><h2 id="12-安装rabbitmq"><a class="markdownIt-Anchor" href="#12-安装rabbitmq"></a> 1.2、安装rabbitmq</h2><h3 id="121-window"><a class="markdownIt-Anchor" href="#121-window"></a> 1.2.1 window</h3><p>因为<code>rabbitmq</code>是<code>erlang</code>实现，所以我们需要先下载安装<code>erlang</code>，然后再下载<code>rabbitmq</code></p><h3 id="122-mac"><a class="markdownIt-Anchor" href="#122-mac"></a> 1.2.2 mac</h3><p>在mac系统中可以直接使用<code>brew</code>安装，它会帮我们自动安装管理依赖。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew update</span><br><span class="line">brew install rabbitmq</span><br></pre></td></tr></table></figure><p>这样，我们就可以使用<code>rabbit-server</code>启动Rabbit服务了。</p><h3 id="123-centos"><a class="markdownIt-Anchor" href="#123-centos"></a> 1.2.3 centos</h3><p>在centos中可以使用<code>yum</code>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install rabbitmq</span><br></pre></td></tr></table></figure><h2 id="13-springboot整合"><a class="markdownIt-Anchor" href="#13-springboot整合"></a> 1.3 springboot整合</h2><p>首先新建一个项目名为rabbit-producer 消息生产者工程<br>并且添加依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在yml配置rabbitmq地址</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rabbitmq配置</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">    rabbitmq:</span></span><br><span class="line"><span class="attr">      addresses:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"><span class="attr">      username:</span> <span class="string">guest</span></span><br><span class="line"><span class="attr">      password:</span> <span class="attr">guest:</span></span><br></pre></td></tr></table></figure><p>同理创建<code>rabbit-consumer</code> 消息消费者工程</p><h3 id="1-普通工作队列模式"><a class="markdownIt-Anchor" href="#1-普通工作队列模式"></a> 1、普通工作队列模式</h3><p>首先在<code>rabbit-producer</code>工程中新建<code>RabbitConfig</code>文件，用于配置我们rabbitmq相关的资源<br>代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukong.rabbitproducer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yukong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/8/22</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> rabbitmq配置类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义队列名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String STRING = <span class="string">"string"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义string队列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">string</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(STRING);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义了名为string的队列。然后我们创建生产者<code>RabbitProducer</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukong.rabbitproducer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.AmqpTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.xml.ws.Action;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yukong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/8/22</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> rabbit消息生产者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AmqpTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stringSend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        String dateString = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"YYYY-mm-DD hh:MM:ss"</span>).format(date);</span><br><span class="line">        System.out.println(<span class="string">"[string] send msg:"</span> + dateString);  </span><br><span class="line">      <span class="comment">// 第一个参数为刚刚定义的队列名称</span></span><br><span class="line">        <span class="keyword">this</span>.rabbitTemplate.convertAndSend(<span class="string">"string"</span>, dateString);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里注入一个<code>AmqpTemplate</code>来发布消息<br>接下来我们需要在<code>rabbit-consumer</code>工程配置一下消费者。<br>创建<code>StringConsumer</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukong.rabbitmqconsumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.AmqpTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yukong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/8/22</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> rabbitmq消费者 <span class="doctag">@RabbitListener</span>(queues = "simpleMsg") 监听名simpleMsg的队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"string"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span> <span class="keyword">private</span> AmqpTemplate rabbitmqTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息消费</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@RabbitHandler</span> 代表此方法为接受到消息后的处理方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recieved</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"[string] recieved message:"</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每一个注解的作用代码里面的注释说的很详细了我就不重复说了。<br>然后我们来测试，<br>首先在生产者工程新建一个测试类，用于生产消息。<br>代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukong.rabbitproducer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitProducerApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitProducer producer;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testStringSend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            producer.stringSend();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先启动生产者工程的测试类。然后再启动消费者工程。<br><img src="http://cdn.yukonga.cn/2019-05-07-061040.jpg" alt=""><br>消息生产成功，一共十条。<br>启动消费者工程。<br><img src="http://cdn.yukonga.cn/2019-05-07-061056.jpg" alt=""><br>消费者成功消费消息。<br>2、 fanout模式<br>fanout属于广播模式，只要跟它绑定的队列都会通知并且接受到消息。<br>我们同理在<code>RabbitConfig</code>中配置一下fanout模式的队列跟交换机。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//=================== fanout 模式  ====================</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">fanoutA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"fanout.a"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">fanoutB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"fanout.b"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">fanoutC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"fanout.c"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义个fanout交换器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">FanoutExchange <span class="title">fanoutExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义一个名为fanoutExchange的fanout交换器</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FanoutExchange(<span class="string">"fanoutExchange"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将定义的fanoutA队列与fanoutExchange交换机绑定</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bindingExchangeWithA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutA()).to(fanoutExchange());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将定义的fanoutB队列与fanoutExchange交换机绑定</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bindingExchangeWithB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutB()).to(fanoutExchange());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将定义的fanoutC队列与fanoutExchange交换机绑定</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bindingExchangeWithC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutC()).to(fanoutExchange());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在代码中我们配置了三个队列名、一个fanout交换机，并且将这三个队列绑定到了fanout交换器上。只要我们往这个交换机生产新的消息，那么这三个队列都会收到。<br>接下来，我们在<code>RabbitProducer</code> 中添加fanout的生产方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fanoutSend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        String dateString = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"YYYY-mm-DD hh:MM:ss"</span>).format(date);</span><br><span class="line">        System.out.println(<span class="string">"[fanout] send msg:"</span> + dateString);</span><br><span class="line">        <span class="comment">// 注意 第一个参数是我们交换机的名称 ，第二个参数是routerKey 我们不用管空着就可以，第三个是你要发送的消息</span></span><br><span class="line">        <span class="keyword">this</span>.rabbitTemplate.convertAndSend(<span class="string">"fanoutExchange"</span>, <span class="string">""</span>, dateString);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>同理我们需要在消费者工程新建三个消费者的类<br>代码分别如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"fanout.a"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanoutAConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AmqpTemplate rabbitmqTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息消费</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@RabbitHandler</span> 代表此方法为接受到消息后的处理方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recieved</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"[fanout.a] recieved message:"</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"fanout.b"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanoutBConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AmqpTemplate rabbitmqTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息消费</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@RabbitHandler</span> 代表此方法为接受到消息后的处理方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recieved</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"[fanout.b] recieved message:"</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Component</span></span><br><span class="line"><span class="variable">@RabbitListener</span>(queues = <span class="string">"fanout.c"</span>)</span><br><span class="line">public class FanoutCConsumer &#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@Autowired</span></span><br><span class="line">    private AmqpTemplate rabbitmqTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息消费</span></span><br><span class="line"><span class="comment">     * @RabbitHandler 代表此方法为接受到消息后的处理方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="variable">@RabbitHandler</span></span><br><span class="line">    public void recieved(String msg) &#123;</span><br><span class="line">        <span class="selector-tag">System</span><span class="selector-class">.out</span><span class="selector-class">.println</span>(<span class="string">"[fanout.c] recieved message:"</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后编写一个名为<code>testFanout()</code>的方法启动我们的fanout生产方法，</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"> <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">testFanoutSend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     producer.fanoutSend();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><img src="http://cdn.yukonga.cn/2019-05-07-061109.jpg" alt=""></p><p>然后重启消费者工程</p><p><img src="http://cdn.yukonga.cn/2019-05-07-061326.jpg" alt=""></p><p>三个队列的消费都成功接收到消息。<br>3、topic模式，<br>同样，配置topic队列跟交换器，注意的是这里需要多配置一个bindingKey</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#################topic模式########################</span></span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Queue <span class="title">topiocA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"topic.a"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Queue <span class="title">topicB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"topic.b"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Queue <span class="title">topicC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"topic.c"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 定义个topic交换器</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function">TopicExchange <span class="title">topicExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 定义一个名为fanoutExchange的fanout交换器</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> TopicExchange(<span class="string">"topicExchange"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 将定义的topicA队列与topicExchange交换机绑定</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Binding <span class="title">bindingTopicExchangeWithA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> BindingBuilder.bind(topiocA()).to(topicExchange()).with(<span class="string">"topic.msg"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 将定义的topicB队列与topicExchange交换机绑定</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Binding <span class="title">bindingTopicExchangeWithB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> BindingBuilder.bind(topicB()).to(topicExchange()).with(<span class="string">"topic.#"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 将定义的topicC队列与topicExchange交换机绑定</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Binding <span class="title">bindingTopicExchangeWithC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> BindingBuilder.bind(topicC()).to(topicExchange()).with(<span class="string">"topic.*.z"</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>topicA的key为topic.msg 那么他只会接收包含topic.msg的消息</li><li>topicB的key为topic.#那么他只会接收topic开头的消息</li><li>topicC的key为topic.*.Z那么他只会接收topic.B.z这样格式的消息<br>同理在<code>RabbitProducer</code>完成topic生产方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">topicTopic1Send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        String dateString = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"YYYY-mm-DD hh:MM:ss"</span>).format(date);</span><br><span class="line">        dateString = <span class="string">"[topic.msg] send msg:"</span> + dateString;</span><br><span class="line">        System.out.println(dateString);</span><br><span class="line">        <span class="comment">// 注意 第一个参数是我们交换机的名称 ，第二个参数是routerKey topic.msg，第三个是你要发送的消息</span></span><br><span class="line">        <span class="comment">// 这条信息将会被 topic.a  topic.b接收</span></span><br><span class="line">        <span class="keyword">this</span>.rabbitTemplate.convertAndSend(<span class="string">"topicExchange"</span>, <span class="string">"topic.msg"</span>, dateString);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">topicTopic2Send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        String dateString = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"YYYY-mm-DD hh:MM:ss"</span>).format(date);</span><br><span class="line">        dateString = <span class="string">"[topic.good.msg] send msg:"</span> + dateString;</span><br><span class="line">        System.out.println(dateString);</span><br><span class="line">        <span class="comment">// 注意 第一个参数是我们交换机的名称 ，第二个参数是routerKey ，第三个是你要发送的消息</span></span><br><span class="line">        <span class="comment">// 这条信息将会被topic.b接收</span></span><br><span class="line">        <span class="keyword">this</span>.rabbitTemplate.convertAndSend(<span class="string">"topicExchange"</span>, <span class="string">"topic.good.msg"</span>, dateString);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">topicTopic3Send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        String dateString = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"YYYY-mm-DD hh:MM:ss"</span>).format(date);</span><br><span class="line">        dateString = <span class="string">"[topic.m.z] send msg:"</span> + dateString;</span><br><span class="line">        System.out.println(dateString);</span><br><span class="line">        <span class="comment">// 注意 第一个参数是我们交换机的名称 ，第二个参数是routerKey ，第三个是你要发送的消息</span></span><br><span class="line">        <span class="comment">// 这条信息将会被topic.b、topic.b接收</span></span><br><span class="line">        <span class="keyword">this</span>.rabbitTemplate.convertAndSend(<span class="string">"topicExchange"</span>, <span class="string">"topic.m.z"</span>, dateString);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后在消费者工程新建队列队列的消费类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"topic.a"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicAConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AmqpTemplate rabbitmqTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息消费</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@RabbitHandler</span> 代表此方法为接受到消息后的处理方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recieved</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"[topic.a] recieved message:"</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Component</span></span><br><span class="line"><span class="variable">@RabbitListener</span>(queues = <span class="string">"topic.b"</span>)</span><br><span class="line">public class TopicBConsumer &#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@Autowired</span></span><br><span class="line">    private AmqpTemplate rabbitmqTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息消费</span></span><br><span class="line"><span class="comment">     * @RabbitHandler 代表此方法为接受到消息后的处理方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="variable">@RabbitHandler</span></span><br><span class="line">    public void recieved(String msg) &#123;</span><br><span class="line">        <span class="selector-tag">System</span><span class="selector-class">.out</span><span class="selector-class">.println</span>(<span class="string">"[topic.b] recieved message:"</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Component</span></span><br><span class="line"><span class="variable">@RabbitListener</span>(queues = <span class="string">"topic.c"</span>)</span><br><span class="line">public class TopicCConsumer &#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@Autowired</span></span><br><span class="line">    private AmqpTemplate rabbitmqTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息消费</span></span><br><span class="line"><span class="comment">     * @RabbitHandler 代表此方法为接受到消息后的处理方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="variable">@RabbitHandler</span></span><br><span class="line">    public void recieved(String msg) &#123;</span><br><span class="line">        <span class="selector-tag">System</span><span class="selector-class">.out</span><span class="selector-class">.println</span>(<span class="string">"[topic.c] recieved message:"</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理为topic新建测试方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTopic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       producer.topicTopic1Send();</span><br><span class="line">       producer.topicTopic2Send();</span><br><span class="line">       producer.topicTopic3Send();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><img src="http://cdn.yukonga.cn/2019-05-07-061340.jpg" alt=""><br>消息成功发出。<br>启动消费者工程，看看消息是不是按照规则被发送消息<br><img src="http://cdn.yukonga.cn/2019-05-07-061402.jpg" alt=""><br>其中 队列topic.a只配置topic.msg一条消息，正确<br>其中 队列topic.b匹配三条消息，因为三条消息都是topic开头的 正确<br>其中 队列topic.c匹配一条消息，只有一条消息满足（也就是topic.m.z这条消息）</p><p>最后配套教程的代码全部在这里<br><a href="https://github.com/YuKongEr/SpringBoot-Study" target="_blank" rel="noopener">github https://github.com/YuKongEr/SpringBoot-Study</a>。麻烦点个star或者fork吧。</p><p>欢迎大家关注一下我的个人公众号。一起交流一起学习，有问必答。<br><img src="http://cdn.yukonga.cn/2019-05-07-055539.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;消息队列中间件是分布式系统中重要的组件，主要解决应用耦合，异步消息，流量削锋等问题实现高性能，高可用，可伸缩和最终一致性&lt;a href=&quot;http://lib.csdn.net/base/architecture&quot; title=&quot;大型网站架构知识库&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;架构&lt;/a&gt;&lt;br&gt;
使用较多的消息队列有ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaMQ，RocketMQ。&lt;br&gt;
今天我们将会了解到在&lt;code&gt;SpringBoot&lt;/code&gt;中使用&lt;code&gt;rabbitmq&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="SpringBoot" scheme="http://www.yukonga.cn/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="http://www.yukonga.cn/tags/SpringBoot/"/>
    
      <category term="RabbitMQ" scheme="http://www.yukonga.cn/tags/RabbitMQ/"/>
    
  </entry>
  
</feed>
