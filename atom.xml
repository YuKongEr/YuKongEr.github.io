<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yukong&#39;s blog</title>
  
  <subtitle>learning program</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.yukonga.cn/"/>
  <updated>2020-04-19T13:05:04.680Z</updated>
  <id>http://www.yukonga.cn/</id>
  
  <author>
    <name>yukong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>127. Word Ladder</title>
    <link href="http://www.yukonga.cn/2020/04/19/127-Word-Ladder/"/>
    <id>http://www.yukonga.cn/2020/04/19/127-Word-Ladder/</id>
    <published>2020-04-19T13:04:07.000Z</published>
    <updated>2020-04-19T13:05:04.680Z</updated>
    
    <content type="html"><![CDATA[<h2 id="127-word-ladder"><a class="markdownIt-Anchor" href="#127-word-ladder"></a> <a href="https://leetcode-cn.com/problems/word-ladder/" target="_blank" rel="noopener">127. Word Ladder</a></h2><blockquote><p>原题链接 <a href="https://leetcode-cn.com/problems/word-ladder/" target="_blank" rel="noopener">127. Word Ladder</a></p></blockquote><p><img src="http://images.yukonga.cn/20200419210443.png" alt="image-20200419210053473"></p><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><p>由题目可得我们需要判断一个单词通过词典列表给的词是否能转换到另一个单词 如果能最少转换次数是多少，且每次转换只能转换一个字符。</p><p>其实我们完全可以把这个过程抽象成一个图，那么这题就变成了图中一个节点到另一个节点的最短路径。</p><p><img src="http://images.yukonga.cn/20200419210443.png" alt="Word_Ladder_1.png"></p><p>在图中 求最短路径可以通过bfs算法实现。</p><h2 id="ac代码"><a class="markdownIt-Anchor" href="#ac代码"></a> AC代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bfs</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!wordList.contains(endWord)) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// visited修改为boolean数组</span></span><br><span class="line">       <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[wordList.size()];</span><br><span class="line">       <span class="keyword">int</span> idx = wordList.indexOf(beginWord);</span><br><span class="line">       <span class="keyword">if</span> (idx != -<span class="number">1</span>) &#123;</span><br><span class="line">           visited[idx] = <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">       queue.offer(beginWord);</span><br><span class="line">       <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">           <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            count++;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;  size; i++) &#123;</span><br><span class="line">               String word = queue.poll();</span><br><span class="line">               <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; wordList.size(); j++) &#123;</span><br><span class="line">                   <span class="keyword">if</span>(visited[j]) &#123;</span><br><span class="line">                       <span class="keyword">continue</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                   String s = wordList.get(j);</span><br><span class="line">                   <span class="keyword">if</span>(!canConvert(word, s)) &#123;</span><br><span class="line">                       <span class="keyword">continue</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">if</span>(endWord.equals(s)) &#123;</span><br><span class="line">                       <span class="keyword">return</span> ++count;</span><br><span class="line">                   &#125;</span><br><span class="line">                   queue.offer(s);</span><br><span class="line">                   visited[j] = <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">          </span><br><span class="line">           </span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">canConvert</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 因为题目说了单词长度相同，可以不考虑长度问题</span></span><br><span class="line">       <span class="comment">// if (s1.length() != s2.length()) return false;</span></span><br><span class="line">       <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.length(); ++i) &#123;</span><br><span class="line">           <span class="keyword">if</span> (s1.charAt(i) != s2.charAt(i)) &#123;</span><br><span class="line">               ++count;</span><br><span class="line">               <span class="keyword">if</span> (count &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> count == <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;127-word-ladder&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#127-word-ladder&quot;&gt;&lt;/a&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/word-ladder/&quot; t
      
    
    </summary>
    
      <category term="leetcode" scheme="http://www.yukonga.cn/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://www.yukonga.cn/tags/leetcode/"/>
    
      <category term="算法" scheme="http://www.yukonga.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="java" scheme="http://www.yukonga.cn/tags/java/"/>
    
      <category term="bfs" scheme="http://www.yukonga.cn/tags/bfs/"/>
    
      <category term="图" scheme="http://www.yukonga.cn/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>Seata-Server Rpc模块源码分析</title>
    <link href="http://www.yukonga.cn/2020/04/13/Seata-Server-Rpc%E6%A8%A1%E5%9D%97%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://www.yukonga.cn/2020/04/13/Seata-Server-Rpc模块源码分析/</id>
    <published>2020-04-13T07:57:19.000Z</published>
    <updated>2020-04-13T07:59:35.274Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>上文已经介绍了<code>Seata Server</code>的启动流程 本文将继续上文的流程来分析一下<code>Seata Server Rpc</code>模块的实现。</p><p><code>Seata</code>的RPC实现是基于<code>Netty</code>。借助<code>Netty</code> <code>Seata</code>可以很容易实现高性能的RPC通讯</p><a id="more"></a><p><img src="http://images.yukonga.cn/20200331225034.png" alt="img"></p><p>Seata 目前允许配置的传输层配置如图所示，用户可根据需要进行Netty传输层面的调优，配置通过配置中心配置，首次加载时生效。具体参数配置参考官网。</p><h2 id="rpc模块介绍"><a class="markdownIt-Anchor" href="#rpc模块介绍"></a> Rpc模块介绍</h2><p>首先来看看顶层UML图</p><p><img src="http://images.yukonga.cn/20200331230136.png" alt="image-20200331230136720"></p><p>整个类图中的顶层类可以分成三类</p><ul><li>RemotingService 定义远程服务的开启与关闭<ul><li>RpcServerBootstrap 负责启动Netty Server启动 监听请求</li></ul></li><li>AbstractRpcRemoting 定义通用的请求发送响应(Server 与 Client复用逻辑)<ul><li>AbstractRpcRemotingServer 负责Server端的具体请求与发送 并且将请求委托给DefaultServerMessageListener来处理</li></ul></li><li>ServerMessageSender 定义Server端中的发送请求的api<ul><li>DefaultServerMessageListener 负责具体的请求的业务逻辑处理 比如<code>BeginGlobalTransaction Commit Rollback</code> (其实它内部的业务逻辑是委托给Core来做的 后文我们会继续分析Coordinator Core模块)等</li></ul></li></ul><p>通过这三个顶层类可以很好的隔离业务逻辑。每个类都只做自己职责的事情</p><ul><li>RemotingService负责Rpc服务的启动关闭</li><li>AbstractRpcRemoting 负责抽象的发送响应</li><li>ServerMessageSender Server端的rpc发送器(带业务逻辑)</li></ul><h3 id="处理流程"><a class="markdownIt-Anchor" href="#处理流程"></a> 处理流程</h3><p><code>RpcServer#init()</code>方法启动</p><pre><code>1、配置对应的RpcServerHandler以及核心业务处理的监听器`DefaultServerMessageListener` 2、配置BootStrapServer 开始监听Client的请求   3、ServerMessageSender 用于处理Client不同类型请求 如果是TM TC Register 则保存对应的Channel映射  如果是全局事务的请求 则委托给`DefaultServerMessageListener`处理</code></pre><p>首先我们看看<code>AbstractRpcRemoting</code>的源码<br><img src="http://images.yukonga.cn/20200402102056.png" alt="image-20200402102056140"></p><p>根据它定义的字段我们大概可以推测它实现的功能</p><ul><li>发送请求 &amp;&amp; 支持异步发送 &amp;&amp; 支持异步获取请求结果</li><li>响应请求</li><li>支持BatchSend 消息合并发送</li></ul><p>话不多说直接看源码, 关键地方我会加上注释</p><p><img src="http://images.yukonga.cn/20200402102433.png" alt="image-20200402102433880"></p><p>主要定义了一下公共的发送方法。它还有一个重要的内部类<code>AbstracHandler</code> 它是一个ChannelHandler用于处理Netty的请求</p><p><img src="http://images.yukonga.cn/20200402102515.png" alt="image-20200402102515100"></p><p>对于<code>AbstractHandler</code>而言 <code>channelRead</code>方法的代码幅度看来很长的</p><p>简单的理解一下就是</p><ol><li>判断是不是 请求或者不需要Response的请求<ol><li>如果是新请求 则交给消息请求处理线程池分发处理</li><li>如果不是请求那就是Response 则判断这个Response的原请求是否还在<ol><li>如果还在则给原请求设置响应结果</li><li>如果不在 则交给消息请求处理线程池分发处理</li></ol></li></ol></li></ol><p>另外对于<code>channelRead</code> 方法而言 我觉得if判断逻辑有点显得冗余 重复代码比较多 可以优化一下！ 读者有兴趣可以试试</p><p><code>ServerHandler</code> 逻辑比较简单</p><p>在read方法 判断是不是TM 注册请求或者是心跳请求, 如果是则调用<code>DefaultServerMessageListener</code>处理，如果不是 则是RM请求 一个分布式事务中 一般只有一个TM多个RM 所以RM请求放入线程池中 异步处理。</p><p><img src="http://images.yukonga.cn/20200402102642.png" alt="image-20200402102642035"></p><p>经过上面的分析 我们已经大概清楚了流程</p><ul><li>RpcServerBootstrap启动server监听请求</li><li>server收到请求到给ServerHandler处理</li><li>ServerHandler根据请求类型采用不同的策略处理<ul><li>TM 心跳请求直接给<code>DefaultServerMessageListener</code>处理</li><li>RM请求放入任务线程池然后给<code>DefaultServerMessageListener</code>处理</li></ul></li></ul><p>以上都是流程公式化的代码 没有什么业务逻辑</p><p>接下来我们来看看<code>DefaultServerMessageListener</code>源码 看看它是如何实现TC中的业务逻辑处理</p><p>首先看看它的顶层接口<code>ServerMessageListener</code></p><p><img src="http://images.yukonga.cn/20200402102713.png" alt="image-20200402102713180"></p><p>我们再看看实现类 <code>DefaultServerMessageListenerImpl</code></p><p><img src="http://images.yukonga.cn/20200402102735.png" alt="image-20200402102735655"></p><p><img src="http://images.yukonga.cn/20200402102905.png" alt="image-20200402102905807"></p><p>上文中 TM注册 RM注册 心跳这个类型的业务逻辑处理很简单的，重要的事务请求的一个逻辑处理，但是它的具体逻辑是委托给Coordinator来做的,不属于RPC模块的内容，但是我们后文会继续分析。</p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>通过本文可以了解到Rpc Server端对于Client的请求处理流程是怎么样。知道了核心的全局事务处理逻辑是委托给<code>Coordinator</code>处理的。所以接下来我们会继续分析 <code>Coordinator</code> 模块是如何注册一个全局事务 分支事务的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h2&gt;
&lt;p&gt;上文已经介绍了&lt;code&gt;Seata Server&lt;/code&gt;的启动流程 本文将继续上文的流程来分析一下&lt;code&gt;Seata Server Rpc&lt;/code&gt;模块的实现。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Seata&lt;/code&gt;的RPC实现是基于&lt;code&gt;Netty&lt;/code&gt;。借助&lt;code&gt;Netty&lt;/code&gt; &lt;code&gt;Seata&lt;/code&gt;可以很容易实现高性能的RPC通讯&lt;/p&gt;
    
    </summary>
    
      <category term="seata" scheme="http://www.yukonga.cn/categories/seata/"/>
    
    
      <category term="java" scheme="http://www.yukonga.cn/tags/java/"/>
    
      <category term="分布式事务" scheme="http://www.yukonga.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
      <category term="seata" scheme="http://www.yukonga.cn/tags/seata/"/>
    
  </entry>
  
  <entry>
    <title>128. Longest Consecutive Sequence(hard)</title>
    <link href="http://www.yukonga.cn/2020/04/06/128-Longest-Consecutive-Sequence-hard/"/>
    <id>http://www.yukonga.cn/2020/04/06/128-Longest-Consecutive-Sequence-hard/</id>
    <published>2020-04-06T08:28:40.000Z</published>
    <updated>2020-04-06T08:29:47.019Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h2 id="128-longest-consecutive-sequencehard"><a class="markdownIt-Anchor" href="#128-longest-consecutive-sequencehard"></a> <a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/" target="_blank" rel="noopener">128. Longest Consecutive Sequence(hard)</a></h2><blockquote><p>原题链接 <a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/" target="_blank" rel="noopener">128. Longest Consecutive Sequence</a></p></blockquote><a id="more"></a><h2 id="题意"><a class="markdownIt-Anchor" href="#题意"></a> 题意</h2><p><img src="http://images.yukonga.cn/20200406162912.png" alt="image-20200406161614905"></p><h2 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h2><p>审题可得题意是想求得数组中最长的连续序列的长度,但是数组并不是有序数组。如果是有序数组这题完全可以用动态规划来解。</p><h3 id="排序动态规划"><a class="markdownIt-Anchor" href="#排序动态规划"></a> 排序+动态规划</h3><p>1、我们可以使用排序+动态规划 来解 时间复杂度是O(nlogn) 不符合题目要求</p><p>代码就不贴了 这只是思路的一种</p><h3 id="归并集"><a class="markdownIt-Anchor" href="#归并集"></a> 归并集</h3><p>2、我们可以使用 归并集来解</p><ul><li>uf代表当前i的起始值 初始化为i</li><li>cnt代表当前i为起始值的连续序列的长度 默认为1</li></ul><p>遍历原数组 判断uf[i] 与 uf[i+1]的起始值是不是同一个</p><ul><li>如果是同一个则代表当前两个位置已经连接 只需要返回cnt[i]就可以</li><li>如果不是同一个则需要连接起来 同时需要把两个序列的长度相加</li></ul><h3 id="ac代码"><a class="markdownIt-Anchor" href="#ac代码"></a> AC代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; um = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Map&lt;Integer, Integer&gt; cnt = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 归并集解法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            um.put(num, num);</span><br><span class="line">            cnt.put(num, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != Integer.MAX_VALUE &amp;&amp; um.containsKey(i + <span class="number">1</span>)) &#123;</span><br><span class="line">                ans = Math.max(ans, merge(i, i + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == um.get(i)) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 压缩路径</span></span><br><span class="line">        <span class="keyword">int</span> res = find(um.get(um.get(i)));</span><br><span class="line">        um.put(i, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> px = find(x);</span><br><span class="line">        <span class="keyword">int</span> py = find(y);</span><br><span class="line">        <span class="keyword">if</span> (px == py) &#123;</span><br><span class="line">            <span class="keyword">return</span> cnt.get(px);</span><br><span class="line">        &#125;</span><br><span class="line">        um.put(y, px);</span><br><span class="line">        cnt.put(px, cnt.get(px) + cnt.get(py));</span><br><span class="line">        <span class="keyword">return</span> cnt.get(px);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="hashset"><a class="markdownIt-Anchor" href="#hashset"></a> HashSet</h3><p>这题还可以使用Set的特性来解决，这些数字用一个 HashSet 保存，实现 O(1) 时间的查询，同时，我们只对 当前数字 - 1 不在哈希表里的数字，作为连续序列的第一个数字去找对应的最长序列，这是因为其他数字一定已经出现在了某个序列里。</p><h3 id="ac代码-2"><a class="markdownIt-Anchor" href="#ac代码-2"></a> AC代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive1</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">       Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">           set.add(num);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i: set)&#123;</span><br><span class="line">           <span class="comment">// 假如一个数在哈希表中存在比他小的，那么它不是可以作为开头的数字</span></span><br><span class="line">           <span class="keyword">if</span>(i != Integer.MIN_VALUE &amp;&amp; set.contains(i-<span class="number">1</span>))&#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">while</span>(i!=Integer.MAX_VALUE &amp;&amp; set.contains(i+<span class="number">1</span>))&#123;</span><br><span class="line">               cnt ++;</span><br><span class="line">               i++;</span><br><span class="line">           &#125;</span><br><span class="line">           ans = Math.max(ans, cnt);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[toc]&lt;/p&gt;
&lt;h2 id=&quot;128-longest-consecutive-sequencehard&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#128-longest-consecutive-sequencehard&quot;&gt;&lt;/a&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/longest-consecutive-sequence/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;128. Longest Consecutive Sequence(hard)&lt;/a&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;原题链接 &lt;a href=&quot;https://leetcode-cn.com/problems/longest-consecutive-sequence/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;128. Longest Consecutive Sequence&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://www.yukonga.cn/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://www.yukonga.cn/tags/leetcode/"/>
    
      <category term="算法" scheme="http://www.yukonga.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="归并集" scheme="http://www.yukonga.cn/tags/%E5%BD%92%E5%B9%B6%E9%9B%86/"/>
    
      <category term="java" scheme="http://www.yukonga.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>395. Longest Substring with At Least K Repeating Characters</title>
    <link href="http://www.yukonga.cn/2020/04/04/395.%20Longest%20Substring%20with%20At%20Least%20K%20Repeating%20Characters/"/>
    <id>http://www.yukonga.cn/2020/04/04/395. Longest Substring with At Least K Repeating Characters/</id>
    <published>2020-04-04T15:59:59.000Z</published>
    <updated>2020-04-04T16:01:35.218Z</updated>
    
    <content type="html"><![CDATA[<h2 id="395-longest-substring-with-at-least-k-repeating-characters"><a class="markdownIt-Anchor" href="#395-longest-substring-with-at-least-k-repeating-characters"></a> <a href="https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/" target="_blank" rel="noopener">395. Longest Substring with At Least K Repeating Characters</a></h2><blockquote><p>原题链接 <a href="https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/" target="_blank" rel="noopener">395. Longest Substring with At Least K Repeating Characters</a></p></blockquote><h2 id="解析思路"><a class="markdownIt-Anchor" href="#解析思路"></a> 解析思路</h2><p>我们来思考一下什么样的情况可能可以构成连续的子串，每个字符都出现了至少k次；什么情况下又构不成？<br>很显然如果字符串里有字符在整个串里都没出现k次，那么含有这个字符的子串一定是不可能成立的。所以我们可以通过这些小于k次的字符作为分隔符 把长字符串分成一个个子串, 采用分支算法求字符串中符合条件的长度 返回其中最长的。</p><a id="more"></a><h3 id="ac代码"><a class="markdownIt-Anchor" href="#ac代码"></a> AC代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestSubstring</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> longestSubstring(s, <span class="number">0</span>, s.length() - <span class="number">1</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestSubstring</span><span class="params">(String s, <span class="keyword">int</span> begin, <span class="keyword">int</span> end, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (end - begin + <span class="number">1</span> &lt; k) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] chs = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="comment">// 计算出现次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i &lt;= end; i++) &#123;</span><br><span class="line">            chs[s.charAt(i) - <span class="string">'a'</span>] = chs[s.charAt(i) - <span class="string">'a'</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 跳过 次数小于k的</span></span><br><span class="line">        <span class="keyword">while</span> (begin &lt; end &amp;&amp; chs[s.charAt(begin) - <span class="string">'a'</span>] &lt; k) &#123;</span><br><span class="line">            begin++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (begin &lt; end &amp;&amp; chs[s.charAt(end) - <span class="string">'a'</span>] &lt; k) &#123;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (end - begin + <span class="number">1</span> &lt; k) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 分而治之</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i &lt;= end; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chs[s.charAt(i) - <span class="string">'a'</span>] &lt; k) &#123;</span><br><span class="line">                <span class="keyword">return</span> Math.max(longestSubstring(s, begin, i - <span class="number">1</span>, k), longestSubstring(s, i + <span class="number">1</span>, end, k));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> end - begin + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;395-longest-substring-with-at-least-k-repeating-characters&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#395-longest-substring-with-at-least-k-repeating-characters&quot;&gt;&lt;/a&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;395. Longest Substring with At Least K Repeating Characters&lt;/a&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;原题链接 &lt;a href=&quot;https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;395. Longest Substring with At Least K Repeating Characters&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;解析思路&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#解析思路&quot;&gt;&lt;/a&gt; 解析思路&lt;/h2&gt;
&lt;p&gt;我们来思考一下什么样的情况可能可以构成连续的子串，每个字符都出现了至少k次；什么情况下又构不成？&lt;br&gt;
很显然如果字符串里有字符在整个串里都没出现k次，那么含有这个字符的子串一定是不可能成立的。所以我们可以通过这些小于k次的字符作为分隔符 把长字符串分成一个个子串, 采用分支算法求字符串中符合条件的长度 返回其中最长的。&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://www.yukonga.cn/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://www.yukonga.cn/tags/leetcode/"/>
    
      <category term="java" scheme="http://www.yukonga.cn/tags/java/"/>
    
      <category term="分治算法" scheme="http://www.yukonga.cn/tags/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Seata-Server 启动流程源码分析</title>
    <link href="http://www.yukonga.cn/2020/04/02/Seata-Server-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://www.yukonga.cn/2020/04/02/Seata-Server-启动流程源码分析/</id>
    <published>2020-04-02T05:19:03.000Z</published>
    <updated>2020-04-02T05:50:09.404Z</updated>
    
    <content type="html"><![CDATA[<h2 id="认识seata"><a class="markdownIt-Anchor" href="#认识seata"></a> 认识Seata</h2><p>Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案。</p><a id="more"></a><h3 id="seata的txc模型"><a class="markdownIt-Anchor" href="#seata的txc模型"></a> Seata的TXC模型</h3><p><img src="http://images.yukonga.cn/20200402132010.png" alt="img"></p><p>根据上图可知整个TXC模型有三个重要的组件</p><ul><li>TC 事务协调器,维护全局和分支事务的状态，驱动全局事务提交或回滚。(单独部署)</li><li>TM  事务管理器 定义全局事务的范围：开始全局事务、提交或回滚全局事务。</li><li>RM 资源管理器 管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</li></ul><p>简单理解就是TM事务管理器通过RPC与TC通讯请求开启一个全局事务</p><p>简单理解过程就是: Business作为服务起始方(此时它是TM)发起全局事务并注册到TC。在调用协同服务时，协同服务的事务分支事务会先完成阶段一的事务提交或回滚，并生成事务回滚的undo_log日志，同时注册当前服务到TC并上报其事务状态，归并到同一个业务的全局事务中。此时若没有问题继续下一个服务的调用，期间任何服务的分支事务回滚，都会通知到TC，TC在通知全局事务包含的所有已完成一阶段提交的分支事务回滚。如果所有分支事务都正常，最后回到全局事务发起方时，也会通知到TC，TC在通知全局事务包含的所有分支删除回滚日志。在这个过程中为了解决写隔离和度隔离的问题会涉及到TC管理的全局锁。</p><p>那么全局事务是如何在服务中传递的呢？实际在TM向TC请求开启一个全局事务的时候，TC会响应一个全局事务XID，只需要TM在调用其他协同服务时把XID传递给协同服务，这样就可以实现全局事务在分布式服务中传播，以及分支事务属于哪个全局事务。</p><p>Seata目前已经支持许多框架中的XID的自动传递了</p><ul><li><p>dubbo</p></li><li><p>spring cloud</p></li><li><p>sofa-rpc</p></li></ul><p>用户在使用Seata的时候对于XID的传递完全是无感知。</p><p>上文提到Seata中三个重要的组件<code>TC TM RM</code>.</p><p>其中TC作为事务协调者, 它负责驱动全局事务的提交与回滚。根据它的职责可知。它的重要性不言而喻。</p><p>那么作为一个优秀的协调者它需要具备哪些功能呢？</p><ul><li>高可用</li><li>高性能</li><li>支持扩展</li></ul><p>那么我们根据我们的猜测来看看TC的实现模块Server是怎么来实现这写功能的。</p><h2 id="server模块介绍"><a class="markdownIt-Anchor" href="#server模块介绍"></a> Server模块介绍</h2><p><img src="http://images.yukonga.cn/20200402132019.png" alt="image-20200331221613306"></p><p>整个Server模块可以分成7个主要模块</p><ul><li>RPC模块 负责与TM RM交互</li><li>Coordinator Core模块 TC实现事务协调的核心模块</li><li>Lock模块 资源全局锁的实现</li><li>Config模块 支持配置TC的配置模块</li><li>Store模块 TC运行时全局事务以及分支事务的相关信息需要通过Store模块持久化</li><li>Discover模块 Seata TC服务注册发现模块</li><li>HA-Cluste模块 TC Server实现高可用的模块</li></ul><p>就一个Server端而言, 它就有7个模块。那么我们改从何看起呢。</p><p>我们可以用Server启动的main函数来理解清楚整个TC的运行流程</p><h2 id="server启动流程"><a class="markdownIt-Anchor" href="#server启动流程"></a> Server启动流程</h2><p>本文所有源码基于<code>Seata1.1.0</code> 个人能力有限,如有不对欢迎指出。</p><p>整个Server端是一个<code>java</code>应用,它是通过<code>java -jar</code>启动的,所以主入口是一个main函数。</p><p>入口地址是<code>io.seata.server.Server#main()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1、 参数解析</span></span><br><span class="line">        ParameterParser parameterParser = <span class="keyword">new</span> ParameterParser(args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、 监控初始化</span></span><br><span class="line">        MetricsManager.get().init();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、将存储模式放到系统环境变量÷</span></span><br><span class="line">        System.setProperty(ConfigurationKeys.STORE_MODE, parameterParser.getStoreMode());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、创建与RM TM通讯的rpc服务器</span></span><br><span class="line">        RpcServer rpcServer = <span class="keyword">new</span> RpcServer(WORKING_THREADS);</span><br><span class="line">        <span class="comment">//server port</span></span><br><span class="line">        rpcServer.setListenPort(parameterParser.getPort());</span><br><span class="line">        UUIDGenerator.init(parameterParser.getServerNode());</span><br><span class="line">        <span class="comment">//log store mode : file, db</span></span><br><span class="line">        <span class="comment">// 5、设置资源存储模式</span></span><br><span class="line">        SessionHolder.init(parameterParser.getStoreMode());</span><br><span class="line">        <span class="comment">// 6、核心事务协调器创建</span></span><br><span class="line">        DefaultCoordinator coordinator = <span class="keyword">new</span> DefaultCoordinator(rpcServer);</span><br><span class="line">        coordinator.init();</span><br><span class="line">        <span class="comment">// 7、把协调器作为一个回调 传给netty rpc模块</span></span><br><span class="line">        rpcServer.setHandler(coordinator);</span><br><span class="line">        <span class="comment">// 8、注册JVM关闭构造函数 </span></span><br><span class="line">        ShutdownHook.getInstance().addDisposable(coordinator);</span><br><span class="line">        ShutdownHook.getInstance().addDisposable(rpcServer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//127.0.0.1 and 0.0.0.0 are not valid here.</span></span><br><span class="line">        <span class="keyword">if</span> (NetUtil.isValidIp(parameterParser.getHost(), <span class="keyword">false</span>)) &#123;</span><br><span class="line">            XID.setIpAddress(parameterParser.getHost());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            XID.setIpAddress(NetUtil.getLocalIp());</span><br><span class="line">        &#125;</span><br><span class="line">        XID.setPort(rpcServer.getListenPort());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 9、启动RPC模块 监听TM RM的请求</span></span><br><span class="line">            rpcServer.init();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">"rpcServer init error:&#123;&#125;"</span>, e.getMessage(), e);</span><br><span class="line">            System.exit(-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>首先看看参数解析,其实参数解析很简单主要是通过<code>JCommander</code>解析main函数中的args数组,不过在需要注意的是,由于Seata Server已经支持容器部署, 所以在容器环境启动参数的创建跟正常启动的参数是不同的。容器部署的启动参数需要通过<code>System.getenv</code>获取</p><p><code>io.seata.server.ParameterParser#init()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 判断启动环境是否是容器</span></span><br><span class="line">            <span class="keyword">boolean</span> inContainer = <span class="keyword">this</span>.isRunningInContainer();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果是容器启动 则从系统环境变量读取参数配置</span></span><br><span class="line">            <span class="keyword">if</span> (inContainer) &#123;</span><br><span class="line">                <span class="keyword">if</span> (LOGGER.isInfoEnabled()) &#123;</span><br><span class="line">                    LOGGER.info(<span class="string">"The server is running in container."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">this</span>.seataEnv = StringUtils.trimToNull(System.getenv(ENV_SYSTEM_KEY));</span><br><span class="line">                <span class="keyword">this</span>.host = StringUtils.trimToNull(System.getenv(ENV_SEATA_IP_KEY));</span><br><span class="line">                <span class="keyword">this</span>.serverNode = NumberUtils.toInt(System.getenv(ENV_SERVER_NODE_KEY), SERVER_DEFAULT_NODE);</span><br><span class="line">                <span class="keyword">this</span>.port = NumberUtils.toInt(System.getenv(ENV_SEATA_PORT_KEY), SERVER_DEFAULT_PORT);</span><br><span class="line">                <span class="keyword">this</span>.storeMode = StringUtils.trimToNull(System.getenv(ENV_STORE_MODE_KEY));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 否则使用JCommander 解析启动参数</span></span><br><span class="line">                JCommander jCommander = JCommander.newBuilder().addObject(<span class="keyword">this</span>).build();</span><br><span class="line">                jCommander.parse(args);</span><br><span class="line">                <span class="keyword">if</span> (help) &#123;</span><br><span class="line">                    jCommander.setProgramName(PROGRAM_NAME);</span><br><span class="line">                    jCommander.usage();</span><br><span class="line">                    System.exit(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isNotBlank(seataEnv)) &#123;</span><br><span class="line">                System.setProperty(ENV_PROPERTY_KEY, seataEnv);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isBlank(storeMode)) &#123;</span><br><span class="line">                storeMode = ConfigurationFactory.getInstance().getConfig(ConfigurationKeys.STORE_MODE,</span><br><span class="line">                    SERVER_DEFAULT_STORE_MODE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParameterException e) &#123;</span><br><span class="line">            printError(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>拿到启动参数后我们就要根据启动参数依次 启动监控、设置存储模型，创建协调核心对象、启动Rpc服务器。</p><p>为什么Rpc服务器要在最后一个启动呢？ 下篇文章会解答。</p><p>由于监控对Seata的核心功能暂无影响所以本文已经后续文章暂不对监控进行分析。</p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>本文简单的介绍了一下<code>Seata Server</code>模块启动流程的一个分析，了解Seata的启动流程,但是都是比较简单没有深入，后续会陆续深入分析Rpc模块与核心协调模块。</p><p><img src="http://images.yukonga.cn/20200402134548.png" alt="扫码_搜索联合传播样式-标准色版"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;认识seata&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#认识seata&quot;&gt;&lt;/a&gt; 认识Seata&lt;/h2&gt;
&lt;p&gt;Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案。&lt;/p&gt;
    
    </summary>
    
      <category term="seata" scheme="http://www.yukonga.cn/categories/seata/"/>
    
    
      <category term="java" scheme="http://www.yukonga.cn/tags/java/"/>
    
      <category term="分布式事务" scheme="http://www.yukonga.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
      <category term="seata" scheme="http://www.yukonga.cn/tags/seata/"/>
    
  </entry>
  
  <entry>
    <title>230. Kth Smallest Element in a BST</title>
    <link href="http://www.yukonga.cn/2020/03/30/230-Kth-Smallest-Element-in-a-BST/"/>
    <id>http://www.yukonga.cn/2020/03/30/230-Kth-Smallest-Element-in-a-BST/</id>
    <published>2020-03-30T03:44:20.000Z</published>
    <updated>2020-04-02T05:29:25.309Z</updated>
    
    <content type="html"><![CDATA[<h2 id="230-kth-smallest-element-in-a-bst"><a class="markdownIt-Anchor" href="#230-kth-smallest-element-in-a-bst"></a> 230. Kth Smallest Element in a BST</h2><blockquote><p>原题地址 <a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/" target="_blank" rel="noopener">230. Kth Smallest Element in a BST</a></p></blockquote><h2 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h2><p>由于给的二叉搜索树，总所周知二叉搜索树的中序遍历是有序的。所以这题可以变相的理解的为有序数组的中的第k个数</p><p>二叉树的中路遍历有两种方法, 递归、非递归(借助 栈).</p><p>我们先看递归</p><a id="more"></a><h3 id="递归解法-1"><a class="markdownIt-Anchor" href="#递归解法-1"></a> 递归解法-1</h3><p>我们通过中序遍历,把遍历的值存在<code>List&lt;Integer&gt; res</code> 中, 然后返回<code>res.get(k -1)</code> 即,.很容易写出如下代码.</p><h4 id="ac代码"><a class="markdownIt-Anchor" href="#ac代码"></a> AC代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    inorder(root, res);</span><br><span class="line">    <span class="keyword">return</span> res.get(k - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ArrayList&lt;Integer&gt; <span class="title">inorder</span><span class="params">(TreeNode root, ArrayList&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    inorder(root.left, res);</span><br><span class="line">    res.add(root.val);</span><br><span class="line">    inorder(root.right, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显时间复杂是O(n),空间复杂度是O(n).</p><h3 id="递归解法-2"><a class="markdownIt-Anchor" href="#递归解法-2"></a> 递归解法-2</h3><p>其实我们没用必要记录每个节点的值, 我们只需要遍历到第k个节点, 并且记录它的值即可,虽然这样不能避免递归的次数,但是可以空间复杂度到O(1).</p><h4 id="ac代码-2"><a class="markdownIt-Anchor" href="#ac代码-2"></a> AC代码</h4><p>很容易写出如下代码.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    inorder(root, k);</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 减枝</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span> || count &gt;= k) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    inorder(root.left, k);</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">if</span> (k == count) &#123;</span><br><span class="line">        num = root.val;</span><br><span class="line">    &#125;</span><br><span class="line">    inorder(root.right, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂是O(n),空间复杂度是O(1).</p><h3 id="非递归解法栈"><a class="markdownIt-Anchor" href="#非递归解法栈"></a> 非递归解法(栈)</h3><p>总所周知通过栈我们能实现二叉树的中序遍历, 非递归的遍历的好处就是我们能提前结束,而不需等到整个二叉树遍历完.</p><p>同时在遍历的时候取第k个数的值即可.</p><h4 id="ac代码-3"><a class="markdownIt-Anchor" href="#ac代码-3"></a> AC代码</h4><p>代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(root);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        root = stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (--k == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        root = root.right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;230-kth-smallest-element-in-a-bst&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#230-kth-smallest-element-in-a-bst&quot;&gt;&lt;/a&gt; 230. Kth Smallest Element in a BST&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;原题地址 &lt;a href=&quot;https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;230. Kth Smallest Element in a BST&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;解题思路&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#解题思路&quot;&gt;&lt;/a&gt; 解题思路&lt;/h2&gt;
&lt;p&gt;由于给的二叉搜索树，总所周知二叉搜索树的中序遍历是有序的。所以这题可以变相的理解的为有序数组的中的第k个数&lt;/p&gt;
&lt;p&gt;二叉树的中路遍历有两种方法, 递归、非递归(借助 栈).&lt;/p&gt;
&lt;p&gt;我们先看递归&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://www.yukonga.cn/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://www.yukonga.cn/tags/leetcode/"/>
    
      <category term="算法" scheme="http://www.yukonga.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="java" scheme="http://www.yukonga.cn/tags/java/"/>
    
      <category term="BST" scheme="http://www.yukonga.cn/tags/BST/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-951. Flip Equivalent Binary Trees</title>
    <link href="http://www.yukonga.cn/2019/05/28/LeetCode-951-Flip-Equivalent-Binary-Trees/"/>
    <id>http://www.yukonga.cn/2019/05/28/LeetCode-951-Flip-Equivalent-Binary-Trees/</id>
    <published>2019-05-28T06:19:41.000Z</published>
    <updated>2019-05-28T06:29:32.503Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/flip-equivalent-binary-trees/" target="_blank" rel="noopener">原题链接</a></p><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>我们可以为二叉树 T 定义一个翻转操作，如下所示：选择任意节点，然后交换它的左子树和右子树。</p><p>只要经过一定次数的翻转操作后，能使 X 等于 Y，我们就称二叉树 X <em>翻转等价</em>于二叉树 Y。</p><p>编写一个判断两个二叉树是否是<em>翻转等价</em>的函数。这些树由根节点 <code>root1</code> 和 <code>root2</code> 给出。</p> <a id="more"></a><p><strong>示例：</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">7</span>,<span class="number">8</span>], root2 = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="literal">null</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">8</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：We flipped at nodes with values <span class="number">1</span>, <span class="number">3</span>, <span class="keyword">and</span> <span class="number">5.</span></span><br></pre></td></tr></table></figure><h2 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h2><p>从跟节点开始 递归判断 两种情况 不需要反转(或者说是反转两次)  或者是需要反转一次</p><p>对应的情况：</p><p>需要反转 那就是左子树等于左子树 ， 右子树等于右子树</p><p>不需要反转 那就是左子树等于右子树 ， 右子树等于左子树</p><h2 id="ac代码"><a class="markdownIt-Anchor" href="#ac代码"></a> AC代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">flipEquiv</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(root1==<span class="keyword">null</span>&amp;&amp;root2==<span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span>( (root1 == <span class="keyword">null</span> &amp;&amp; root2 != <span class="keyword">null</span>)</span><br><span class="line">               || (root1 != <span class="keyword">null</span> &amp;&amp; root2 == <span class="keyword">null</span>))&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(root1.val!=root2.val)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span>((flipEquiv(root1.left,root2.left) &amp;&amp; flipEquiv(root1.right,root2.right)) ||</span><br><span class="line">               (flipEquiv(root1.left,root2.right) &amp;&amp; flipEquiv(root1.right,root2.left)))&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/flip-equivalent-binary-trees/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原题链接&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#题目描述&quot;&gt;&lt;/a&gt; 题目描述&lt;/h2&gt;
&lt;p&gt;我们可以为二叉树 T 定义一个翻转操作，如下所示：选择任意节点，然后交换它的左子树和右子树。&lt;/p&gt;
&lt;p&gt;只要经过一定次数的翻转操作后，能使 X 等于 Y，我们就称二叉树 X &lt;em&gt;翻转等价&lt;/em&gt;于二叉树 Y。&lt;/p&gt;
&lt;p&gt;编写一个判断两个二叉树是否是&lt;em&gt;翻转等价&lt;/em&gt;的函数。这些树由根节点 &lt;code&gt;root1&lt;/code&gt; 和 &lt;code&gt;root2&lt;/code&gt; 给出。&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://www.yukonga.cn/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://www.yukonga.cn/tags/leetcode/"/>
    
      <category term="算法" scheme="http://www.yukonga.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="java" scheme="http://www.yukonga.cn/tags/java/"/>
    
      <category term="递归" scheme="http://www.yukonga.cn/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-338 Counting Bits</title>
    <link href="http://www.yukonga.cn/2019/05/27/LeetCode-338-Counting-Bits/"/>
    <id>http://www.yukonga.cn/2019/05/27/LeetCode-338-Counting-Bits/</id>
    <published>2019-05-27T07:27:15.000Z</published>
    <updated>2019-05-27T07:42:16.867Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/counting-bits/submissions/" target="_blank" rel="noopener">原题链接</a></p><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>给定一个非负整数 <strong>num</strong>。对于 <strong>0 ≤ i ≤ num</strong> 范围中的每个数字 <strong>i</strong> ，计算其二进制数中的 1 的数目并将它们作为数组返回。</p><p><strong>示例 1:</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">2</span></span><br><span class="line">输出: [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">5</span></span><br><span class="line">输出: [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p><strong>进阶:</strong></p><ul><li>给出时间复杂度为**O(n*sizeof(integer))<strong>的解答非常容易。但你可以在线性时间</strong>O(n)**内用一趟扫描做到吗？</li><li>要求算法的空间复杂度为<strong>O(n)</strong>。</li><li>你能进一步完善解法吗？要求在C<ins>或任何其他语言中不使用任何内置函数（如 C</ins> 中的 <strong>__builtin_popcount</strong>）来执行此操作。</li></ul><h2 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h2><p><code>i &amp; (i - 1)</code>去掉<code>i</code>最右边的一个1；因<code>i &amp; (i - 1）&lt; i</code>，故<code>result[i &amp; (i - 1)]</code>已计算，所以<code>i</code>中1的个数为<code>result[i &amp; (i - 1)] + 1</code></p><h2 id="ac代码"><a class="markdownIt-Anchor" href="#ac代码"></a> AC代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] countBits(<span class="keyword">int</span> num) &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[num + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num ; i++) &#123;</span><br><span class="line">        res[i] = res[i &amp; (i - <span class="number">1</span>)] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/counting-bits/submissions/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原题链接&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a class=
      
    
    </summary>
    
      <category term="leetcode" scheme="http://www.yukonga.cn/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://www.yukonga.cn/tags/leetcode/"/>
    
      <category term="算法" scheme="http://www.yukonga.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="java" scheme="http://www.yukonga.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>【SpringSecurity系列02】SpringSecurity UsernamePasswordAuthenticationFilter认证逻辑源码解读</title>
    <link href="http://www.yukonga.cn/2019/04/12/%E3%80%90SpringSecurity%E7%B3%BB%E5%88%9702%E3%80%91SpringSecurity%20UsernamePasswordAuthenticationFilter%E8%AE%A4%E8%AF%81%E9%80%BB%E8%BE%91%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    <id>http://www.yukonga.cn/2019/04/12/【SpringSecurity系列02】SpringSecurity UsernamePasswordAuthenticationFilter认证逻辑源码解读/</id>
    <published>2019-04-12T07:58:25.000Z</published>
    <updated>2019-07-27T06:07:47.719Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概要"><a class="markdownIt-Anchor" href="#概要"></a> 概要</h2><p>前面一节，通过简单配置即可实现SpringSecurity表单认证功能，而今天这一节将通过阅读源码的形式来学习SpringSecurity是如何实现这些功能, 前方高能预警，<strong><code>本篇分析源码篇幅较长</code></strong>。</p><a id="more"></a><h2 id="过滤器链"><a class="markdownIt-Anchor" href="#过滤器链"></a> 过滤器链</h2><p>前面我说过SpringSecurity是基于过滤器链的形式，那么我解析将会介绍一下具体有哪些过滤器。</p><table><thead><tr><th style="text-align:center">Filter Class</th><th style="text-align:center">介绍</th></tr></thead><tbody><tr><td style="text-align:center">SecurityContextPersistenceFilter</td><td style="text-align:center">判断当前用户是否登录</td></tr><tr><td style="text-align:center">CrsfFilter</td><td style="text-align:center">用于防止csrf攻击</td></tr><tr><td style="text-align:center">LogoutFilter</td><td style="text-align:center">处理注销请求</td></tr><tr><td style="text-align:center">UsernamePasswordAuthenticationFilter</td><td style="text-align:center">处理表单登录的请求(也是我们今天的主角)</td></tr><tr><td style="text-align:center">BasicAuthenticationFilter</td><td style="text-align:center">处理http basic认证的请求</td></tr></tbody></table><p>由于过滤器链中的过滤器实在太多，我没有一一列举，调了几个比较重要的介绍一下。</p><p>通过上面我们知道SpringSecurity对于表单登录的认证请求是交给了UsernamePasswordAuthenticationFilter处理的，那么具体的认证流程如下：</p><p><img src="https://i.loli.net/2019/05/24/5ce7b959b91be68275.png" alt="">从上图可知，<code>UsernamePasswordAuthenticationFilter</code>继承于抽象类<code>AbstractAuthenticationProcessingFilter</code>。</p><p>具体认证是：</p><ol><li>进入doFilter方法，判断是否要认证，如果需要认证则进入attemptAuthentication方法，如果不需要直接结束</li><li>attemptAuthentication方法中根据username跟password构造一个UsernamePasswordAuthenticationToken对象(此时的token是未认证的)，并且将它交给ProviderManger来完成认证。</li><li>ProviderManger中维护这一个AuthenticationProvider对象列表，通过遍历判断并且最后选择DaoAuthenticationProvider对象来完成最后的认证。</li><li>DaoAuthenticationProvider根据ProviderManger传来的token取出username，并且调用我们写的UserDetailsService的loadUserByUsername方法从数据库中读取用户信息，然后对比用户密码，如果认证通过，则返回用户信息也是就是UserDetails对象，在重新构造UsernamePasswordAuthenticationToken(此时的token是 已经认证通过了的)。</li></ol><p>接下来我们将通过源码来分析具体的整个认证流程。</p><h2 id="abstractauthenticationprocessingfilter"><a class="markdownIt-Anchor" href="#abstractauthenticationprocessingfilter"></a> AbstractAuthenticationProcessingFilter</h2><p>AbstractAuthenticationProcessingFilter 是一个抽象类。所有的认证认证请求的过滤器都会继承于它，它主要将一些公共的功能实现，而具体的验证逻辑交给子类实现，有点类似于父类设置好认证流程，子类负责具体的认证逻辑，这样跟设计模式的<strong>模板方法模式</strong>有点相似。</p><p>现在我们分析一下 它里面比较重要的方法</p><h3 id="1-dofilter"><a class="markdownIt-Anchor" href="#1-dofilter"></a> 1、doFilter</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest req, ServletResponse res, FilterChain chain)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"><span class="comment">// 省略不相干代码。。。</span></span><br><span class="line">    <span class="comment">// 1、判断当前请求是否要认证</span></span><br><span class="line"><span class="keyword">if</span> (!requiresAuthentication(request, response)) &#123;</span><br><span class="line">      <span class="comment">// 不需要直接走下一个过滤器</span></span><br><span class="line">chain.doFilter(request, response);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 2、开始请求认证，attemptAuthentication具体实现给子类，如果认证成功返回一个认证通过的Authenticaion对象</span></span><br><span class="line">authResult = attemptAuthentication(request, response);</span><br><span class="line"><span class="keyword">if</span> (authResult == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">      <span class="comment">// 3、登录成功 将认证成功的用户信息放入session SessionAuthenticationStrategy接口，用于扩展</span></span><br><span class="line">sessionStrategy.onAuthentication(authResult, request, response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (InternalAuthenticationServiceException failed) &#123;</span><br><span class="line">      <span class="comment">//2.1、发生异常，登录失败，进入登录失败handler回调</span></span><br><span class="line">unsuccessfulAuthentication(request, response, failed);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (AuthenticationException failed) &#123;</span><br><span class="line">      <span class="comment">//2.1、发生异常，登录失败，进入登录失败处理器</span></span><br><span class="line">unsuccessfulAuthentication(request, response, failed);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3.1、登录成功，进入登录成功处理器。</span></span><br><span class="line">successfulAuthentication(request, response, chain, authResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-successfulauthentication"><a class="markdownIt-Anchor" href="#2-successfulauthentication"></a> 2、successfulAuthentication</h3><p>登录成功处理器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">successfulAuthentication</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">HttpServletResponse response, FilterChain chain, Authentication authResult)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">    <span class="comment">//1、登录成功 将认证成功的Authentication对象存入SecurityContextHolder中</span></span><br><span class="line">    <span class="comment">//  SecurityContextHolder本质是一个ThreadLocal</span></span><br><span class="line">SecurityContextHolder.getContext().setAuthentication(authResult);</span><br><span class="line">    <span class="comment">//2、如果开启了记住我功能，将调用rememberMeServices的loginSuccess 将生成一个token</span></span><br><span class="line">  <span class="comment">//   将token放入cookie中这样 下次就不用登录就可以认证。具体关于记住我rememberMeServices的相关分析我们下面几篇文章会深入分析的。</span></span><br><span class="line">rememberMeServices.loginSuccess(request, response, authResult);</span><br><span class="line"><span class="comment">// Fire event</span></span><br><span class="line">    <span class="comment">//3、发布一个登录事件。</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.eventPublisher != <span class="keyword">null</span>) &#123;</span><br><span class="line">eventPublisher.publishEvent(<span class="keyword">new</span> InteractiveAuthenticationSuccessEvent(</span><br><span class="line">authResult, <span class="keyword">this</span>.getClass()));</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//4、调用我们自己定义的登录成功处理器，这样也是我们扩展得知登录成功的一个扩展点。</span></span><br><span class="line">successHandler.onAuthenticationSuccess(request, response, authResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-unsuccessfulauthentication"><a class="markdownIt-Anchor" href="#3-unsuccessfulauthentication"></a> 3、unsuccessfulAuthentication</h3><p>登录失败处理器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">unsuccessfulAuthentication</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">HttpServletResponse response, AuthenticationException failed)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">    <span class="comment">//1、登录失败，将SecurityContextHolder中的信息清空</span></span><br><span class="line">SecurityContextHolder.clearContext();</span><br><span class="line">    <span class="comment">//2、关于记住我功能的登录失败处理</span></span><br><span class="line">rememberMeServices.loginFail(request, response);</span><br><span class="line">    <span class="comment">//3、调用我们自己定义的登录失败处理器，这里可以扩展记录登录失败的日志。</span></span><br><span class="line">failureHandler.onAuthenticationFailure(request, response, failed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于AbstractAuthenticationProcessingFilter主要分析就到这。我们可以从源码中知道，当请求进入该过滤器中具体的流程是</p><ol><li>判断该请求是否要被认证</li><li>调用<code>attemptAuthentication</code>方法开始认证，由于是抽象方法具体认证逻辑给子类</li><li>如果登录成功，则将认证结果<code>Authentication</code>对象根据session策略写入session中，将认证结果写入到<code>SecurityContextHolder</code>,如果开启了记住我功能，则根据记住我功能，生成token并且写入cookie中，最后调用一个<code>successHandler</code>对象的方法，这个对象可以是我们配置注入的，用于处理我们的自定义登录成功的一些逻辑（比如记录登录成功日志等等）。</li><li>如果登录失败，则清空<code>SecurityContextHolder</code>中的信息，并且调用我们自己注入的<code>failureHandler</code>对象，处理我们自己的登录失败逻辑。</li></ol><h2 id="usernamepasswordauthenticationfilter"><a class="markdownIt-Anchor" href="#usernamepasswordauthenticationfilter"></a> UsernamePasswordAuthenticationFilter</h2><p>从上面分析我们可以知道，<code>UsernamePasswordAuthenticationFilter</code>是继承于<code>AbstractAuthenticationProcessingFilter</code>，并且实现它的<code>attemptAuthentication</code>方法，来实现认证具体的逻辑实现。接下来，我们通过阅读<code>UsernamePasswordAuthenticationFilter</code>的源码来解读，它是如何完成认证的。 由于这里会涉及<code>UsernamePasswordAuthenticationToken</code>对象构造，所以我们先看看<code>UsernamePasswordAuthenticationToken</code>的源码</p><h3 id="1-usernamepasswordauthenticationtoken"><a class="markdownIt-Anchor" href="#1-usernamepasswordauthenticationtoken"></a> 1、UsernamePasswordAuthenticationToken</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承至AbstractAuthenticationToken </span></span><br><span class="line"><span class="comment">// AbstractAuthenticationToken主要定义一下在SpringSecurity中toke需要存在一些必须信息</span></span><br><span class="line"><span class="comment">// 例如权限集合  Collection&lt;GrantedAuthority&gt; authorities; 是否认证通过boolean authenticated = false;认证通过的用户信息Object details;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsernamePasswordAuthenticationToken</span> <span class="keyword">extends</span> <span class="title">AbstractAuthenticationToken</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 未登录情况下 存的是用户名 登录成功情况下存的是UserDetails对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object principal;</span><br><span class="line">  <span class="comment">// 密码</span></span><br><span class="line"><span class="keyword">private</span> Object credentials;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 构造函数，用户没有登录的情况下，此时的authenticated是false，代表尚未认证</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UsernamePasswordAuthenticationToken</span><span class="params">(Object principal, Object credentials)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(<span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">this</span>.principal = principal;</span><br><span class="line"><span class="keyword">this</span>.credentials = credentials;</span><br><span class="line">setAuthenticated(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 构造函数，用户登录成功的情况下，多了一个参数 是用户的权限集合，此时的authenticated是true，代表认证成功</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UsernamePasswordAuthenticationToken</span><span class="params">(Object principal, Object credentials,</span></span></span><br><span class="line"><span class="function"><span class="params">Collection&lt;? extends GrantedAuthority&gt; authorities)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(authorities);</span><br><span class="line"><span class="keyword">this</span>.principal = principal;</span><br><span class="line"><span class="keyword">this</span>.credentials = credentials;</span><br><span class="line"><span class="keyword">super</span>.setAuthenticated(<span class="keyword">true</span>); <span class="comment">// must use super, as we override</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们就可以分析attemptAuthentication方法了。</p><h3 id="2-attemptauthentication"><a class="markdownIt-Anchor" href="#2-attemptauthentication"></a> 2、attemptAuthentication</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Authentication <span class="title">attemptAuthentication</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">HttpServletResponse response)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">     <span class="comment">// 1、判断是不是post请求，如果不是则抛出AuthenticationServiceException异常，注意这里抛出的异常都在AbstractAuthenticationProcessingFilter#doFilter方法中捕获，捕获之后会进入登录失败的逻辑。</span></span><br><span class="line"><span class="keyword">if</span> (postOnly &amp;&amp; !request.getMethod().equals(<span class="string">"POST"</span>)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> AuthenticationServiceException(</span><br><span class="line"><span class="string">"Authentication method not supported: "</span> + request.getMethod());</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 2、从request中拿用户名跟密码</span></span><br><span class="line">String username = obtainUsername(request);</span><br><span class="line">String password = obtainPassword(request);</span><br><span class="line"><span class="comment">// 3、非空处理，防止NPE异常</span></span><br><span class="line"><span class="keyword">if</span> (username == <span class="keyword">null</span>) &#123;</span><br><span class="line">username = <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (password == <span class="keyword">null</span>) &#123;</span><br><span class="line">password = <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 4、除去空格</span></span><br><span class="line">username = username.trim();</span><br><span class="line">    <span class="comment">// 5、根据username跟password构造出一个UsernamePasswordAuthenticationToken对象 从上文分析可知道，此时的token是未认证的。</span></span><br><span class="line">UsernamePasswordAuthenticationToken authRequest = <span class="keyword">new</span> UsernamePasswordAuthenticationToken(</span><br><span class="line">username, password);</span><br><span class="line">    <span class="comment">// 6、配置一下其他信息 ip 等等</span></span><br><span class="line">setDetails(request, authRequest);</span><br><span class="line">   <span class="comment">//  7、调用ProviderManger的authenticate的方法进行具体认证逻辑</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.getAuthenticationManager().authenticate(authRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="providermanager"><a class="markdownIt-Anchor" href="#providermanager"></a> ProviderManager</h2><p>维护一个AuthenticationProvider列表，进行认证逻辑验证</p><h3 id="1-authenticate"><a class="markdownIt-Anchor" href="#1-authenticate"></a> 1、authenticate</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Authentication <span class="title">authenticate</span><span class="params">(Authentication authentication)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">    <span class="comment">// 1、拿到token的类型。</span></span><br><span class="line">Class&lt;? extends Authentication&gt; toTest = authentication.getClass();</span><br><span class="line">AuthenticationException lastException = <span class="keyword">null</span>;</span><br><span class="line">Authentication result = <span class="keyword">null</span>;</span><br><span class="line">   <span class="comment">// 2、遍历AuthenticationProvider列表</span></span><br><span class="line"><span class="keyword">for</span> (AuthenticationProvider provider : getProviders()) &#123;</span><br><span class="line">      <span class="comment">// 3、AuthenticationProvider不支持当前token类型，则直接跳过</span></span><br><span class="line"><span class="keyword">if</span> (!provider.supports(toTest)) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 4、如果Provider支持当前token，则交给Provider完成认证。</span></span><br><span class="line">result = provider.authenticate(authentication);</span><br><span class="line">     </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (AccountStatusException e) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (InternalAuthenticationServiceException e) &#123;</span><br><span class="line"><span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (AuthenticationException e) &#123;</span><br><span class="line">lastException = e;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 5、登录成功 返回登录成功的token</span></span><br><span class="line"><span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">eventPublisher.publishAuthenticationSuccess(result);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="abstractuserdetailsauthenticationprovider"><a class="markdownIt-Anchor" href="#abstractuserdetailsauthenticationprovider"></a> AbstractUserDetailsAuthenticationProvider</h2><h3 id="1-authenticate-2"><a class="markdownIt-Anchor" href="#1-authenticate-2"></a> 1、authenticate</h3><p><code>AbstractUserDetailsAuthenticationProvider</code>实现了<code>AuthenticationProvider</code>接口，并且实现了部分方法，<code>DaoAuthenticationProvider</code>继承于<code>AbstractUserDetailsAuthenticationProvider</code>类，所以我们先来看看<code>AbstractUserDetailsAuthenticationProvider</code>的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractUserDetailsAuthenticationProvider</span> <span class="keyword">implements</span></span></span><br><span class="line"><span class="class"><span class="title">AuthenticationProvider</span>, <span class="title">InitializingBean</span>, <span class="title">MessageSourceAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 国际化处理</span></span><br><span class="line"><span class="keyword">protected</span> MessageSourceAccessor messages = SpringSecurityMessageSource.getAccessor();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对token一些检查，具体检查逻辑交给子类实现，抽象方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">additionalAuthenticationChecks</span><span class="params">(UserDetails userDetails,</span></span></span><br><span class="line"><span class="function"><span class="params">UsernamePasswordAuthenticationToken authentication)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> AuthenticationException</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 认证逻辑的实现，调用抽象方法retrieveUser根据username获取UserDetails对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Authentication <span class="title">authenticate</span><span class="params">(Authentication authentication)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1、获取usernmae</span></span><br><span class="line">String username = (authentication.getPrincipal() == <span class="keyword">null</span>) ? <span class="string">"NONE_PROVIDED"</span></span><br><span class="line">: authentication.getName();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、尝试去缓存中获取UserDetails对象</span></span><br><span class="line">UserDetails user = <span class="keyword">this</span>.userCache.getUserFromCache(username);</span><br><span class="line">    <span class="comment">// 3、如果为空，则代表当前对象没有缓存。</span></span><br><span class="line"><span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</span><br><span class="line">cacheWasUsed = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//4、调用retrieveUser去获取UserDetail对象，为什么这个方法是抽象方法大家很容易知道，如果UserDetail信息存在关系数据库 则可以重写该方法并且去关系数据库获取用户信息，如果UserDetail信息存在其他地方，可以重写该方法用其他的方法去获取用户信息，这样丝毫不影响整个认证流程，方便扩展。</span></span><br><span class="line">user = retrieveUser(username,</span><br><span class="line">(UsernamePasswordAuthenticationToken) authentication);</span><br><span class="line">&#125;</span><br><span class="line">      <span class="keyword">catch</span> (UsernameNotFoundException notFound) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 捕获异常 日志处理 并且往上抛出，登录失败。</span></span><br><span class="line"><span class="keyword">if</span> (hideUserNotFoundExceptions) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BadCredentialsException(messages.getMessage(</span><br><span class="line"><span class="string">"AbstractUserDetailsAuthenticationProvider.badCredentials"</span>,</span><br><span class="line"><span class="string">"Bad credentials"</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> notFound;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 5、前置检查  判断当前用户是否锁定，禁用等等</span></span><br><span class="line">preAuthenticationChecks.check(user);</span><br><span class="line">      <span class="comment">// 6、其他的检查，在DaoAuthenticationProvider是检查密码是否一致</span></span><br><span class="line">additionalAuthenticationChecks(user,</span><br><span class="line">(UsernamePasswordAuthenticationToken) authentication);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (AuthenticationException exception) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7、后置检查，判断密码是否过期</span></span><br><span class="line">postAuthenticationChecks.check(user);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 8、登录成功通过UserDetail对象重新构造一个认证通过的Token对象</span></span><br><span class="line"><span class="keyword">return</span> createSuccessAuthentication(principalToReturn, authentication, user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Authentication <span class="title">createSuccessAuthentication</span><span class="params">(Object principal,</span></span></span><br><span class="line"><span class="function"><span class="params">Authentication authentication, UserDetails user)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 调用第二个构造方法，构造一个认证通过的Token对象</span></span><br><span class="line">UsernamePasswordAuthenticationToken result = <span class="keyword">new</span> UsernamePasswordAuthenticationToken(</span><br><span class="line">principal, authentication.getCredentials(),</span><br><span class="line">authoritiesMapper.mapAuthorities(user.getAuthorities()));</span><br><span class="line">result.setDetails(authentication.getDetails());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们具体看看<code>retrieveUser</code>的实现，没看源码大家应该也可以知道，<code>retrieveUser</code>方法应该是调用<code>UserDetailsService</code>去数据库查询是否有该用户，以及用户的密码是否一致。</p><h2 id="daoauthenticationprovider"><a class="markdownIt-Anchor" href="#daoauthenticationprovider"></a> DaoAuthenticationProvider</h2><p>DaoAuthenticationProvider 主要是通过UserDetailService来获取UserDetail对象。</p><h3 id="1-retrieveuser"><a class="markdownIt-Anchor" href="#1-retrieveuser"></a> 1、retrieveUser</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> UserDetails <span class="title">retrieveUser</span><span class="params">(String username,</span></span></span><br><span class="line"><span class="function"><span class="params">UsernamePasswordAuthenticationToken authentication)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 1、调用UserDetailsService接口的loadUserByUsername方法获取UserDeail对象</span></span><br><span class="line">UserDetails loadedUser = <span class="keyword">this</span>.getUserDetailsService().loadUserByUsername(username);</span><br><span class="line">       <span class="comment">// 2、如果loadedUser为null 代表当前用户不存在，抛出异常 登录失败。</span></span><br><span class="line"><span class="keyword">if</span> (loadedUser == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> InternalAuthenticationServiceException(</span><br><span class="line"><span class="string">"UserDetailsService returned null, which is an interface contract violation"</span>);</span><br><span class="line">&#125;</span><br><span class="line">      <span class="comment">// 3、返回查询的结果</span></span><br><span class="line"><span class="keyword">return</span> loadedUser;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-additionalauthenticationchecks"><a class="markdownIt-Anchor" href="#2-additionalauthenticationchecks"></a> 2、additionalAuthenticationChecks</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">additionalAuthenticationChecks</span><span class="params">(UserDetails userDetails,</span></span></span><br><span class="line"><span class="function"><span class="params">UsernamePasswordAuthenticationToken authentication)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">    <span class="comment">// 1、如果密码为空，则抛出异常、</span></span><br><span class="line"><span class="keyword">if</span> (authentication.getCredentials() == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BadCredentialsException(messages.getMessage(</span><br><span class="line"><span class="string">"AbstractUserDetailsAuthenticationProvider.badCredentials"</span>,</span><br><span class="line"><span class="string">"Bad credentials"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、获取用户输入的密码</span></span><br><span class="line">String presentedPassword = authentication.getCredentials().toString();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、调用passwordEncoder的matche方法 判断密码是否一致</span></span><br><span class="line"><span class="keyword">if</span> (!passwordEncoder.matches(presentedPassword, userDetails.getPassword())) &#123;</span><br><span class="line">logger.debug(<span class="string">"Authentication failed: password does not match stored value"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 4、如果不一致 则抛出异常。</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BadCredentialsException(messages.getMessage(</span><br><span class="line"><span class="string">"AbstractUserDetailsAuthenticationProvider.badCredentials"</span>,</span><br><span class="line"><span class="string">"Bad credentials"</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>至此，整认证流程已经分析完毕，大家如果有什么不懂可以关注我的公众号一起讨论。</p><p>学习是一个漫长的过程，学习源码可能会很困难但是只要努力一定就会有获取，大家一致共勉。</p><p><img src="https://i.loli.net/2019/05/24/5ce7b959b91be68275.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概要&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#概要&quot;&gt;&lt;/a&gt; 概要&lt;/h2&gt;
&lt;p&gt;前面一节，通过简单配置即可实现SpringSecurity表单认证功能，而今天这一节将通过阅读源码的形式来学习SpringSecurity是如何实现这些功能, 前方高能预警，&lt;strong&gt;&lt;code&gt;本篇分析源码篇幅较长&lt;/code&gt;&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="SpringSecurity" scheme="http://www.yukonga.cn/categories/SpringSecurity/"/>
    
    
      <category term="SpringBoot" scheme="http://www.yukonga.cn/tags/SpringBoot/"/>
    
      <category term="SpringSecurity" scheme="http://www.yukonga.cn/tags/SpringSecurity/"/>
    
  </entry>
  
  <entry>
    <title>【SpringSecurity系列01】初识SpringSecurity</title>
    <link href="http://www.yukonga.cn/2019/04/11/%E3%80%90SpringSecurity%E7%B3%BB%E5%88%9701%E3%80%91%E5%88%9D%E8%AF%86SpringSecurity/"/>
    <id>http://www.yukonga.cn/2019/04/11/【SpringSecurity系列01】初识SpringSecurity/</id>
    <published>2019-04-11T08:20:09.000Z</published>
    <updated>2019-05-24T09:27:17.373Z</updated>
    
    <content type="html"><![CDATA[<p>​    什么是<code>SpringSecurity</code> ？</p><a id="more"></a><blockquote><p>​      Spring Security是一个能够为基于Spring的企业应用系统提供声明式的安全访问控制解决方案的安全框架。它提供了一组可以在Spring应用上下文中配置的Bean，充分利用了Spring IoC，DI（控制反转Inversion of Control ,DI:Dependency Injection 依赖注入）和AOP（面向切面编程）功能，为应用系统提供声明式的安全访问控制功能，减少了为企业系统安全控制编写大量重复代码的工作。</p></blockquote><p>以上来介绍来自<code>wiki</code>，比较官方。</p><p>​        用自己的话 简单介绍一下，<code>Spring Security</code>基于 Servlet 过滤器链的形式，为我们的web项目提供<code>认证</code>与<code>授权</code>服务。它来自于<code>Spring</code>，那么它与<code>SpringBoot</code>整合开发有着天然的优势，目前与<code>SpringSecurity</code>对应的开源框架还有<code>shiro</code>。接下来我将通过一个简单的例子带大家来认识<code>SpringSecurity</code>,然后通过分析它的源码带大家来认识一下<code>SpringSecurity</code>是如何工作，从一个简单例子入门，大家由浅入深的了解学习<code>SpringSecurity</code>。</p><p>通常大家在做一个后台管理的系统的时候，应该采用<code>session</code>判断用户是否登录。我记得我在没有接触学习SpringSecurity与shiro之前。对于用户登录功能实现通常是如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(User user, HttpSession session)</span></span>&#123;</span><br><span class="line">  <span class="comment">//1、根据用户名或者id从数据库读取数据库中用户</span></span><br><span class="line">  <span class="comment">//2、判断密码是否一致</span></span><br><span class="line">  <span class="comment">//3、如果密码一致</span></span><br><span class="line">  session.setAttribute(<span class="string">"user"</span>,user);</span><br><span class="line">  <span class="comment">//4、否则返回登录页面</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">对于之后那些需要登录之后才能访问的url，通过SpringMvc的拦截器中的#preHandle来判断session中是否有user对象</span><br><span class="line">如果没有 则返回登录页面</span><br><span class="line">如果有， 则允许访问这个页面。</span><br></pre></td></tr></table></figure><p>但是在<code>SpringSecurity</code>中，这一些逻辑已经被封装起来，我们只需要简单的配置一下就能使用。</p><p>接下来我通过一个简单例子大家认识一下<code>SpringSecurity</code></p><p>本文基于<code>SpringBoot</code>，如果大家对SpringBoot不熟悉的话可以看看我之前写的<a href="https://www.jianshu.com/p/5d0295fb375a" target="_blank" rel="noopener">SpringBoot入门系列</a></p><p>我使用的是：</p><ul><li>SpringBoot 2.1.4.RELEASE</li><li>SpringSecurity 5</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.yukong<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springboot-springsecurity<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>springboot-springsecurity<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>springboot-springsecurity study<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.security<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-security-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置一下数据库 以及<code>MyBatis</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  datasource:</span></span><br><span class="line"><span class="attr">    driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">    url:</span> <span class="attr">jdbc:mysql://127.0.0.1:3306/db_test?useUnicode=true&amp;characterEncoding=utf8</span></span><br><span class="line"><span class="attr">    password:</span> <span class="string">abc123</span></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line"><span class="attr">  mapper-locations:</span> <span class="attr">classpath:mapper/*.xml</span></span><br></pre></td></tr></table></figure><p>这里我用的<code>MySQL8.0</code> 大家注意一下 <code>MySQL8.0</code>的数据库驱动的类的包改名了</p><p>在前面我有讲过SpringBoot中如何整合Mybatis，在这里我就不累述，有需要的话看<a href="https://www.jianshu.com/p/c44dc639cb93" target="_blank" rel="noopener">这篇文章</a></p><p><code>user.sql</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`user`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'主键'</span>,</span><br><span class="line">  <span class="string">`username`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户名'</span>,</span><br><span class="line">  <span class="string">`svc_num`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户号码'</span>,</span><br><span class="line">  <span class="string">`password`</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'密码'</span>,</span><br><span class="line">  <span class="string">`cust_id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'客户id  1对1'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">2</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4 <span class="keyword">COLLATE</span>=utf8mb4_0900_ai_ci;</span><br></pre></td></tr></table></figure><p>对应的<code>UserMapper.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukong.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yukong.entity.User;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yukong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-04-11 16:50</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insertSelective</span><span class="params">(User record)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">User <span class="title">selectByUsername</span><span class="params">(String  username)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>UserMapper.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.yukong.mapper.UserMapper"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"BaseResultMap"</span> <span class="attr">type</span>=<span class="string">"com.yukong.entity.User"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">jdbcType</span>=<span class="string">"BIGINT"</span> <span class="attr">property</span>=<span class="string">"id"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"username"</span> <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span> <span class="attr">property</span>=<span class="string">"username"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"svc_num"</span> <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span> <span class="attr">property</span>=<span class="string">"svcNum"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"password"</span> <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span> <span class="attr">property</span>=<span class="string">"password"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"cust_id"</span> <span class="attr">jdbcType</span>=<span class="string">"BIGINT"</span> <span class="attr">property</span>=<span class="string">"custId"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">"Base_Column_List"</span>&gt;</span></span><br><span class="line">    id, username, svc_num, `password`, cust_id</span><br><span class="line">  <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectByUsername"</span> <span class="attr">parameterType</span>=<span class="string">"java.lang.String"</span> <span class="attr">resultMap</span>=<span class="string">"BaseResultMap"</span>&gt;</span></span><br><span class="line">    select</span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"Base_Column_List"</span> /&gt;</span></span><br><span class="line">    from user</span><br><span class="line">    where username = #&#123;username,jdbcType=VARCHAR&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertSelective"</span> <span class="attr">keyColumn</span>=<span class="string">"id"</span> <span class="attr">keyProperty</span>=<span class="string">"id"</span> <span class="attr">parameterType</span>=<span class="string">"com.yukong.entity.User"</span> <span class="attr">useGeneratedKeys</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    insert into user</span><br><span class="line">    <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">"("</span> <span class="attr">suffix</span>=<span class="string">")"</span> <span class="attr">suffixOverrides</span>=<span class="string">","</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"username != null"</span>&gt;</span></span><br><span class="line">        username,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"svcNum != null"</span>&gt;</span></span><br><span class="line">        svc_num,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"password != null"</span>&gt;</span></span><br><span class="line">        `password`,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"custId != null"</span>&gt;</span></span><br><span class="line">        cust_id,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">"values ("</span> <span class="attr">suffix</span>=<span class="string">")"</span> <span class="attr">suffixOverrides</span>=<span class="string">","</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"username != null"</span>&gt;</span></span><br><span class="line">        #&#123;username,jdbcType=VARCHAR&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"svcNum != null"</span>&gt;</span></span><br><span class="line">        #&#123;svcNum,jdbcType=VARCHAR&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"password != null"</span>&gt;</span></span><br><span class="line">        #&#123;password,jdbcType=VARCHAR&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"custId != null"</span>&gt;</span></span><br><span class="line">        #&#123;custId,jdbcType=BIGINT&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这里我们定义了两个方法。</p><p>国际惯例<code>ctrl+shift+t</code>创建mapper的测试方法，并且插入一条记录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukong.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yukong.SpringbootSpringsecurityApplicationTests;</span><br><span class="line"><span class="keyword">import</span> com.yukong.entity.User;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.password.PasswordEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yukong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-04-11 16:53</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserMapperTest</span> <span class="keyword">extends</span> <span class="title">SpringbootSpringsecurityApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setUsername(<span class="string">"yukong"</span>);</span><br><span class="line">        user.setPassword(<span class="string">"abc123"</span>);</span><br><span class="line">        userMapper.insertSelective(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行测试方法，并且成功插入一条记录。</p><p>创建<code>UserController.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukong.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yukong.entity.User;</span><br><span class="line"><span class="keyword">import</span> com.yukong.mapper.UserMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yukong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-04-11 15:22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/user/&#123;username&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">hello</span><span class="params">(@PathVariable String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userMapper.selectByUsername(username);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法就是根据用户名去数据库查找用户详细信息。</p><p>启动。因为我们之前插入过一条username=yukong的记录，所以我们查询一下,访问<code>127.0.0.1:8080/user/yukong</code></p><p><img src="http://cdn.yukonga.cn/2019-05-07-060558.jpg" alt=""></p><p>我们可以看到 我们被重定向到了一个登录界面，这也是我们之前引入的<code>spring-boot-security-starter</code>起作用了。</p><p>大家可能想问了，用户名跟密码是什么，用户名默认是<code>user</code>，密码在启动的时候已经通过日志打印在控制台了。</p><p><img src="http://cdn.yukonga.cn/2019-05-07-060617.jpg" alt=""></p><p>现在我们输入用户跟密码并且登录。就可以成功访问我们想要访问的接口。</p><p><img src="http://cdn.yukonga.cn/2019-05-07-060632.jpg" alt=""></p><p>从这里我们可以知道，我只需要引入了<code>Spring-Security</code>的依赖，它就开始生效，并且保护我们的接口了，但是现在有一个问题就是，它的用户名只能是user并且密码是通过日志打印在控制台，但是我们希望它能通过数据来访问我们的用户并且判断登录。</p><p>其实想实现这个功能也很简单。这里我们需要了解两个接口。</p><ul><li>UserDetails</li><li>UserDetailsService</li></ul><p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1g1yto9h70kj30z40u0dnt.jpg" alt="UserDetails"></p><p>所以，我们需要将我们的User.java实现这个接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukong.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.GrantedAuthority;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.authority.AuthorityUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yukong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-04-11 16:50</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">UserDetails</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 主键</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 用户名</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 用户号码</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> String svcNum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 密码</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 客户id  1对1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> Long custId;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAccountNonExpired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAccountNonLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCredentialsNonExpired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSvcNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> svcNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSvcNum</span><span class="params">(String svcNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.svcNum = svcNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123;</span><br><span class="line">        <span class="comment">// 这里我们没有用到权限，所以返回一个默认的admin权限</span></span><br><span class="line">        <span class="keyword">return</span> AuthorityUtils.commaSeparatedStringToAuthorityList(<span class="string">"admin"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getCustId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> custId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCustId</span><span class="params">(Long custId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.custId = custId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们再看看<code>UserDetailsService</code></p><p><img src="http://cdn.yukonga.cn/2019-05-07-060652.jpg" alt=""></p><p>它只有一个方法的声明，就是通过用户名去查找用户信息，从这里我们应该知道了，SpringSecurity回调UserDetails#loadUserByUsername去获取用户，但是它不知道用户信息存在哪里，所以定义成接口，让使用者去实现。在我们这个项目用 我们的用户是存在了数据库中，所以我们需要调用UserMapper的方法去访问数据库查询用户信息。这里我们新建一个类叫<code>MyUserDetailsServiceImpl</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukong.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yukong.mapper.UserMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UsernameNotFoundException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yukong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-04-11 17:35</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyUserDetailServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserDetailsService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userMapper.selectByUsername(username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后新建一个类去把我们的<code>UserDetailsService</code>配置进去</p><p>这里我们新建一个<code>SecurityConfig</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukong.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.builders.HttpSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.password.PasswordEncoder;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yukong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-04-11 15:08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDetailsService userDetailsService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PasswordEncoder <span class="title">passwordEncoder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureGlobal</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 配置UserDetailsService 跟 PasswordEncoder 加密器</span></span><br><span class="line">        auth.userDetailsService(userDetailsService).passwordEncoder(passwordEncoder());</span><br><span class="line">        auth.eraseCredentials(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里我们还配置了一个<code>PasswordEncoder</code>加密我们的密码，大家都知道密码明文存数据库是很不安全的。</p><p>接下里我们插入一条记录，需要注意的是 密码需要加密。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukong.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yukong.SpringbootSpringsecurityApplicationTests;</span><br><span class="line"><span class="keyword">import</span> com.yukong.entity.User;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.password.PasswordEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yukong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-04-11 16:53</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserMapperTest</span> <span class="keyword">extends</span> <span class="title">SpringbootSpringsecurityApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PasswordEncoder passwordEncoder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setUsername(<span class="string">"yukong"</span>);</span><br><span class="line">        user.setPassword(passwordEncoder.encode(<span class="string">"abc123"</span>));</span><br><span class="line">        userMapper.insertSelective(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来启动程序，并且登录，这次只需要输入插入到数据中的那条记录的用户名跟密码即可。</p><p>在这里一节中，我们了解到如何使用springsecurity 完成一个登录功能，接下我们将通过分析源码来了解为什么需要这个配置，以及SpringSecurity的工作原理是什么。</p><p><img src="http://cdn.yukonga.cn/2019-05-07-055539.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​    什么是&lt;code&gt;SpringSecurity&lt;/code&gt; ？&lt;/p&gt;
    
    </summary>
    
      <category term="SpringSecurity" scheme="http://www.yukonga.cn/categories/SpringSecurity/"/>
    
    
      <category term="SpringBoot" scheme="http://www.yukonga.cn/tags/SpringBoot/"/>
    
      <category term="SpringSecurity" scheme="http://www.yukonga.cn/tags/SpringSecurity/"/>
    
  </entry>
  
  <entry>
    <title>56. 合并区间(Merge Intervals)</title>
    <link href="http://www.yukonga.cn/2019/01/18/56-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4-Merge-Intervals/"/>
    <id>http://www.yukonga.cn/2019/01/18/56-合并区间-Merge-Intervals/</id>
    <published>2019-01-18T08:37:47.000Z</published>
    <updated>2019-01-18T08:41:21.097Z</updated>
    
    <content type="html"><![CDATA[<p>给出一个区间的集合，请合并所有重叠的区间。</p><p><strong>示例 1:</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">6</span>],[<span class="number">8</span>,<span class="number">10</span>],[<span class="number">15</span>,<span class="number">18</span>]]</span><br><span class="line">输出: [[<span class="number">1</span>,<span class="number">6</span>],[<span class="number">8</span>,<span class="number">10</span>],[<span class="number">15</span>,<span class="number">18</span>]]</span><br><span class="line">解释: 区间 [<span class="number">1</span>,<span class="number">3</span>] 和 [<span class="number">2</span>,<span class="number">6</span>] 重叠, 将它们合并为 [<span class="number">1</span>,<span class="number">6</span>].</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">4</span>,<span class="number">5</span>]]</span><br><span class="line">输出: [[<span class="number">1</span>,<span class="number">5</span>]]</span><br><span class="line">解释: 区间 [<span class="number">1</span>,<span class="number">4</span>] 和 [<span class="number">4</span>,<span class="number">5</span>] 可被视为重叠区间。</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">解题思路：</span><br><span class="line">*  根据对象的<span class="built_in">start</span> 升序排序</span><br><span class="line">*  遍历对象列表</span><br><span class="line">*  如果当前结果列表最后一个元素<span class="keyword">end</span>比下一个元素的<span class="built_in">start</span>小   则把下一个加入到结果列表</span><br><span class="line">*  否则 将当前结果列表中最后一个元素的<span class="keyword">end</span>赋值 = <span class="built_in">max</span>(res.<span class="built_in">get</span>(<span class="keyword">last</span>()).<span class="keyword">end</span>, current.<span class="keyword">end</span>)</span><br></pre></td></tr></table></figure><p><code>java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interval</span> </span>&#123;</span><br><span class="line">          <span class="keyword">int</span> start;</span><br><span class="line">          <span class="keyword">int</span> end;</span><br><span class="line">          Interval() &#123; start = <span class="number">0</span>; end = <span class="number">0</span>; &#125;</span><br><span class="line">          Interval(<span class="keyword">int</span> s, <span class="keyword">int</span> e) &#123; start = s; end = e; &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Definition for an interval.</span></span><br><span class="line"><span class="comment">     * public class Interval &#123;</span></span><br><span class="line"><span class="comment">     *     int start;</span></span><br><span class="line"><span class="comment">     *     int end;</span></span><br><span class="line"><span class="comment">     *     Interval() &#123; start = 0; end = 0; &#125;</span></span><br><span class="line"><span class="comment">     *     Interval(int s, int e) &#123; start = s; end = e; &#125;</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Interval&gt; <span class="title">merge</span><span class="params">(List&lt;Interval&gt; intervals)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据start排序</span></span><br><span class="line">        Collections.sort(intervals, (x,y) -&gt; (x.start - y.start));</span><br><span class="line">        LinkedList&lt;Interval&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Interval inerval: intervals</span><br><span class="line">             ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (res.isEmpty() || res.peekLast().end &lt; inerval.start) &#123;</span><br><span class="line">                res.addLast(inerval);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res.peekLast().end = Math.max(inerval.end, res.peekLast().end );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>python</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for an interval.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interval</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, s=<span class="number">0</span>, e=<span class="number">0</span>)</span>:</span></span><br><span class="line">        self.start = s</span><br><span class="line">        self.end = e</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, intervals)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type intervals: List[Interval]</span></span><br><span class="line"><span class="string">        :rtype: List[Interval]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        intervals.sort(key=<span class="keyword">lambda</span> x : x.start)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> interval <span class="keyword">in</span> intervals:</span><br><span class="line">            <span class="keyword">if</span> len(res) &lt;= <span class="number">0</span> <span class="keyword">or</span> res[len(res)<span class="number">-1</span>].end &lt; interval.start:</span><br><span class="line">                res.append(interval)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res[len(res)<span class="number">-1</span>].end  = max(res[len(res)<span class="number">-1</span>].end, interval.end)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给出一个区间的集合，请合并所有重叠的区间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;],[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;],[&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;],[&lt;span class=&quot;number&quot;&gt;15&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;18&lt;/span&gt;]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: [[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;],[&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;],[&lt;span class=&quot;number&quot;&gt;15&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;18&lt;/span&gt;]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 区间 [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;] 和 [&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;] 重叠, 将它们合并为 [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;].&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;],[&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: [[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 区间 [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;] 和 [&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;] 可被视为重叠区间。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://www.yukonga.cn/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://www.yukonga.cn/tags/leetcode/"/>
    
      <category term="算法" scheme="http://www.yukonga.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="java" scheme="http://www.yukonga.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title> 780. 到达终点 (Reaching Points)</title>
    <link href="http://www.yukonga.cn/2019/01/17/780-%E5%88%B0%E8%BE%BE%E7%BB%88%E7%82%B9-Reaching-Points/"/>
    <id>http://www.yukonga.cn/2019/01/17/780-到达终点-Reaching-Points/</id>
    <published>2019-01-17T09:10:17.000Z</published>
    <updated>2019-01-18T08:38:55.566Z</updated>
    
    <content type="html"><![CDATA[<p>从点 <code>(x, y)</code> 可以<strong>转换</strong>到 <code>(x, x+y)</code>  或者 <code>(x+y, y)</code>。</p><p>给定一个起点 <code>(sx, sy)</code> 和一个终点 <code>(tx, ty)</code>，如果通过一系列的<strong>转换</strong>可以从起点到达终点，则返回 <code>True</code>，否则返回 <code>False</code>。</p><a id="more"></a><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line">输入: sx = <span class="number">1</span>, sy = <span class="number">1</span>, tx = <span class="number">3</span>, ty = <span class="number">5</span></span><br><span class="line">输出: True</span><br><span class="line">解释:</span><br><span class="line">可以通过以下一系列转换从起点转换到终点：</span><br><span class="line">(<span class="number">1</span>, <span class="number">1</span>) -&gt; (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>) -&gt; (<span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="number">2</span>) -&gt; (<span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">输入: sx = <span class="number">1</span>, sy = <span class="number">1</span>, tx = <span class="number">2</span>, ty = <span class="number">2</span></span><br><span class="line">输出: False</span><br><span class="line"></span><br><span class="line">输入: sx = <span class="number">1</span>, sy = <span class="number">1</span>, tx = <span class="number">1</span>, ty = <span class="number">1</span></span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ul><li><code>sx, sy, tx, ty</code> 是范围在 <code>[1, 10^9]</code> 的整数。</li></ul><p>由于本题按照题目给的思路正向一步一步走下去会存在多种情况，我们可以逆向推导。反推起点，因为这样只存在两种种情况。</p><ul><li><code>if : tx &gt; ty then : tx = tx % ty</code></li><li><code>if : ty &gt; tx then : ty = ty % tx</code></li></ul><p><code>java代码</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">reachingPoints</span><span class="params">(<span class="keyword">int</span> sx, <span class="keyword">int</span> sy, <span class="keyword">int</span> tx, <span class="keyword">int</span> ty)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(tx &gt; sx &amp;&amp; ty &gt; sy) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tx &gt; ty) &#123;</span><br><span class="line">                tx = tx % ty;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ty = ty % tx;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tx == sx) &#123;</span><br><span class="line">           <span class="keyword">return</span>  (ty - sy)   % tx == <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ty == sy) &#123;</span><br><span class="line">           <span class="keyword">return</span> (tx  - sx) % ty  == <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>python代码</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reachingPoints</span><span class="params">(self, sx, sy, tx, ty)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type sx: int</span></span><br><span class="line"><span class="string">        :type sy: int</span></span><br><span class="line"><span class="string">        :type tx: int</span></span><br><span class="line"><span class="string">        :type ty: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">while</span> tx &gt; sx <span class="keyword">and</span> ty &gt; sy:</span><br><span class="line">            <span class="keyword">if</span> tx &gt; ty:</span><br><span class="line">                tx = tx % ty</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ty = ty % tx</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> tx == sx:</span><br><span class="line">             <span class="keyword">return</span> (ty - sy) % sx == <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> ty == sy:</span><br><span class="line">             <span class="keyword">return</span> (tx - sx) % sy == <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从点 &lt;code&gt;(x, y)&lt;/code&gt; 可以&lt;strong&gt;转换&lt;/strong&gt;到 &lt;code&gt;(x, x+y)&lt;/code&gt;  或者 &lt;code&gt;(x+y, y)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;给定一个起点 &lt;code&gt;(sx, sy)&lt;/code&gt; 和一个终点 &lt;code&gt;(tx, ty)&lt;/code&gt;，如果通过一系列的&lt;strong&gt;转换&lt;/strong&gt;可以从起点到达终点，则返回 &lt;code&gt;True&lt;/code&gt;，否则返回 &lt;code&gt;False&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://www.yukonga.cn/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://www.yukonga.cn/tags/leetcode/"/>
    
      <category term="算法" scheme="http://www.yukonga.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="java" scheme="http://www.yukonga.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>基于SpringCloud Finchley.SR1 、SpringBoot 2.x、 vue、element-ui 微服务基础脚手架</title>
    <link href="http://www.yukonga.cn/2018/11/29/%E5%9F%BA%E4%BA%8ESpringCloud-Finchley-SR1-%E3%80%81SpringBoot-2-x%E3%80%81-vue%E3%80%81element-ui-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%9F%BA%E7%A1%80%E8%84%9A%E6%89%8B%E6%9E%B6/"/>
    <id>http://www.yukonga.cn/2018/11/29/基于SpringCloud-Finchley-SR1-、SpringBoot-2-x、-vue、element-ui-微服务基础脚手架/</id>
    <published>2018-11-29T07:48:17.000Z</published>
    <updated>2019-05-07T06:29:20.276Z</updated>
    
    <content type="html"><![CDATA[<p>panda是基于SpringCloud Finchley.SR1 、SpringBoot 2.x、 vue、element-ui 微服务基础脚手架<br>对于日常开发而言提供基础权限控制，动态菜单，才用前后端分离架构，前台采用vue 后台使用springcloud提供rest接口。对于以后开发，只需要在1panda-service` 添加业务模块即可，大大减少工作量。</p><a id="more"></a><h2 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h2><p>github 地址  跪求大家star<br><a href="https://github.com/YuKongEr/panda-cloud" target="_blank" rel="noopener">panda微服务工程地址</a><br><a href="https://github.com/YuKongEr/panda-admin" target="_blank" rel="noopener">panda-admin前台工程地址</a><br>panda是基于SpringCloud Finchley.SR1 、SpringBoot 2.x、 vue、element-ui 微服务基础脚手架<br>对于日常开发而言提供基础权限控制，动态菜单，才用前后端分离架构，前台采用vue 后台使用springcloud提供rest接口。对于以后开发，只需要在1panda-service` 添加业务模块即可，大大减少工作量。</p><ul><li>panda-server 服务注册中心</li><li>panda-auth  oauth2 认证服务器 提供token</li><li>panda-common 公共模块集合</li><li>panda-config-server 配置中心服务器</li><li>panda-gateway 统一网关，提供动态路由 同时也是oauth2的资源服务器</li><li>panda-service 业务模块集合<ul><li>panda-user-service 统一用户管理模块</li><li>panda-gen-service 代码生成器模块</li></ul></li></ul><p>后续会陆续支持 zipkin服务链路监控  springboot-admin 服务健康监控等</p><h2 id="技术选型文档"><a class="markdownIt-Anchor" href="#技术选型文档"></a> 技术选型&amp;文档</h2><ul><li><p>Spring Boot（<a href="https://www.jianshu.com/p/0d400d30936b" target="_blank" rel="noopener">查看Spring Boot学习&amp;使用指南</a>）</p></li><li><p>Spring Cloud（<a href="https://springcloud.cc/spring-cloud-dalston.html" target="_blank" rel="noopener">查看官方中文文档</a>）</p></li><li><p>Spring Security Oauth2（<a href="http://projects.spring.io/spring-security-oauth/docs/oauth2.html" target="_blank" rel="noopener">查看官方中文文档</a>）</p></li><li><p>MyBatis（<a href="http://www.mybatis.org/mybatis-3/zh/index.html" target="_blank" rel="noopener">查看官方中文文档</a>）</p></li><li><p>MyBatis plus（<a href="http://mp.baomidou.com/" target="_blank" rel="noopener">查看官方中文文档</a>）</p></li><li><p>Vue.js（<a href="https://cn.vuejs.org/" target="_blank" rel="noopener">查看官方中文文档</a>）</p></li><li><p>ElementUI（<a href="http://element.eleme.io/#/" target="_blank" rel="noopener">查看官方中文文档</a>）</p></li><li><p>Redis</p></li><li><p>RabbitMq</p></li><li><p>OSS</p></li></ul><h2 id="进度"><a class="markdownIt-Anchor" href="#进度"></a> 进度</h2><p><img src="http://cdn.yukonga.cn/2019-05-07-060058.jpg" alt=""></p><p><img src="http://cdn.yukonga.cn/2019-05-07-060136.jpg" alt=""><img src="http://cdn.yukonga.cn/2019-05-07-060213.jpg" alt=""></p><p><img src="http://cdn.yukonga.cn/2019-05-07-060230.jpg" alt=""></p><p><img src="http://cdn.yukonga.cn/2019-05-07-060247.jpg" alt=""></p><p><img src="http://cdn.yukonga.cn/2019-05-07-060308.jpg" alt=""></p><p><img src="http://cdn.yukonga.cn/2019-05-07-060325.jpg" alt=""></p><p><img src="http://cdn.yukonga.cn/2019-05-07-060343.jpg" alt=""></p><p><img src="http://cdn.yukonga.cn/2019-05-07-060418.jpg" alt=""></p><p><img src="http://cdn.yukonga.cn/2019-05-07-060438.jpg" alt=""></p><p><img src="http://cdn.yukonga.cn/2019-05-07-060456.jpg" alt=""></p><ul><li>[x] 登录管理<ul><li>[x] 登录</li><li>[x] 登出</li></ul></li><li>[x] 系统管理<ul><li>[x] 资源管理<ul><li>[x] 查看资源</li><li>[x] 添加资源</li><li>[x] 修改资源</li><li>[x] 删除资源</li></ul></li><li>[x] 角色管理<ul><li>[x] 查看角色</li><li>[x] 添加角色</li><li>[x] 修改角色</li><li>[x] 分配资源</li></ul></li><li>[x] 用户管理<ul><li>[x] 查看用户</li><li>[x] 添加用户</li><li>[x] 修改用户</li><li>[x] 分配角色</li></ul></li><li>[ ] 字典管理</li><li>[ ] 终端管理</li><li>[ ] 令牌管理</li></ul></li><li>[x] 日志管理<ul><li>[x] 登录日志<ul><li>[x] 查询日志</li></ul></li><li>[x] 操作日志<ul><li>[x] 查询日志</li></ul></li><li>[x] 异常日志<ul><li>[x] 查询日志</li></ul></li></ul></li><li>[x] 研发管理<ul><li>[x] 代码生成<ul><li>[x] 查询表格</li><li>[x] 生成代码</li></ul></li><li>[x] 接口文档</li></ul></li><li>[ ] 个人中心<ul><li>[ ] 查看资料</li><li>[ ] 修改资料</li></ul></li></ul><h2 id="启动教程"><a class="markdownIt-Anchor" href="#启动教程"></a> 启动教程</h2><ul><li>根据<code>init.sql</code> 创建数据库</li><li>首先启动 <code>panda-server</code> 注册中心</li><li>然后启动<code>panda-config-server</code>配置注册中心</li><li>启动统一用户服务<code>panda-user-service</code></li><li>启动认证服务<code>panda-auth</code>  以为认证服务依赖于统一用户服务，所以 统一用户服务器启动在前</li><li>最后启动<code>panda-gateway</code> 网关</li><li>然后启动前台工程  <code>npm run dev / yarn run dev</code>就可以<br>目前完成 基础权限模块，接下来会完善动态路由界面可视化配置，与个人中心模块。</li></ul><p>github 地址  跪求大家star<br><a href="https://github.com/YuKongEr/panda" target="_blank" rel="noopener">panda微服务工程地址</a><br><a href="https://github.com/YuKongEr/panda-admin" target="_blank" rel="noopener">panda-admin前台工程地址</a><br>希望大家有兴趣一起完善的可以联系我<br>最后大家关注一下我的个人公众号把。关注我公众号即可获取源码<br><img src="http://cdn.yukonga.cn/2019-05-07-055539.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;panda是基于SpringCloud Finchley.SR1 、SpringBoot 2.x、 vue、element-ui 微服务基础脚手架&lt;br&gt;
对于日常开发而言提供基础权限控制，动态菜单，才用前后端分离架构，前台采用vue 后台使用springcloud提供rest接口。对于以后开发，只需要在1panda-service` 添加业务模块即可，大大减少工作量。&lt;/p&gt;
    
    </summary>
    
      <category term="SpringCloud" scheme="http://www.yukonga.cn/categories/SpringCloud/"/>
    
    
      <category term="SpringBoot" scheme="http://www.yukonga.cn/tags/SpringBoot/"/>
    
      <category term="SpringCloud" scheme="http://www.yukonga.cn/tags/SpringCloud/"/>
    
      <category term="Vue" scheme="http://www.yukonga.cn/tags/Vue/"/>
    
      <category term="ElementUI" scheme="http://www.yukonga.cn/tags/ElementUI/"/>
    
  </entry>
  
  <entry>
    <title>【java并发编程实战6】AQS之独占锁ReentrantLock实现</title>
    <link href="http://www.yukonga.cn/2018/09/10/%E3%80%90java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%986%E3%80%91AQS%E4%B9%8B%E7%8B%AC%E5%8D%A0%E9%94%81ReentrantLock%E5%AE%9E%E7%8E%B0/"/>
    <id>http://www.yukonga.cn/2018/09/10/【java并发编程实战6】AQS之独占锁ReentrantLock实现/</id>
    <published>2018-09-10T10:11:08.000Z</published>
    <updated>2019-05-07T05:59:11.868Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>自从JDK1.5后，jdk新增一个并发工具包<code>java.util.concurrent</code>，提供了一系列的并发工具类。而今天我们需要学习的是<code>java.util.concurrent.lock</code>也就是它下面的lock包，其中有一个最为常见类<code>ReentrantLock</code>，</p><p>我们知道<code>ReentrantLock</code>的功能是实现代码段的并发访问控制，也就是通常意义上所说的锁。之前我们也学习过一种锁的实现，也就是<code>synchronized</code>关键词，<code>synchronized</code>是在字节码层面，通过对象的监视器锁实现的。那么<code>ReentrantLock</code>又是怎么实现的呢？</p><a id="more"></a><p>如果不看源码，可能会以为它的实现是通过类似于<code>synchronized</code>，通过对象的监视器锁实现的。但事实上它仅仅是一个工具类！没有使用更“高级”的机器指令，不是关键字，也不依靠JDK编译时的特殊处理，仅仅作为一个普普通通的类就完成了代码块的并发访问控制，这就更让人疑问它怎么实现的代码块的并发访问控制的了。</p><p>我们查看源码发现，它是通过继承抽象类实现的<code>AbstractQueuedSynchronizer</code>，为了方便描述，接下来我将用AQS代替<code>AbstractQueuedSynchronizer</code>。</p><h1 id="关于aqs"><a class="markdownIt-Anchor" href="#关于aqs"></a> 关于AQS</h1><blockquote><p>AQS，它是用来构建锁或者其他同步组建的基础框架，我们见过许多同步工具类都是基于它构建的。包括<code>ReentrantLock、CountDownLatch等</code>。在深入了解AQS了解之前，我们需要知道锁跟AQS的区别。锁，它是面向使用者的，它定义了使用者与锁交互的接口，隐藏了实现的细节；而AQS面像的是锁的实现者，它简化了锁的实现。锁与AQS很好的隔离使用者与实现者所需要关注的领域。那么我们今天就作为一个锁的实现者，一步一步分析锁的实现。</p></blockquote><p>AQS又称同步器，它的内部有一个int成员变量state表示同步状态，还有一个内置的FIFO队列来实现资源获取线程的排队工作。通过它们我们就能实现锁。</p><p>在实现锁之前，我们需要考虑做为锁的使用者，锁会有哪几种？</p><p>通常来说，锁分为两种，一种是独占锁(排它锁,互斥锁),另一种就是共享锁了。根据这两类，其实AQS也给我们提供了两套API。而我们作为锁的实现者，通常都是要么全部实现它的独占api，要么实现它的共享api，而不会出现一起实现的。即使juc内置的<code>ReentrantReadWriteLock</code>也是通过两个子类分别来实现的。</p><h1 id="锁的实现"><a class="markdownIt-Anchor" href="#锁的实现"></a> 锁的实现</h1><h2 id="独占锁"><a class="markdownIt-Anchor" href="#独占锁"></a> 独占锁</h2><p>独占锁又名互斥锁，同一时间，只有一个线程能获取到锁，其余的线程都会被阻塞等待。其中我们常用的<code>ReentrantLock</code>就是一种独占锁，我们一起来分<code>ReentrantLock</code> 析分析<code>ReentrantLock</code>的同时看一看AQS的实现，再推理出AQS独特的设计思路和实现方式。最后，再看其共享控制功能的实现。</p><p>首先我们来看看获取锁的过程</p><h2 id="加锁"><a class="markdownIt-Anchor" href="#加锁"></a> 加锁</h2><p>我们查看<code>ReentrantLock</code>的源码。来分析它的lock方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      sync.lock();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>与我们之前分析的一样，锁的具体实现由内部的代理类完成，lock只是暴露给锁的使用者的一套api。使用过ReentrantLock的同学应该知道，ReentrantLock又分为公平锁和非公平锁，所以，ReentrantLock内部只有两个sync的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Sync object for non-fair locks</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span></span>&#123;..&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Sync object for fair locks</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span></span>&#123;..&#125;</span><br></pre></td></tr></table></figure><ul><li>公平锁 ：每个线程获取锁的顺序是按照调用lock方法的先后顺序来的。</li><li>非公平锁：每个线程获取锁的顺序是不会按照调用lock方法的先后顺序来的。完全看运气。</li></ul><p>所以我们完全可以猜测到，这个公平与不公平的区别就体现在锁的获取过程。我们以公平锁为例，来分析获取锁过程，最后对比非公平锁的过程，寻找差异。</p><h3 id="lock"><a class="markdownIt-Anchor" href="#lock"></a> lock</h3><p>查看FairSync的lock方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           acquire(<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>这里它调用到了父类AQS的acquire方法，所以我们继续查看acquire方法的代码</p><h3 id="acquire"><a class="markdownIt-Anchor" href="#acquire"></a> acquire</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires in exclusive mode, ignoring interrupts.  Implemented</span></span><br><span class="line"><span class="comment">     * by invoking at least once &#123;<span class="doctag">@link</span> #tryAcquire&#125;,</span></span><br><span class="line"><span class="comment">     * returning on success.  Otherwise the thread is queued, possibly</span></span><br><span class="line"><span class="comment">     * repeatedly blocking and unblocking, invoking &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * #tryAcquire&#125; until success.  This method can be used</span></span><br><span class="line"><span class="comment">     * to implement method &#123;<span class="doctag">@link</span> Lock#lock&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment">     *        &#123;<span class="doctag">@link</span> #tryAcquire&#125; but is otherwise uninterpreted and</span></span><br><span class="line"><span class="comment">     *        can represent anything you like.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) </span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>查看方法方法的注释我们可以知道这个方法的作用，这里我简单的翻译一下.</p><p>Acquires方法是一个独占锁模式的方法，它是不会响应中断的。它至少执行一次tryAcquire去获取锁，如果返回true，则代表获取锁成功，否则它将会被加入等待队列阻塞，直到重新尝试获取锁成功。所以我们需要看看尝试获取锁的方法tryAcquire的实现</p><h3 id="tryacruire"><a class="markdownIt-Anchor" href="#tryacruire"></a> tryAcruire</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>抛出一个异常，没有实现。所以我们需要查看它的子类，在我们这里就是FairSync的实现。</p><blockquote><p>这里也会大家会有疑惑，没有实现为什么不写成抽象方法呢，前面我们提到过，我们不会同时在一个类中实现独占锁跟共享锁的api，那么tryAcruire是属于独占锁，那么如果我想一个共享锁也要重新独占锁的方法吗？所以大师的设计是绝对没有问题的。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>目前为止，如果获取锁成功，则返回true，获取锁的过程结束，如果获取失败，则返回false</p><p>按照之前的逻辑，如果线程获取锁失败，则会被放入到队列中，但是在放入之前，需要给线程包装一下。</p><p>那么这个addWaiter就是包装线程并且放入到队列的过程实现的方法。</p><h3 id="addwaiter"><a class="markdownIt-Anchor" href="#addwaiter"></a> addWaiter</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Creates and enqueues node for current thread and given mode.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> the new node</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">     Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">     <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">     Node pred = tail;</span><br><span class="line">     <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">         node.prev = pred;</span><br><span class="line">         <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">             pred.next = node;</span><br><span class="line">             <span class="keyword">return</span> node;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     enq(node);</span><br><span class="line">     <span class="keyword">return</span> node;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>注释: 把当前线程作为一个节点添加到队列中，并且为这个节点设置模式</p><blockquote><p>模式： 也就是独占模式/共享模式,在这里模式是形参，所以我们看看起调方</p><p><code>acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</code> Node.EXCLUSIVE 就代表这是独占锁模式。</p></blockquote><p>创建好节点后，将节点加入到队列尾部，此处，在队列不为空的时候，先尝试通过cas方式修改尾节点为最新的节点，如果修改失败，意味着有并发，这个时候才会进入enq中死循环，“自旋”方式修改。</p><p>将线程的节点接入到队里中后，当然还需要做一件事:将当前线程挂起！这个事，由acquireQueued来做。</p><p>在解释acquireQueued之前，我们需要先看下AQS中队列的内存结构，我们知道，队列由Node类型的节点组成，其中至少有两个变量，一个封装线程，一个封装节点类型。</p><p>而实际上，它的内存结构是这样的（第一次节点插入时，第一个节点是一个空节点，代表有一个线程已经获取锁，事实上，队列的第一个节点就是代表持有锁的节点）：<br><img src="https://upload-images.jianshu.io/upload_images/5338436-332432b498a8401d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="0730009.png"></p><p>黄色节点为队列默认的头节点，每次有线程竞争失败，进入队列后其实都是插入到队列的尾节点（tail后面）后面。这个从enq方法可以看出来，上文中有提到enq方法为将节点插入队列的方法:</p><h3 id="enq"><a class="markdownIt-Anchor" href="#enq"></a> enq</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node t = tail;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">                <span class="comment">// 一个空的节点，通常代表获取锁的线程</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                    tail = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node.prev = t;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    t.next = node;</span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="acquirequeued"><a class="markdownIt-Anchor" href="#acquirequeued"></a> acquireQueued</h3><p>接着我们来看看当节点被放入到队列中，如何将线程挂起，也就是看看acquireQueued方法的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">// 获取当前节点前驱结点</span></span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="comment">// 如果前驱节点是head，那么它就是等待队列中的第一个线程</span></span><br><span class="line">                <span class="comment">// 因为我们知道head就是获取线程的节点，那么它就有机会再次获取锁</span></span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    <span class="comment">//成功后，将上图中的黄色节点移除，Node1变成头节点。 也证实了head就是获取锁的线程的节点。</span></span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 1、检查前一个节点的状态，判断是否要挂起</span></span><br><span class="line">                <span class="comment">// 2、如果需要挂起，则通过JUC下的LockSopport类的静态方法park挂起当前线程，直到被唤醒。</span></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 如果发生异常</span></span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                <span class="comment">// 取消请求，也就是将当前节点重队列中移除。</span></span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里我还需要解释的是：</p><p>1、Node节点除了存储当前线程之外，节点类型，前驱后驱指针之后，还存储一个叫waitStatus的变量，该变量用于描述节点的状态。共有四种状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** waitStatus value to indicate thread has cancelled */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/** waitStatus value to indicate successor's thread needs unparking */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">/** waitStatus value to indicate thread is waiting on condition */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * waitStatus value to indicate the next acquireShared should</span></span><br><span class="line"><span class="comment">     * unconditionally propagate</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>分别表示：</p><ul><li>1 = 取消状态，该节点将会被队列移除。</li><li>-1 = 等待状态，后驱节点处于等待状态。</li><li>-2 = 等待被通知，该节点将会阻塞至被该锁的condition的await方法唤醒。</li><li>-3 = 共享传播状态，代表该节点的状态会向后传播。</li></ul><p>到此为止，一个线程对于锁的一次竞争才告于段落，结果有两种，要么成功获取到锁（不用进入到AQS队列中），要么，获取失败，被挂起，等待下次唤醒后继续循环尝试获取锁，值得注意的是，AQS的队列为FIFO队列，所以，每次被CPU假唤醒，且当前线程不是出在头节点的位置，也是会被挂起的。AQS通过这样的方式，实现了竞争的排队策略。</p><h2 id="释放锁"><a class="markdownIt-Anchor" href="#释放锁"></a> 释放锁</h2><p>看完了加锁，再看释放锁。我们先不看代码也可以猜测到释放锁需要的步骤。</p><ul><li>队列的头节点是当前获取锁的线程，所以我们需要移除头节点</li><li>释放锁，唤醒头节点后驱节点来竞争锁</li></ul><p>接下来我们查看源码来验证我们的猜想是否在正确。</p><h3 id="unlock"><a class="markdownIt-Anchor" href="#unlock"></a> unlock</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>unlock方法调用AQS的release方法，因为我们的acquire的时候传入的是1，也就是同步状态量+1，那么对应的解锁就要-1。</p><h3 id="release"><a class="markdownIt-Anchor" href="#release"></a> release</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 尝试释放锁</span></span><br><span class="line">      <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">          <span class="comment">// 释放锁成功，获取当前队列的头节点</span></span><br><span class="line">          Node h = head;</span><br><span class="line">          <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">              <span class="comment">// 唤醒当前节点的下一个节点</span></span><br><span class="line">              unparkSuccessor(h);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="tryrelease"><a class="markdownIt-Anchor" href="#tryrelease"></a> tryRelease</h3><p>同样的它是交给子类实现的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">           <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">       <span class="comment">// 当前线程不是获取锁的线程 抛出异常</span></span><br><span class="line">           <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">           <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">       <span class="comment">// 因为是重入的关系，不是每次释放锁c都等于0，直到最后一次释放锁时，才通知AQS不需要再记录哪个线程正在获取锁。</span></span><br><span class="line">           <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">               free = <span class="keyword">true</span>;</span><br><span class="line">               setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           setState(c);</span><br><span class="line">           <span class="keyword">return</span> free;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="unparksuccessor"><a class="markdownIt-Anchor" href="#unparksuccessor"></a> unparkSuccessor</h3><p>释放锁成功之后，就唤醒头节点后驱节点来竞争锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">       <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">           compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">       Node s = node.next;</span><br><span class="line">       <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           s = <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">               <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                   s = t;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">           LockSupport.unpark(s.thread);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>值得注意的是，寻找的顺序是从队列尾部开始往前去找的最前面的一个waitStatus小于0的节点。因为大于0 就是1状态的节点是取消状态。</p><h2 id="公平锁与非公平锁"><a class="markdownIt-Anchor" href="#公平锁与非公平锁"></a> 公平锁与非公平锁</h2><p>到此我们锁获取跟锁的释放已经分析的差不多。那么公平锁跟非公平锁的区别在于加锁的过程。对比代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3000897897090466540L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7316153563782823691L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Performs lock.  Try immediate barge, backing up to normal</span></span><br><span class="line"><span class="comment">         * acquire on failure.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中也可以看出来，非公平在公平锁的加锁的逻辑之前先直接cas修改一次state变量（尝试获取锁），成功就返回，不成功再排队，从而达到不排队直接抢占的目的。</p><p>欢迎大家关注一下我的个人公众号。一起交流一起学习，有问必答。<br><img src="http://cdn.yukonga.cn/2019-05-07-055539.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;自从JDK1.5后，jdk新增一个并发工具包&lt;code&gt;java.util.concurrent&lt;/code&gt;，提供了一系列的并发工具类。而今天我们需要学习的是&lt;code&gt;java.util.concurrent.lock&lt;/code&gt;也就是它下面的lock包，其中有一个最为常见类&lt;code&gt;ReentrantLock&lt;/code&gt;，&lt;/p&gt;
&lt;p&gt;我们知道&lt;code&gt;ReentrantLock&lt;/code&gt;的功能是实现代码段的并发访问控制，也就是通常意义上所说的锁。之前我们也学习过一种锁的实现，也就是&lt;code&gt;synchronized&lt;/code&gt;关键词，&lt;code&gt;synchronized&lt;/code&gt;是在字节码层面，通过对象的监视器锁实现的。那么&lt;code&gt;ReentrantLock&lt;/code&gt;又是怎么实现的呢？&lt;/p&gt;
    
    </summary>
    
      <category term="java并发编程实战" scheme="http://www.yukonga.cn/categories/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="java" scheme="http://www.yukonga.cn/tags/java/"/>
    
      <category term="多线程" scheme="http://www.yukonga.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="独占锁" scheme="http://www.yukonga.cn/tags/%E7%8B%AC%E5%8D%A0%E9%94%81/"/>
    
      <category term="AQS" scheme="http://www.yukonga.cn/tags/AQS/"/>
    
  </entry>
  
  <entry>
    <title>【java并发编程实战5】线程与线程通信</title>
    <link href="http://www.yukonga.cn/2018/09/07/%E3%80%90java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%985%E3%80%91%E7%BA%BF%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    <id>http://www.yukonga.cn/2018/09/07/【java并发编程实战5】线程与线程通信/</id>
    <published>2018-09-07T09:36:13.000Z</published>
    <updated>2019-05-07T05:59:08.364Z</updated>
    
    <content type="html"><![CDATA[<p>现代操作系统在运行一个程序，会为其创建一个进程。然后它调度的最小单元是线程，线程也叫轻量级进程(Light Weight Process)，在一个进程中可以创建多个线程，这些线程都有各自的计算器，堆，栈和局部变量</p><a id="more"></a><h2 id="线程介绍"><a class="markdownIt-Anchor" href="#线程介绍"></a> 线程介绍</h2><h3 id="线程定义"><a class="markdownIt-Anchor" href="#线程定义"></a> 线程定义</h3><blockquote><p>现代操作系统在运行一个程序，会为其创建一个进程。然后它调度的最小单元是线程，线程也叫轻量级进程(Light Weight Process)，在一个进程中可以创建多个线程，这些线程都有各自的计算器，堆，栈和局部变量，并且都能访问共享的内存变量。处理器在这些线程上高速切换，让用户感觉这些线程在同时在执行。</p></blockquote><h3 id="线程优先级"><a class="markdownIt-Anchor" href="#线程优先级"></a> 线程优先级</h3><p>在计算机操作系统，操作系统采用的是时间片轮转法来调度线程的。操作系统会为每个线程分配时间片，当线程的时间片用了，就会发生线程调度，并且等待下次分配，线程分配到的时间片的多与少就决定线程能占用cpu的时间。</p><p>线程优先级就是决定线程能分配的时间片的多与少。在java线程中，可以通过<code>priority</code>来控制线程优先级，线程优先级的范围从<code>1~10</code>。默认值是<code>5</code>，优先级大的分配的时间片会大于优先级低，所以频繁阻塞线程可以设置高优先级，而占用cpu比较长的线程（计算线程）可以设置较低的优先级。但是在有的操作系统会无视对线程有限制。</p><h3 id="线程的状态"><a class="markdownIt-Anchor" href="#线程的状态"></a> 线程的状态</h3><table><thead><tr><th style="text-align:center">状态名称</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td style="text-align:center">NEW</td><td style="text-align:center">初始状态，线程被构建，但是还没执行start()方法</td></tr><tr><td style="text-align:center">RUNNABLE</td><td style="text-align:center">运行状态，Java中将就绪与运行统称为 ”运行中“</td></tr><tr><td style="text-align:center">BLOCKED</td><td style="text-align:center">阻塞状态，表示线程阻塞与获取锁的过程</td></tr><tr><td style="text-align:center">WAITING</td><td style="text-align:center">等待状态，表示线程进入等待状态，进入该状态需要等待其他线程做出一些特定的动作（通知或者中断）</td></tr><tr><td style="text-align:center">TIME_WAITING</td><td style="text-align:center">超时等待状态，该状态不同于WAITING，它是可以在指定时间能自行返回的</td></tr><tr><td style="text-align:center">TERMINATED</td><td style="text-align:center">终止状态，表示当前下才能已经执行完成</td></tr></tbody></table><p>下面就用代码演示各种方法时线程的状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadState</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> TimeWaiting(), <span class="string">"TimeWaitingThread"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Waiting(), <span class="string">"WaitingThread"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Blocked(), <span class="string">"BlockedThread - 1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Blocked(), <span class="string">"BlockedThread - 2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeWaitnging</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                  TimeUnit.SECONDS.sleep(<span class="number">1000L</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Waitnging</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span>(Waiting.class) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Waiting.class.wait()</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Blocked</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Blocked.class) &#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                          TimeUnit.SECONDS.sleep(<span class="number">1000L</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java中线程状态的变迁如下图</p><p><img src="https://upload-images.jianshu.io/upload_images/5338436-fb8fa816ef0dde42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1536140160461.png"></p><h2 id="线程通信"><a class="markdownIt-Anchor" href="#线程通信"></a> 线程通信</h2><h3 id="通知等待机制"><a class="markdownIt-Anchor" href="#通知等待机制"></a> 通知等待机制</h3><p>首先我们需要了解一下wait()与notify方法</p><ul><li>wait() 调用该方法的线程会进入WAITING状态，只有等待另外线程通知或者被中断才能返回，wait方法会释放对象锁</li><li>wait(long) 调用该方法的线程会进入TIME_WAITING状态， 超过等待一段时间，参数单位是毫秒，意味着等待n毫秒后，如果没有通知就返回</li><li>wait(long, int) 控制跟粒度更细，到纳秒</li><li>notify) 通知一个在此对象上等待的线程，从其从wait()方法返回，返回的前提是该线程获取到了对象的线程锁。</li><li>notifyAll() 通知在此对象上等待的所有线程。</li></ul><p>现在我们可以通过 <code>synchronized+wait+notify</code>来实现一个简单的<code>通知\等待模型</code></p><ul><li>等待方（消费者）</li></ul><p>1）获取对象锁</p><p>2）如果条件不满足，那么调用对象的wait()方法，被通知依旧要检查条件。</p><p>3）条件满足则执行对应的逻辑</p><p>伪代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(对象) &#123;</span><br><span class="line">    <span class="keyword">while</span> (条件不满足) &#123;</span><br><span class="line">        对象.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    处理对应逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通知方法 (生产者)</li></ul><p>1）获取对象锁</p><p>2）改变条件</p><p>3）通知所有等在在此对象上的线程</p><p>对应伪代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(对象) &#123;</span><br><span class="line">    改变条件</span><br><span class="line">    对象.notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据上面的通知等待机制，我们可以实现一个简单的线程池。</p><p>首先我们先定义一下线程池的接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yukong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/9/5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 线程池接口，抽象出来，定义规范</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ThreadPool</span>&lt;<span class="title">Job</span> <span class="keyword">extends</span> <span class="title">Runnable</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行任务，这个任务需要继承Runnable接口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> job 任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Job job)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加工作者数目</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num 要添加的数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addWorkers</span><span class="params">(<span class="keyword">int</span> num)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 减少工作者数目</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num 要减少的数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeWorks</span><span class="params">(<span class="keyword">int</span> num)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取正在等待执行的任务数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getJobCount</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后编写一个实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yukong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/9/5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultThreadPool</span>&lt;<span class="title">Job</span> <span class="keyword">extends</span> <span class="title">Runnable</span>&gt; <span class="keyword">implements</span> <span class="title">ThreadPool</span>&lt;<span class="title">Job</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池最大数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_WORKER_NUMBERS = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池默认数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_WORKER_NUMBERS = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池最小数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_WORKER_NUMBERS = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 任务队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LinkedList&lt;Job&gt;  jobs = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工作者列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Worker&gt; workers = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工作者线程数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> workerNum = DEFAULT_WORKER_NUMBERS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程编号生成</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger threadNum = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultThreadPool</span><span class="params">(<span class="keyword">int</span> workerNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.workerNum = workerNum &gt; MAX_WORKER_NUMBERS ? MAX_WORKER_NUMBERS</span><br><span class="line">                : workerNum &lt; MIN_WORKER_NUMBERS ? MIN_WORKER_NUMBERS</span><br><span class="line">                : workerNum;</span><br><span class="line">        initializeWorkers(<span class="keyword">this</span>.workerNum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initializeWorkers</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            Worker worker = <span class="keyword">new</span> Worker();</span><br><span class="line">            workers.add(worker);</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(worker, <span class="string">"ThreadPool-Worker-"</span> + threadNum.incrementAndGet());</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Job job)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (job != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (jobs) &#123;</span><br><span class="line">                jobs.addLast(job);</span><br><span class="line">                jobs.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Worker worker: workers) &#123;</span><br><span class="line">            worker.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addWorkers</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">synchronized</span> (jobs) &#123;</span><br><span class="line">           <span class="comment">// 限制新增的数目与已有的数目之和超过最大数</span></span><br><span class="line">           <span class="keyword">if</span> (num + <span class="keyword">this</span>.workerNum&gt; MAX_WORKER_NUMBERS) &#123;</span><br><span class="line">               num = MAX_WORKER_NUMBERS - <span class="keyword">this</span>.workerNum;</span><br><span class="line">           &#125;</span><br><span class="line">           initializeWorkers(num);</span><br><span class="line">           <span class="keyword">this</span>.workerNum += num;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeWorks</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (jobs) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &gt; <span class="keyword">this</span>.workerNum) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"beyond workNum"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (count &lt; num) &#123;</span><br><span class="line">                Worker worker = workers.get(count);</span><br><span class="line">                <span class="keyword">if</span> (workers.remove(worker)) &#123;</span><br><span class="line">                    worker.shutdown();</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.workerNum -= num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getJobCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jobs.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> Boolean running = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (running) &#123;</span><br><span class="line">                Job job = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">synchronized</span> (jobs) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (jobs.isEmpty()) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            jobs.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            <span class="comment">// 设置中断标记，让外界感知</span></span><br><span class="line">                            Thread.currentThread().interrupt();</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    job = jobs.removeFirst();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (job != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    job.run();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            running = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此我们就实现了一个简单的线程池了。</p><p>欢迎大家关注一下我的个人公众号。一起交流一起学习，有问必答。<br><img src="http://cdn.yukonga.cn/2019-05-07-055539.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现代操作系统在运行一个程序，会为其创建一个进程。然后它调度的最小单元是线程，线程也叫轻量级进程(Light Weight Process)，在一个进程中可以创建多个线程，这些线程都有各自的计算器，堆，栈和局部变量&lt;/p&gt;
    
    </summary>
    
      <category term="java并发编程实战" scheme="http://www.yukonga.cn/categories/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="java" scheme="http://www.yukonga.cn/tags/java/"/>
    
      <category term="多线程" scheme="http://www.yukonga.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="线程通信" scheme="http://www.yukonga.cn/tags/%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>【java并发编程实战4】偏向锁-轻量锁-重量锁的那点秘密synchronize实现原理</title>
    <link href="http://www.yukonga.cn/2018/09/07/%E3%80%90java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%984%E3%80%91%E5%81%8F%E5%90%91%E9%94%81-%E8%BD%BB%E9%87%8F%E9%94%81-%E9%87%8D%E9%87%8F%E9%94%81%E7%9A%84%E9%82%A3%E7%82%B9%E7%A7%98%E5%AF%86synchronize%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://www.yukonga.cn/2018/09/07/【java并发编程实战4】偏向锁-轻量锁-重量锁的那点秘密synchronize实现原理/</id>
    <published>2018-09-07T00:26:12.000Z</published>
    <updated>2019-05-07T06:24:00.818Z</updated>
    
    <content type="html"><![CDATA[<p>在多线程并发编程中，synchronized一直都是元老级别的角色，人们都通常称呼它为<strong>重量锁</strong>，但是在jdk1.6版本之后，jdk就对synchronized做了大量的优化，这时候我们就不能称呼它为重量锁了，有的时候它也是很<strong>轻</strong>的，那么接下来我们就调调，synchronized是怎么被优化的，它跟偏向锁、轻量锁、重量锁又有什么渊源。</p><a id="more"></a><h1 id="synchronized"><a class="markdownIt-Anchor" href="#synchronized"></a> synchronized</h1><p>回顾一下synchronized是怎么使用的呢。</p><h2 id="1-同步普通方法"><a class="markdownIt-Anchor" href="#1-同步普通方法"></a> 1、同步普通方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span>  <span class="title">sync1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do somethings</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该方法中，synchronized锁的是当前实例的对象</p><h2 id="2-同步静态方法"><a class="markdownIt-Anchor" href="#2-同步静态方法"></a> 2、同步静态方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sync2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do somethings</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于该方法是一个静态方法，那么它锁的当前类的class对象。</p><h2 id="3-同步方法快"><a class="markdownIt-Anchor" href="#3-同步方法快"></a> 3、同步方法快</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sync3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// do somethings</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sync4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(MyTest.css) &#123;</span><br><span class="line">        <span class="comment">// do somethings</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么同步方法快是需要根据方法中具体同步的对象来实现的。</p><p>在上面代码中其实<code>sync3()</code>跟同步普通方法一样，锁的是当前实例对象；那么<code>sync4</code>方法就与同步静态方法一样，锁的是当前类的class对象。</p><p>从上面代码可以看出来的，我们通过使用<code>synchronized</code>关键字可以很简单的解决并发问题，但是其实是jvm底层通过使用一种叫内置锁的手段，简化了开发人员实现并发的复杂度，在jdk1.6以前 synchronized是基于重量锁实现的，即每次遇到同步代码都要获取锁，然后释放锁，在jdk1.6之后对其优化，根据不同场景使用不同的策略，这也就是 偏向锁、轻量锁、重量锁的来由。在介绍他们之前我先介绍一下另一个锁-自旋锁。听到这么多锁，是不是头晕，当初我学习的时候也是这样的。但是当你慢慢学习深入，你就会很容易的理解每个锁的作用。</p><h1 id="自旋锁"><a class="markdownIt-Anchor" href="#自旋锁"></a> 自旋锁</h1><p>自旋锁顾名思义，就是自己旋转转圈等待，那么它有什么作用呢？</p><ul><li>当前线程尝试去竞争锁</li><li>竞争失败，准备阻塞自己</li><li>但是并没有阻塞自己，而是采用自旋锁，进入自旋状态</li><li>进入自旋状态，并且重新不断竞争锁</li><li>如果在自旋期间成功获取锁，那么结束自旋状态，否则进入阻塞状态</li></ul><blockquote><p>如果在自旋期间成功获取锁，那么就减少一次线程的切换。</p></blockquote><p>根据上面解释我们可以很容易的明白自旋锁的意义，因为cpu从内核态切换至用户态，线程的阻塞与恢复会浪费资源的，但是通过自旋而不是去阻塞当前线程，那么就会节省这个一个cpu状态切换。</p><p>所以自旋锁适合在** 持有锁的时间长，且竞争不激烈**的场景下使用。</p><blockquote><p>使用-XX:-UseSpinning参数关闭自旋锁优化；-XX:PreBlockSpin参数修改默认的自旋次数</p></blockquote><h1 id="偏向锁"><a class="markdownIt-Anchor" href="#偏向锁"></a> 偏向锁</h1><p>在实际场景中，如果一个同步方法，没有多线程竞争，并且总是由同一个线程多次获取锁，如果每次还有阻塞线程，唤醒cpu从用户态转核心态，那么对于cpu是一种资源的浪费，为了解决这类问题，旧引入了偏向锁的概念。</p><p>“偏向”的意思是，<em>偏向锁假定将来只有第一个申请锁的线程会使用锁</em>（不会有任何线程再来申请锁），因此，<em>只需要在Mark Word中CAS记录owner（本质上也是更新，但初始值为空），如果记录成功，则偏向锁获取成功</em>，记录锁状态为偏向锁，<em>以后当前线程等于owner就可以零成本的直接获得锁；否则，说明有其他线程竞争，膨胀为轻量级锁</em>。</p><p>具体的步骤如下</p><ul><li><p>访问同步代码块</p></li><li><p>检查对象头是否owner是否存储当前现成的id</p></li><li><p>如果没有，进行CAS尝试替换mark word中的owner  如果有执行同步代码（代表获取锁成功）</p></li><li><p>修改成功 （代表无竞争）owner修改为当前线程id,执行同步代码 修改失败(代表有竞争) 进入撤销偏向锁，暂停线程并将owner置空，进入轻量锁。</p></li></ul><p><img src="http://cdn.yukonga.cn/2019-05-07-062340.jpg" alt=""></p><p>偏向锁无法使用自旋锁优化，因为一旦有其他线程申请锁，就破坏了偏向锁的假定。</p><blockquote><p>如果你确定应用程序中所有的锁通常是在竞争状态，你可以通过JVM参数关闭偏向锁</p><p>UseBiasedLocking = false，那么程序会默认进入轻量锁状态。</p></blockquote><h1 id="轻量锁"><a class="markdownIt-Anchor" href="#轻量锁"></a> 轻量锁</h1><p>如果说偏向锁是为了解决同步代码在单线程下访问性能问题，那么轻量锁是为了解决<strong>减少无实际竞争情况下，使用重量级锁产生的性能消耗</strong></p><p>轻量锁，顾名思义，轻量是相对于重量的问题，使用轻量锁时，不需要申请互斥量(mutex)</p><p>,而是将mark word中的信息复制到当前线程的栈中，然后通过cas尝试修改mark word并替换成轻量锁，如果替换成功则执行同步代码。如果此时有线程2来竞争，并且他也尝试cas修改mark word但是失败了，那么线程2会进入自旋状态，如果在自旋状态也没有修改成功，那么轻量锁将膨胀成状态，mark word会被修改成重量锁标记(10) ,线程进入阻塞状态。</p><p>当然，由于轻量级锁天然瞄准不存在锁竞争的场景，如果存在锁竞争但不激烈，仍然可以用自旋锁优化，<em>自旋失败后再膨胀为重量级锁</em>。</p><h1 id="重量锁"><a class="markdownIt-Anchor" href="#重量锁"></a> 重量锁</h1><p>在jvm规范中，synchronized是基于监视器锁(monitor)来实现的，它会在同步代码之前添加一个<code>monitorenter</code>指令，获取到该对象的monitor，同时它会在同步代码结束处和异常处添加一个<code>monitorexit</code>指令去释放该对象的monitor,需要注意的是每一个对象都有一个monitor与之配对，当一个monitor被获取之后 也就是被<code>monitorenter</code>，它会处于一个锁定状态，其他尝试获取该对象的monitor的线程会获取失败，只有当获取该对象的monitor的线程执行了<code>monitorexit</code>指令后，其他线程才有可能获取该对象的monitor成功。</p><p>所以从上面描述可以得出，监视器锁就是<code>monitor</code>它是互斥的(mutex)。由于它是互斥的，那么它的操作成本就非常的高，包括系统调用引起的内核态与用户态切换、线程阻塞造成的线程切换等。因此，后来称这种锁为“重量级锁”。</p><h1 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h1><p>偏向锁、轻量级锁、重量级锁适用于不同的并发场景：</p><ul><li>偏向锁：无实际竞争，且将来只有第一个申请锁的线程会使用锁。</li><li>轻量级锁：无实际竞争，多个线程交替使用锁；允许短时间的锁竞争。</li><li>重量级锁：有实际竞争，且锁竞争时间长。</li></ul><p>另外，如果锁竞争时间短，可以使用自旋锁进一步优化轻量级锁、重量级锁的性能，减少线程切换。</p><p>如果锁竞争程度逐渐提高（缓慢），那么从偏向锁逐步膨胀到重量锁，能够提高系统的整体性能。<br>同时需要注意<strong>锁可以升级，但是不能降级</strong>。</p><p>另外通过这次学习，大家应该也知道自从jdk1.6以后 <code>synchronized</code>已经被优化了，性能不会比<code>Lock</code>差</p><p>所以jdk.16版本及其以后版本的同学可以放心大胆的使用了。</p><p>最后附一张从偏向锁膨胀至重量锁的完全的流程图</p><p><img src="http://cdn.yukonga.cn/2019-05-07-062353.jpg" alt=""></p><p>欢迎大家关注一下我的个人公众号。一起交流一起学习，有问必答。</p><p><img src="http://cdn.yukonga.cn/2019-05-07-055539.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在多线程并发编程中，synchronized一直都是元老级别的角色，人们都通常称呼它为&lt;strong&gt;重量锁&lt;/strong&gt;，但是在jdk1.6版本之后，jdk就对synchronized做了大量的优化，这时候我们就不能称呼它为重量锁了，有的时候它也是很&lt;strong&gt;轻&lt;/strong&gt;的，那么接下来我们就调调，synchronized是怎么被优化的，它跟偏向锁、轻量锁、重量锁又有什么渊源。&lt;/p&gt;
    
    </summary>
    
      <category term="java并发编程实战" scheme="http://www.yukonga.cn/categories/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="java" scheme="http://www.yukonga.cn/tags/java/"/>
    
      <category term="多线程" scheme="http://www.yukonga.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="synchronized" scheme="http://www.yukonga.cn/tags/synchronized/"/>
    
  </entry>
  
  <entry>
    <title>【SpringBoot2.0系列11】SpringBoot之@Elasticsearch完成CURD</title>
    <link href="http://www.yukonga.cn/2018/09/04/%E3%80%90SpringBoot2-0%E7%B3%BB%E5%88%9711%E3%80%91SpringBoot%E4%B9%8B-Elasticsearch%E5%AE%8C%E6%88%90CURD/"/>
    <id>http://www.yukonga.cn/2018/09/04/【SpringBoot2-0系列11】SpringBoot之-Elasticsearch完成CURD/</id>
    <published>2018-09-04T10:37:47.000Z</published>
    <updated>2019-05-07T06:07:34.476Z</updated>
    
    <content type="html"><![CDATA[<p>ElasticSearch是一个基于Lucene的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。Elasticsearch是用Java开发的，并作为Apache许可条款下的开放源码发布，是当前流行的企业级搜索引擎。设计用于<a href="https://baike.baidu.com/item/%E4%BA%91%E8%AE%A1%E7%AE%97/9969353" target="_blank" rel="noopener">云计算</a>中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。</p><a id="more"></a><p>如果在springboot使用Easticsearch呢。在这里我们使用spring-boot-starter-data-elasticsearch。<br>它提供一系列简单的api给我们使用，让我们有种操作关系数据库的感觉。<br>好了话不多说，先说一下环境。</p><ul><li>spring boot2.x</li><li>jdk8</li><li>elasticsearch5.x(6.x也可以)</li></ul><h2 id="依赖"><a class="markdownIt-Anchor" href="#依赖"></a> 依赖</h2><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">&lt;!-- lombok --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.16.22<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- elasticsearch --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-elasticsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这里我们分别引入elasticsearch跟lombok的依赖，关于lombok的介绍大家可以看看<a href="https://blog.csdn.net/motui/article/details/79012846" target="_blank" rel="noopener">这篇文章</a> 讲的很详细。我这简单的介绍一下在项目中使用Lombok可以减少很多重复代码的书写。比如说getter/setter/toString等方法的编写。</p><h2 id="配置es地址"><a class="markdownIt-Anchor" href="#配置es地址"></a> 配置es地址</h2><p>在下文中我将用es代替elasticsearch。我们打开application.yml文件 配置如下</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line"><span class="attr">  elasticsearch:</span></span><br><span class="line">    <span class="comment"># 集群的名字</span></span><br><span class="line"><span class="attr">    cluster-name:</span> <span class="string">wali</span></span><br><span class="line">    <span class="comment"># 节点的ip与端口 注意端口是9300不是9200</span></span><br><span class="line"><span class="attr">    cluster-nodes:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9300</span></span><br></pre></td></tr></table></figure><h2 id="构建文档对象"><a class="markdownIt-Anchor" href="#构建文档对象"></a> 构建文档对象</h2><p>假设这是一个商品索引goods，他有一个类型是电脑computer。<br>分别有四个字段</p><ul><li>id  唯一标识</li><li>name 商品名称</li><li>number 商品数量</li><li>desc 商品具体描述<br>我们根据上面的描述，编写出对应的实体类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@Accessors</span>(chain = <span class="keyword">true</span>)</span><br><span class="line"><span class="meta">@Document</span>(indexName = <span class="string">"goods"</span>, type = <span class="string">"computer"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Good</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 主键,注意这个搜索是id类型是string，与我们常用的不同</span></span><br><span class="line"><span class="comment">     * Id注解加上后，在Elasticsearch里相应于该列就是主键了，在查询时就可以直接用主键查询</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer number;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>@Data @ToString @Accessors(chain = true)</code> 是属于lombok注解。</p><ul><li>@Data 会自动上传get/set方法</li><li>@ToString 会生成tostring方法</li><li>@Accessors(chain = true) 会让我们set方法可以链式调用<br>@Document注解</li></ul><p><code>@Document</code>注解里面的几个属性，类比mysql的话是这样：<br>indexName –&gt; 索引库的名称，建议以项目的名称命名，就相当于数据库DB<br>type –&gt; 类型，建议以实体的名称命名Table ，就相当于数据库中的表table<br>Document –&gt; row 就相当于某一个具体对象</p><h2 id="jpa构建文档库"><a class="markdownIt-Anchor" href="#jpa构建文档库"></a> jpa构建文档库</h2><p>接着，我们可以通过jpa构建文档库，来操作我们的goods对应的文档。<br>因为我们引入的是spring data的elasticsearch所以它遵循spring data的接口，也就是说操作elasticSearch与操作spring data jpa的方法是完全一样的，我们只将文档库继承ElasticsearchRepository即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GoodRepository</span> <span class="keyword">extends</span> <span class="title">ElasticsearchRepository</span>&lt;<span class="title">Good</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据商品名称查询 分页</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pageable</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Page&lt;Good&gt; <span class="title">findByName</span><span class="params">(String name, Pageable pageable)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后创建对应的测试类。前面说过快捷键<code>ctrl+shift+t</code><br>并且编写测试方法，我们分别需要测试添加 删除 修改  查询 分页查询方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@FixMethodOrder</span>(MethodSorters.NAME_ASCENDING)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoodRepositoryTest</span> <span class="keyword">extends</span> <span class="title">Chapter10ApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> GoodRepository goodRepository;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findByName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码我们是通过基础<code>主测试类</code>然后使用<code>@Component</code>注解就可以，这样就不需要每个测试都要<code>@SpringTest注解与@RunWith注解了</code><br>另外<code>@FixMethodOrder(MethodSorters.NAME_ASCENDING)</code>这个注解是表示按照方法名的顺序来排序，不然它不会按照我们方法书写的顺序执行，那么就有可能导致，还没save就select，这样就会失败了。<br>接下来继续编写方法体。<code>goodRepository</code>跟我们直接<code>data-jpa</code>的<code>respository</code>用法基本一致。都有继承<code>save,delete,find</code>方法的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Good good = <span class="keyword">new</span> Good();</span><br><span class="line">        good.setId(<span class="string">"100"</span>)</span><br><span class="line">                .setName(<span class="string">"联想e541"</span>)</span><br><span class="line">                .setDesc(<span class="string">"联想e系列"</span>)</span><br><span class="line">                .setNumber(<span class="number">10</span>);</span><br><span class="line">        Good result = goodRepository.save(good);</span><br><span class="line">        Assert.assertNotNull(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 需要注意find方法返回的死Optional对象 需要调用get方法返回具体的实体类对象</span></span><br><span class="line">        Good result = goodRepository.findById(<span class="string">"100"</span>).get();</span><br><span class="line">        Assert.assertNotNull(result);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Good result = goodRepository.findById(<span class="string">"100"</span>).get();</span><br><span class="line">        result.setNumber(<span class="number">300</span>);</span><br><span class="line">        <span class="comment">// 更新也是调用save方法</span></span><br><span class="line">        Good good = goodRepository.save(result);</span><br><span class="line">        Assert.assertNotNull(good);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span></span>&#123;</span><br><span class="line">        goodRepository.deleteById(<span class="string">"100"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们首先测试增删改查方法。并且通过Assert断言来判断。</p><p><img src="https://upload-images.jianshu.io/upload_images/5338436-7cfb53c208dcaab7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>测试通过，<br>接下来我测试一下分页查询方法，首页我们看一下es中、goods索引computer类别下有哪些文档。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET  <span class="string">'http://127.0.0.1:9200/goods/computer/_search?pretty'</span></span><br></pre></td></tr></table></figure><p>结果如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"took"</span> : <span class="number">21</span>,</span><br><span class="line">  <span class="attr">"timed_out"</span> : <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"_shards"</span> : &#123;</span><br><span class="line">    <span class="attr">"total"</span> : <span class="number">5</span>,</span><br><span class="line">    <span class="attr">"successful"</span> : <span class="number">5</span>,</span><br><span class="line">    <span class="attr">"skipped"</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"failed"</span> : <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"hits"</span> : &#123;</span><br><span class="line">    <span class="attr">"total"</span> : <span class="number">3</span>,</span><br><span class="line">    <span class="attr">"max_score"</span> : <span class="number">1.0</span>,</span><br><span class="line">    <span class="attr">"hits"</span> : [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"_index"</span> : <span class="string">"goods"</span>,</span><br><span class="line">        <span class="attr">"_type"</span> : <span class="string">"computer"</span>,</span><br><span class="line">        <span class="attr">"_id"</span> : <span class="string">"_search"</span>,</span><br><span class="line">        <span class="attr">"_score"</span> : <span class="number">1.0</span>,</span><br><span class="line">        <span class="attr">"_source"</span> : &#123;</span><br><span class="line">          <span class="attr">"id"</span> : <span class="string">"_search"</span>,</span><br><span class="line">          <span class="attr">"name"</span> : <span class="string">"macbook"</span>,</span><br><span class="line">          <span class="attr">"number"</span> : <span class="number">20</span>,</span><br><span class="line">          <span class="attr">"desc"</span> : <span class="string">"macbook air"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"_index"</span> : <span class="string">"goods"</span>,</span><br><span class="line">        <span class="attr">"_type"</span> : <span class="string">"computer"</span>,</span><br><span class="line">        <span class="attr">"_id"</span> : <span class="string">"2"</span>,</span><br><span class="line">        <span class="attr">"_score"</span> : <span class="number">1.0</span>,</span><br><span class="line">        <span class="attr">"_source"</span> : &#123;</span><br><span class="line">          <span class="attr">"id"</span> : <span class="string">"2"</span>,</span><br><span class="line">          <span class="attr">"name"</span> : <span class="string">"think pad"</span>,</span><br><span class="line">          <span class="attr">"number"</span> : <span class="number">20</span>,</span><br><span class="line">          <span class="attr">"desc"</span> : <span class="string">"联想旗下thinkpad系列"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"_index"</span> : <span class="string">"goods"</span>,</span><br><span class="line">        <span class="attr">"_type"</span> : <span class="string">"computer"</span>,</span><br><span class="line">        <span class="attr">"_id"</span> : <span class="string">"1"</span>,</span><br><span class="line">        <span class="attr">"_score"</span> : <span class="number">1.0</span>,</span><br><span class="line">        <span class="attr">"_source"</span> : &#123;</span><br><span class="line">          <span class="attr">"id"</span> : <span class="string">"1"</span>,</span><br><span class="line">          <span class="attr">"name"</span> : <span class="string">"macbook"</span>,</span><br><span class="line">          <span class="attr">"number"</span> : <span class="number">20</span>,</span><br><span class="line">          <span class="attr">"desc"</span> : <span class="string">"macbook pro"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我看到在computer类别中存有三条文档，name分别是 <code>macbook</code> <code>think pad</code> <code>macbook</code>,所以我们查询一下name=macbook的文档，pageSize=1,pageNum=1.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findByName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String name = <span class="string">"macbook"</span>;</span><br><span class="line">        Pageable pageable = <span class="keyword">new</span> PageRequest(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        Page&lt;Good&gt; goods = goodRepository.findByName(name, pageable);</span><br><span class="line">        System.out.println(goods.getContent());</span><br><span class="line">        Assert.assertEquals(<span class="number">1</span>, goods.getSize());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们查询name为macbook的数据，并且限制每页一条，所以我们查询的结果总数应该是一条。结果如下。<br><img src="http://cdn.yukonga.cn/2019-05-07-060723.jpg" alt=""></p><p>在这节，我们了解了springboot与es的curd操作，都是比较简单的，那么下节我们会详细了解springboot对es如何进行复杂查询，与聚合查询。<br>最后本节的配套代码地址为<a href="https://github.com/YuKongEr/SpringBoot-Study/tree/master/chapter10" target="_blank" rel="noopener">https://github.com/YuKongEr/SpringBoot-Study/tree/master/chapter10</a></p><p>最后欢迎大家关注一下我的个人公众号。一起交流一起学习，有问必答。<br><img src="http://cdn.yukonga.cn/2019-05-07-055539.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ElasticSearch是一个基于Lucene的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。Elasticsearch是用Java开发的，并作为Apache许可条款下的开放源码发布，是当前流行的企业级搜索引擎。设计用于&lt;a href=&quot;https://baike.baidu.com/item/%E4%BA%91%E8%AE%A1%E7%AE%97/9969353&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;云计算&lt;/a&gt;中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。&lt;/p&gt;
    
    </summary>
    
      <category term="SpringBoot" scheme="http://www.yukonga.cn/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="http://www.yukonga.cn/tags/SpringBoot/"/>
    
      <category term="ElasticSearch" scheme="http://www.yukonga.cn/tags/ElasticSearch/"/>
    
  </entry>
  
  <entry>
    <title>【java并发编程实战3】解密volatile</title>
    <link href="http://www.yukonga.cn/2018/09/03/%E3%80%90java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%983%E3%80%91%E8%A7%A3%E5%AF%86volatile/"/>
    <id>http://www.yukonga.cn/2018/09/03/【java并发编程实战3】解密volatile/</id>
    <published>2018-09-03T11:19:22.000Z</published>
    <updated>2019-05-07T06:24:45.274Z</updated>
    
    <content type="html"><![CDATA[<p>自从jdk1.5以后，<code>volatile</code>可谓发生了翻天覆地的变化，从一个一直被吐槽的关键词，变成一个轻量级的线程通信代名词。</p><a id="more"></a><p>接下来我们将从以下几个方面来分析以下<code>volatile</code>。</p><ul><li><p>重排序与<code>as if serial</code>的关系</p></li><li><p><code>volatile</code>的特点</p></li><li><p><code>volatile</code>的内存语义</p></li><li><p><code>volatile</code>的使用场景</p></li></ul><h2 id="重排序与as-if-serial的关系"><a class="markdownIt-Anchor" href="#重排序与as-if-serial的关系"></a> 重排序与as if serial的关系</h2><p>重排序值得是编译器与处理器为了优化程序的性能，而对指令序列进行重新排序的。</p><p>但是并不是什么情况下都可以重排序的，</p><ul><li><p>数据依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span>;<span class="comment">// 1</span></span><br><span class="line">b = <span class="number">2</span>;<span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>在这种情况，1、2不存在数据依赖，是可以重排序的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span>;<span class="comment">// 1</span></span><br><span class="line">b = a;<span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>在这种情况，1、2存在数据依赖，是禁止重排序的。</p></li><li><p><code>as if serial</code></p><p>简单的理解就是。不管怎么重排序，在单线程情况下程序的执行结果是一致。</p></li></ul><p>根据 <code>as if serial</code>原则，它强调了单线程。那么多线程发生重排序又是怎么样的呢？</p><p>请看下面代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileExample1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 共享变量 name</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String name = <span class="string">"init"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 共享变量 flag</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread threadA = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            name = <span class="string">"yukong"</span>;<span class="comment">// 1</span></span><br><span class="line">            flag = <span class="keyword">true</span>;<span class="comment">// 2</span></span><br><span class="line">        &#125;);</span><br><span class="line">        Thread threadB = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;   <span class="comment">// 3</span></span><br><span class="line">                System.out.println(<span class="string">"flag = "</span> + flag + <span class="string">" name = "</span> +name);  <span class="comment">// 4</span></span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，name输出一定是<code>yukong</code>吗，答案是不一定，根据<code>happen-before</code>原则与<code>as if serial</code></p><p>原则，由于 1、2不存在依赖关系，可以重排序，操作3、操作4也不存在数据依赖，也可以重排序。</p><p>那么就有可能发生下面的情况</p><p><img src="http://cdn.yukonga.cn/2019-05-07-062415.jpg" alt=""></p><p>上图中，操作1与操作2发生了重排序，程序运行的时候，线程A先将flag更改成true，然后线程B读取flag变量并且判断，由于此时flag已经是true，线程B将继续读取name的值，由于此时线程name的值还没有被线程A写入，那么线程此时输出的name就是初始值，因为在多线程的情况下，重排序存在线程安全问题。</p><h2 id="volatile的特点"><a class="markdownIt-Anchor" href="#volatile的特点"></a> volatile的特点</h2><p><code>volatile</code>变量具有以下的特点。</p><ul><li>可见性。对于一个<code>volatile</code>变量的读，总是能看到任意线程对这个变量的最后的修改。</li><li>有序性。对于存在指令重排序的情况，<code>volatile</code>会禁止部分指令重排序。</li></ul><p>这里我先介绍一下<code>volatile</code>关键词的特点，接下来我们将会从它的内存语义来解释，为什么它会具有以上的特点，以及它使用的场景。</p><h2 id="volatile的内存语义"><a class="markdownIt-Anchor" href="#volatile的内存语义"></a> volatile的内存语义</h2><ul><li>当写一个<code>volatile</code>变量时，JMM会<strong>立即</strong>将本地变量中对应的共享变量值刷新到主内存中。</li><li>当读一个<code>volatile</code>变量时，JMM会将线程本地变量存储的值，置为无效值，线程接下来将从主内存中读取共享变量。</li></ul><p>如果一个场景存在对<code>volatile</code>变量的读写场景，在读线程B读一个<code>volatile</code>变量后，，写线程A在写这个<code>volatile</code>变量前所有的所见的共享变量的值都将会立即变得对读线程B可见。</p><p>那么这种内存语义是怎么实现的呢？</p><p>其实编译器生产字节码的时候，会在指令序列中插入内存屏障来禁止指令排序。下面就是JMM内存屏障插入的策略。</p><ul><li>在每一个volatile写操作前插入一个StoreStore屏障</li><li>在每一个volatile写操作后插入一个StoreLoad屏障</li><li>在每一个volatile写操作后插入一个LoadLoad屏障</li><li>在每一个volatile读操作后插入一个LoadStore屏障</li></ul><p>那么这些策略中，插入这些屏障有什么作用呢？我们逐条逐条分析一下。</p><ul><li>在每一个volatile写操作前插入一个StoreStore屏障，这条策略保证了volatile写变量与之前的普通变量写不会重排序，即是只有当volatile变量之前的普通变量写完，volatile变量才会写。 这样就保证volatile变量写不会跟它之前的普通变量写重排序</li><li>在每一个volatile写操作后插入一个StoreLoad屏障，这条策略保证了volatile写变量与之后的volatile写/读不会重排序，即是只有当volatile变量写完之后，你后面的volatile读写才能操作。 这样就保证volatile变量写不会跟它之后的普通变量读重排序</li><li>在每一个volatile读操作后插入一个LoadLoad屏障，这条策略保证了volatile读变量与之后的普通读不会重排序，即只有当前volatile变量读完，之后的普通读才能读。 这样就保证volatile变量读不会跟它之后的普通变量读重排序</li><li>在每一个volatile读操作后插入一个LoadStore屏障，这条策略保证了volatile读变量与之后的普通写不会重排序，即只有当前volatile变量读完，之后的普通写才能写。样就保证volatile变量读不会跟它之后的普通变量写重排序</li></ul><p>根据这些策略，volatile变量禁止了部分的重排序，这样也是为什么我们会说volatile具有一定的有序的原因。</p><p>根据以上分析的<code>volatile</code>的内存语义，大家也就知道了为什么前面我们提到的<code>happen-before</code>原则会有一条</p><ul><li>volatile的写happen-before与volaile的读。</li></ul><p>那么根据<code>volatile</code>的内存语义，我们只需要更改之前的部分代码，只能让它正确的执行。</p><p>即把flag定义成一个<code>volatile</code>变量即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileExample1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 共享变量 name</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String name = <span class="string">"init"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 共享变量 flag</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread threadA = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            name = <span class="string">"yukong"</span>;<span class="comment">// 1</span></span><br><span class="line">            flag = <span class="keyword">true</span>;<span class="comment">// 2</span></span><br><span class="line">        &#125;);</span><br><span class="line">        Thread threadB = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;   <span class="comment">// 3</span></span><br><span class="line">                System.out.println(<span class="string">"flag = "</span> + flag + <span class="string">" name = "</span> +name);  <span class="comment">// 4</span></span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来分析一下</p><ul><li><p>由于 flag是volatile变量 那么在volatile写之前插入一个storestore内存屏障，所以1,2不会发生重排序,即1happen before 2</p></li><li><p>由于 flag是volatile变量 那么在volatile读之后插入一个loadload内存屏障，所以3,4不会发生重排序,即3happen before 4</p></li><li><p>根据happen-before原则，volatile写happen before volatile读，即是 2happen before 3。</p></li><li><p>根据happen-before的传递性，所以1 happen before4。</p></li></ul><p><img src="http://cdn.yukonga.cn/2019-05-07-062426.jpg" alt=""></p><h1 id="volatile的使用场景"><a class="markdownIt-Anchor" href="#volatile的使用场景"></a> volatile的使用场景</h1><ul><li>标记变量，也就是上面的flag使用</li><li>double check 单例模式中</li></ul><p>下面我们看看double check的使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="keyword">null</span>)</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于为何需要这么写请参考：</p><p>《Java 中的双重检查（Double-Check）》<a href="http://www.iteye.com/topic/652440" target="_blank" rel="noopener">http://www.iteye.com/topic/652440</a></p><p>最后大家希望关注一下我的个人公众号。<br>欢迎大家关注一下我的个人公众号。一起交流一起学习，有问必答。</p><p><img src="http://cdn.yukonga.cn/2019-05-07-055539.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自从jdk1.5以后，&lt;code&gt;volatile&lt;/code&gt;可谓发生了翻天覆地的变化，从一个一直被吐槽的关键词，变成一个轻量级的线程通信代名词。&lt;/p&gt;
    
    </summary>
    
      <category term="java并发编程实战" scheme="http://www.yukonga.cn/categories/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="java" scheme="http://www.yukonga.cn/tags/java/"/>
    
      <category term="多线程" scheme="http://www.yukonga.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="volatile" scheme="http://www.yukonga.cn/tags/volatile/"/>
    
  </entry>
  
  <entry>
    <title>【java并发编程实战2】无锁编程CAS与atomic包</title>
    <link href="http://www.yukonga.cn/2018/08/30/%E3%80%90java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%982%E3%80%91%E6%97%A0%E9%94%81%E7%BC%96%E7%A8%8BCAS%E4%B8%8Eatomic%E5%8C%85/"/>
    <id>http://www.yukonga.cn/2018/08/30/【java并发编程实战2】无锁编程CAS与atomic包/</id>
    <published>2018-08-30T06:35:34.000Z</published>
    <updated>2019-05-07T06:25:04.030Z</updated>
    
    <content type="html"><![CDATA[<p>无锁编程可能大家在面试的时候会被经常问道，那么何为无锁编程CAS，怎么实现无锁编程CAS？</p><a id="more"></a><h1 id="1-无锁编程cas"><a class="markdownIt-Anchor" href="#1-无锁编程cas"></a> 1、无锁编程CAS</h1><h2 id="11-cas"><a class="markdownIt-Anchor" href="#11-cas"></a> 1.1、CAS</h2><p>CAS的全称是Compare And Swap 即比较交换，其算法核心思想如下</p><blockquote><p>执行函数：CAS(V,E,N)</p></blockquote><p>其包含3个参数</p><ul><li>V表示要更新的变量</li><li>E表示预期值</li><li>N表示新值</li></ul><p>如果V值等于E值，则将V的值设为N。若V值和E值不同，则说明已经有其他线程做了更新，则当前线程什么都不做。通俗的理解就是CAS操作需要我们提供一个期望值，当期望值与当前线程的变量值相同时，说明还没线程修改该值，当前线程可以进行修改，也就是执行CAS操作，但如果期望值与当前线程不符，则说明该值已被其他线程修改，此时不执行更新操作，但可以选择重新读取该变量再尝试再次修改该变量，也可以放弃操作，原理图如下</p><p><img src="http://cdn.yukonga.cn/2019-05-07-062455.jpg" alt=""></p><p>由于CAS操作属于乐观派，它总认为自己可以成功完成操作，当多个线程同时使用CAS操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作，这点从图中也可以看出来。基于这样的原理，CAS操作即使没有锁，同样知道其他线程对共享资源操作影响，并执行相应的处理措施。同时从这点也可以看出，由于无锁操作中没有锁的存在，因此不可能出现死锁的情况，也就是说无锁操作天生免疫死锁。</p><h2 id="12-cpu指令对cas的支持"><a class="markdownIt-Anchor" href="#12-cpu指令对cas的支持"></a> 1.2、CPU指令对CAS的支持</h2><p>或许我们可能会有这样的疑问，假设存在多个线程执行CAS操作并且CAS的步骤很多，有没有可能在判断V和E相同后，正要赋值时，切换了线程，更改了值。造成了数据不一致呢？答案是否定的，因为CAS是一种系统原语，原语属于操作系统用语范畴，是由若干条指令组成的，用于完成某个功能的一个过程，并且原语的执行必须是连续的，在执行过程中不允许被中断，也就是说CAS是一条CPU的原子指令，不会造成所谓的数据不一致问题。</p><h1 id="2-atomic族类"><a class="markdownIt-Anchor" href="#2-atomic族类"></a> 2、 atomic族类</h1><p>在atomic包下共有AtomicBoolean、AtomicInteger、AtomicIntegerArray、AtmoicReference、AtomicReferenceFieldUpdater、LongAdder等类。</p><p>在上面线程不安全的例子中，我们用1000个线程调用整型变量的i的自增，然后输出i最后的大小，在多线程情况下，这明显是线程不安全的，因为<code>i++</code>不是原子操作，这里我们可以使用AtomicInteger代替Integer。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 并发线程数目</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> threadNum = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 闭锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch countDownLatch  = <span class="keyword">new</span> CountDownLatch(threadNum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger i = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; threadNum; j++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                add();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用闭锁保证当所有统计线程完成后，主线程输出统计结果。 其实这里也可以使用Thread.sleep() 让主线程阻塞等待一会儿实现</span></span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(i.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">        i.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码就是线程安全的，运行输出 i=1000,这是为什么呢。我们来看看<code>getAndIncrement()</code>方法的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Atomically increments by one the current value.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the previous value</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>我们看到方法是由一个unsafe对象的getAndAddInt方法实现。我们继续点进去看看getAndAddInt方法的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//</span></span><br><span class="line">       <span class="keyword">int</span> var5;</span><br><span class="line">       <span class="keyword">do</span> &#123;</span><br><span class="line">           var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">       &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> var5;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面就是<code>getAndAddInt</code>方法的实现,具体流程如下，</p><p>1、首先根据当前的传过来的对象指针，获取期望的值  var5,</p><p>2、然后while判断调用compareAndSwapInt方法 ，这是一个native本地方法，它有四个参数，</p><p>第一个参数，当前的对象，第二个参数实际的值，第三个参数期望的值，第四个参数想要更新的值。</p><p>只有实际的值等于期望的值的时候，才会把值更新成第四个参数，也就是想要的更新的值，否则一直循环尝试。</p><p>这也就是无锁编程，CAS。</p><p>在高并发的场景，这种循环尝试的次数会比较高，成功率会比较低，这样性能会比较差。但是在JDK8中推出了一个新的类名为<code>LongAdder</code></p><p>我们看看它的用法。我们也继续上面的求和的例子，只需要把<code>AtomicInteger</code>改成<code>LongAddr</code>然后更改对应调用的方法即可。具体代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongAdderExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 并发线程数目</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> threadNum = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 闭锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch countDownLatch  = <span class="keyword">new</span> CountDownLatch(threadNum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LongAdder i = <span class="keyword">new</span> LongAdder();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; threadNum; j++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                add();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用闭锁保证当所有统计线程完成后，主线程输出统计结果。 其实这里也可以使用Thread.sleep() 让主线程阻塞等待一会儿实现</span></span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">        i.increment();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序，发现结果与预期的一样i=1000，是线程安全的。那么我们看看它又是如何。保证线程安全的呢。</p><p>由于篇幅原因我不跟入源码讲解了，大致思想与ConcurrentHashMapy大致一致，采用的是热点分离法，</p><p>把value分成base+cells数组，避免所有的写操作都是在value上面，这样就保证提高性能，但是在多线程情况下，统计会有误差。</p><p>接着我们讲解CAS中常常会遇到的ABA问题。</p><p>比如说一个线程one从内存位置V中取出A，这时候另一个线程two也从内存中取出A，并且two进行了一些操作变成了B，然后two又将V位置的数据变成A，这时候线程one进行CAS操作发现内存中仍然是A，然后one操作成功。尽管线程one的CAS操作成功，但是不代表这个过程就是没有问题的。如果链表的头在变化了两次后恢复了原值，但是不代表链表就没有变化。</p><p>这里我们可以借助乐观锁的一个概念，使用version版本号来判断是否一致，每次操作后版本号加1如果两次对比版本号一致才交换，这样就避免了ABA问题，在atomic包下面也提供了对应的类<code>AtomicStampedReference</code>。</p><p><code>AtomicStampedReference</code>每次操作前判断更新的时间戳与预期的时间戳是否一致，这样就巧妙的避免了ABA问题。</p><p>最后大家希望关注一下我的个人公众号。<br>欢迎大家关注一下我的个人公众号。一起交流一起学习，有问必答。</p><p><img src="http://cdn.yukonga.cn/2019-05-07-055539.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;无锁编程可能大家在面试的时候会被经常问道，那么何为无锁编程CAS，怎么实现无锁编程CAS？&lt;/p&gt;
    
    </summary>
    
      <category term="java并发编程实战" scheme="http://www.yukonga.cn/categories/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="java" scheme="http://www.yukonga.cn/tags/java/"/>
    
      <category term="多线程" scheme="http://www.yukonga.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="CAS" scheme="http://www.yukonga.cn/tags/CAS/"/>
    
      <category term="atomic" scheme="http://www.yukonga.cn/tags/atomic/"/>
    
  </entry>
  
  <entry>
    <title>【java并发编程实战1】何为线程安全性</title>
    <link href="http://www.yukonga.cn/2018/08/29/%E3%80%90java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%981%E3%80%91%E4%BD%95%E4%B8%BA%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7/"/>
    <id>http://www.yukonga.cn/2018/08/29/【java并发编程实战1】何为线程安全性/</id>
    <published>2018-08-29T11:17:02.000Z</published>
    <updated>2019-05-07T06:25:27.596Z</updated>
    
    <content type="html"><![CDATA[<p>多线程问题，一直是我们老生常谈的一个问题，在面试中也会被经常问到，如何去学习理解多线程，何为线程安全性，那么大家跟我的脚步一起来学习一下。</p><a id="more"></a><h1 id="线程安全性"><a class="markdownIt-Anchor" href="#线程安全性"></a> 线程安全性</h1><p>定义：</p><blockquote><p>当多个线程访问某个类时，不管运行时环境采用<strong>何种调度方式</strong> 或者这些线程如何交替执行，并且在主调代码中<strong>不需要任何额外的同步或者协同</strong>，这个类都能表现<strong>正确的行为</strong>,那么称这个类时线程安全的。</p></blockquote><p>线程的安全性主要体现在三个方法</p><ul><li>原子性：即不可分割，提供互斥访问，同一时刻只能有一个线程对它进行操作</li><li>可见性：一个线程对共享变量的修改，可以及时被其他线程观察到</li><li>有序性：序在执行的时候，程序的代码执行顺序和语句的顺序是一致的。</li></ul><h2 id="1-原子性"><a class="markdownIt-Anchor" href="#1-原子性"></a> 1、原子性</h2><p>1、访问（读/写）某个共享变量的操作从其执行线程以外的线程来看，该操作要么已经执行结果，有么尚未执行，也就是说其他线程不会看到“该操作执行了部分的效果”。</p><p>2、访问同一组共享变量的原子操作 不能够被交错的。</p><p>在java中实现原子性的两种方式：</p><ul><li><p>使用CAS也是atomic包下的类。</p></li><li><p>使用锁</p></li></ul><blockquote><p>在java语言中，除long/double之外的任何类型的变量的写操作都是原子操作。</p><p>java语言中任何变量的读操作都是原子操作。</p><p>需要注意的是 原子操作 + 原子操作  != 原子操作</p><p>例如 i++ 先读后写  读跟写都是原子操作，但是 i++并不是原子操作</p></blockquote><p>下面用代码讲一下实现的两种方式</p><p>例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yukong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/8/29</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 线程不安全</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 并发线程数目</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> threadNum = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 闭锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch countDownLatch  = <span class="keyword">new</span> CountDownLatch(threadNum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer i = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; threadNum; j++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                add();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用闭锁保证当所有统计线程完成后，主线程输出统计结果。 其实这里也可以使用Thread.sleep() 让主线程阻塞等待一会儿实现</span></span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码很明显因为i++不是原子性操作，所以不是线程安全的。</p><p>那么根据上面讲的，我们可以使用锁，或者atomic包下的类实现。</p><h2 id="2-可见性"><a class="markdownIt-Anchor" href="#2-可见性"></a> 2、可见性</h2><p>一个线程对共享变量的修改能够及时被其他线程所观察。</p><p>这句话怎么理解呢？</p><p>在JMM（Java Memory Model）的定义中，所有的变量都需要存储在主体内存中，主内存是共享内存区域，所有的线程都能访问的，但是线程对变量的操作（读、写）必须在工作内存中完成。</p><p>1、首先将变量从主内存中拷贝到自己的工作内存。</p><p>2、对变量进行读写操作。</p><p>3、操作完成，将变量回写到主内存中。</p><p>从上面可以得知，线程不能直接操作主内存的变量，必须要在工作内存中操作。</p><p>简单了解一下JMM的规定，那么我们就可以很容易的理解可见性了。<img src="http://cdn.yukonga.cn/2019-05-07-062515.jpg" alt=""></p><p>由上图可知 ，在多线程情况下，线程对共享变量的的操作都是拷贝一份副本到自己的工作内存中操作的，然后才写回到主内存中，这就可能存在一个问题，线程1修改了共享变量X的值，但是还未写回主内存，另外一个线程2又对主内存中的同一个共享变量x进行操作，但此时线程1工作内存中的变量x对线程n并不可以，这种工作内存与主内存同步延迟的问题就造成了可见性问题，另外指令重排序也会导致可见性问题。</p><p>那么对于可见性问题，使用什么解决方法呢？</p><ul><li>synchronized关键字</li><li>volatile关键词</li></ul><p>为什么synchronized能保证可见性呢？根据JMM关于synchronized的规定</p><ul><li>线程解锁前，必须把共享变量的最新刷新到主内存。</li><li>线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要重新从主内存中读取最新值。</li></ul><p>那么volatile又是怎么实现可见性的呢？</p><p>其实volatile是通过加入<strong>内存屏障</strong>和禁止指令<strong>重排序</strong>优化来实现的。</p><ul><li>对volatile变量写操作时，会在写操作后加入一条store屏障指令，将工作内存中的共享变量值刷新到主内存中</li><li>对于volatile变量读操作时，会在读操作前加入一条load屏障指定，从主内存读取共享变量最新的值到工作内存中。</li></ul><p>那大家可能就会想问了，我把上面的代码的i变量用<code>volatile</code>修饰一下，是不是就保证线程安全，输出的结果就是1000呢，答案是否定的，volatile保证的是可见性，并不能保证原子性。但是利用volatile可见性这个特点，我们可以利用它完全一些线程中的通信</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>; </span><br><span class="line"><span class="comment">// thread a</span></span><br><span class="line">&#123;</span><br><span class="line">    flag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// do somethings</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// thread b</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">        <span class="comment">// do somethings</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就完全一个线程中通信的案例。</p><h2 id="3-有序性"><a class="markdownIt-Anchor" href="#3-有序性"></a> 3、有序性</h2><blockquote><p>在JMM（java 内存 模型）中，运行编译器和处理器对指令就行重排序，但是重排序过程不会影响到<strong>单线程</strong>程序的执行，却会影响多线程并发执行的正确性。</p></blockquote><p>在java中，可以通过<code>volatile</code>关键字来保证一定的有序性。另外也可以通过<code>synchronized</code>和<code>Lock</code>来保证有序性。很显然，synchronized跟lock保证每个时刻是只有一个线程执行同步代码，相当于让线程属性执行同步代码，自然保证了有序性。</p><p>另外java内存模型也具备一些先天的<code>有序性</code>,即不需要通过任何手段就能够保证的有序性，这个通常也称为<code>Happen-Before</code>原则。如果两个操作的资源无法从<code>Happen-Before</code>原则推导出来，那么他们就不能保证它的有序性，虚拟机就可以随机对他们进行重排序。</p><p>那么下面就详细介绍<code>Happen-Before</code>(先行发生原则)：</p><ol><li>线程次序规则： 在一个线程内，按照代码顺序，书写在前的代码先行发生于书写在后的代码操作。</li><li>锁定原则：一个unlock操作先行发生于后面的对同一个锁的lock操作。</li><li>volatile变量原则，对同一个变量的写操作先行发生于后面对这个变量的读操作。</li><li>传递原则：如果操作A先行发生于操作B,而且操作B又先行发生于操作C，则可以得出操作A先行发生于操作C。</li><li>线程启动原则：Thread对象的start()方法先行发生于此线程的每一个操作。</li><li>线程中断原则：Thread对象的interrupt()方法先行发生于被中断线程检测到中断事件的发生</li><li>线程终结原则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束，Thread.isAlive()的返回值手段检测线程是否已经终止。</li><li>线程终结原则：一个对象的初始化完成先行发生于他的finalize()方法的开始。</li></ol><h1 id="4-总结"><a class="markdownIt-Anchor" href="#4-总结"></a> 4、总结</h1><p>如果一个操作具有以上的三种特性，那么我们称它为线程安全的。</p><p>最后欢迎大家关注一下我的个人公众号 程序咖啡厅 每天一杯逐渐成长。<br>欢迎大家关注一下我的个人公众号。一起交流一起学习，有问必答。</p><p><img src="http://cdn.yukonga.cn/2019-05-07-055539.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;多线程问题，一直是我们老生常谈的一个问题，在面试中也会被经常问到，如何去学习理解多线程，何为线程安全性，那么大家跟我的脚步一起来学习一下。&lt;/p&gt;
    
    </summary>
    
      <category term="java并发编程实战" scheme="http://www.yukonga.cn/categories/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="java" scheme="http://www.yukonga.cn/tags/java/"/>
    
      <category term="多线程" scheme="http://www.yukonga.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="并发编程" scheme="http://www.yukonga.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
</feed>
